<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SMAX Multi-Client Upgrade Hub</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        :root { 
            --primary: #2ea44f; 
            --dark: #24292e; 
            --bg: #f6f8fa; 
            --border: #d1d5da;
            --text: #24292e;
            --card-bg: #ffffff;
        }
        
        /* Dark mode variables */
        body.dark-mode {
            --dark: #f6f8fa;
            --bg: #0d1117;
            --border: #30363d;
            --text: #c9d1d9;
            --card-bg: #161b22;
        }
        
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif; 
            background: var(--bg); 
            margin: 0; 
            color: var(--text);
            transition: background 0.3s, color 0.3s;
        }
        
        /* Header & Controls */
        .header { background: var(--dark); color: white; padding: 1rem 2rem; display: flex; justify-content: space-between; align-items: center; }
        .controls { display: flex; gap: 12px; flex-wrap: wrap; background: #fff; padding: 15px 2rem; border-bottom: 1px solid var(--border); position: sticky; top: 0; z-index: 100; align-items: center; position: relative; }
        
        /* Layout */
        .container { max-width: 1000px; margin: 20px auto; padding: 0 20px; }
        .card { background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; padding: 16px; margin-bottom: 16px; position: relative; }
        .step-done { background: #f0fff4; border-left: 6px solid var(--primary); }
        body.dark-mode .step-done { background: #0d3818; }
        
        /* Elements */
        pre { background: #1b1f23; color: #e1e4e8; padding: 16px; border-radius: 6px; overflow-x: auto; font-family: ui-monospace, monospace; font-size: 13px; position: relative; }
        .copy-btn { position: absolute; top: 8px; right: 8px; background: #0366d6; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; }
        textarea { width: 100%; margin-top: 10px; border: 1px solid var(--border); border-radius: 6px; padding: 10px; font-family: inherit; box-sizing: border-box; }
        input, select { padding: 8px 12px; border: 1px solid var(--border); border-radius: 6px; font-size: 14px; }
        
        /* Status Indicators */
        .status-area { display: flex; align-items: center; gap: 8px; font-size: 12px; }
        .indicator { width: 10px; height: 10px; border-radius: 50%; background: #d1d5da; }
        .online { background: var(--primary); box-shadow: 0 0 5px var(--primary); }
        .error-msg { background: #ffeef0; color: #d73a49; padding: 10px; border-radius: 6px; margin-bottom: 15px; display: none; border: 1px solid #f97583; }
        
        /* Stage Navigation */
        .stage-tabs { display: flex; gap: 8px; background: var(--card-bg); padding: 15px 2rem; border-bottom: 1px solid var(--border); overflow-x: auto; }
        .stage-tab { padding: 10px 20px; border-radius: 6px 6px 0 0; cursor: pointer; background: var(--bg); border: 1px solid var(--border); border-bottom: none; transition: all 0.2s; white-space: nowrap; }
        .stage-tab:hover { background: #e1e4e8; }
        body.dark-mode .stage-tab:hover { background: #21262d; }
        .stage-tab.active { background: var(--card-bg); border-bottom: 2px solid var(--card-bg); margin-bottom: -1px; font-weight: 600; color: var(--primary); }
        
        /* Progress Indicator */
        .progress-bar { height: 8px; background: var(--bg); border-radius: 4px; margin: 10px 0; overflow: hidden; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, var(--primary), #34d058); transition: width 0.3s ease; }
        
        /* Stage Navigation Buttons */
        .stage-nav { display: flex; justify-content: space-between; margin: 20px 0; }
        .stage-nav button { padding: 10px 20px; border: 1px solid var(--border); border-radius: 6px; cursor: pointer; background: var(--card-bg); font-weight: 500; color: var(--text); }
        .stage-nav button:hover { background: var(--bg); }
        .stage-nav button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        /* Markdown Notes */
        .note-section { margin-top: 15px; border-top: 1px solid var(--border); padding-top: 15px; }
        .note-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .note-header h5 { margin: 0; color: #586069; font-size: 14px; }
        .note-toggle { background: none; border: none; color: var(--primary); cursor: pointer; font-size: 12px; text-decoration: underline; }
        .note-editor { display: none; }
        .note-editor.active { display: block; }
        .note-content.editing .note-preview { display: none; }
        .note-content.editing .note-textarea { display: block; }
        .note-content:not(.editing) .note-preview { display: block; }
        .note-content:not(.editing) .note-textarea { display: none; }
        .note-preview { background: var(--bg); border: 1px solid var(--border); border-radius: 6px; padding: 12px; min-height: 40px; color: var(--text); }
        .note-preview h1, .note-preview h2, .note-preview h3 { margin-top: 0; }
        .note-preview code { background: #1b1f23; color: #e1e4e8; padding: 2px 6px; border-radius: 3px; font-family: ui-monospace, monospace; }
        .note-preview pre { background: #1b1f23; color: #e1e4e8; padding: 12px; border-radius: 6px; overflow-x: auto; }
        .note-preview pre code { background: none; padding: 0; }
        .note-preview ul, .note-preview ol { padding-left: 25px; }
        .note-preview blockquote { border-left: 4px solid var(--border); padding-left: 15px; color: #586069; margin: 10px 0; }
        
        /* Reset Button */
        .reset-btn { background: #d73a49; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500; }
        .reset-btn:hover { background: #cb2431; }
        
        /* Modal */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.4); }
        .modal-content { background-color: var(--card-bg); margin: 15% auto; padding: 20px; border: 1px solid var(--border); border-radius: 6px; width: 400px; max-width: 90%; }
        .modal-buttons { display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px; }
        
        /* Inline editing */
        .editable { cursor: pointer; padding: 2px 6px; border-radius: 4px; transition: background 0.2s; }
        .editable:hover { background: var(--bg); }
        .editing { background: var(--card-bg); border: 1px solid var(--primary); padding: 4px 8px; }
        
        /* Notes toggle button */
        .note-toggle-btn { background: none; border: 1px solid var(--border); padding: 4px 12px; border-radius: 6px; cursor: pointer; color: var(--text); font-size: 12px; }
        .note-toggle-btn:hover { background: var(--bg); }
        .note-toggle-btn.has-notes { background: var(--primary); color: white; border-color: var(--primary); }
        
        /* Add buttons */
        .add-btn { background: var(--primary); color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; margin: 10px 0; }
        .add-btn:hover { background: #2c974b; }
        
        /* Autosave indicator */
        .autosave-indicator { font-size: 11px; color: #586069; margin-left: 10px; }
        
        /* Dark mode toggle */
        .theme-toggle { background: none; border: 1px solid var(--border); padding: 6px 12px; border-radius: 6px; cursor: pointer; color: var(--text); }
        .theme-toggle:hover { background: var(--bg); }
        
        /* Raw editor */
        .raw-editor { width: 100%; height: 600px; font-family: ui-monospace, monospace; font-size: 13px; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--card-bg); color: var(--text); }
        
        /* Image upload */
        .image-upload-area { border: 2px dashed var(--border); border-radius: 6px; padding: 20px; text-align: center; margin: 10px 0; cursor: pointer; }
        .image-upload-area:hover { background: var(--bg); }
        .image-upload-area.dragging { border-color: var(--primary); background: var(--bg); }
        
        /* Environment Variables Sidebar */
        .env-vars-sidebar { position: fixed; top: 300px; right: -310px; width: 300px; max-height: 70vh; overflow-y: auto; z-index: 100; box-shadow: 0 4px 12px rgba(0,0,0,0.15); transition: right 0.3s ease; }
        .env-vars-sidebar.open { right: 20px; }
        
        /* Client Menu Modal */
        .client-menu-modal { position: fixed; top: 300px; left: 50px; width: 300px; max-height: 70vh; overflow-y: auto; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        
        /* Edit Step Modal */
        .edit-step-modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 600px; max-height: 80vh; overflow-y: auto; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .menu-item { padding: 8px 12px; cursor: pointer; border-bottom: 1px solid var(--border); }
        .menu-item:hover { background: var(--border); }
        .menu-item.selected { background: var(--primary); color: white; }
        .submenu { margin-left: 20px; }
        .submenu .menu-item { border-bottom: none; }
    </style>
</head>
<body>

<div class="header">
    <strong id="appTitle">SMAX Multi-Tenant Operations</strong>
    <div class="status-area">
        <button class="theme-toggle" onclick="toggleDarkMode()" title="Toggle dark mode">
            <span id="theme-icon">üåô</span>
        </button>
        <div id="syncInd" class="indicator"></div>
        <span id="syncStat">Offline</span>
        <span id="autosave-status" class="autosave-indicator"></span>
    </div>
</div>

<div class="controls">
    <input type="password" id="ghToken" placeholder="Paste GitHub Token" onchange="connect()">
    
    <select id="selProduct" onchange="onProductChange()">
        <option value="SMAX">SMAX</option>
        <option value="OTHER">Other Products (Future)</option>
    </select>
    
    <select id="selVer" onchange="onVersionChange()">
        <option value="">Select version...</option>
    </select>

    <select id="selClient" onchange="loadData()">
        <option value="">Loading clients...</option>
    </select>

    <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
        <input type="checkbox" id="autosaveToggle" onchange="toggleAutosave()" checked />
        Autosave
    </label>

    <button onclick="saveData()" style="background: var(--primary); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
        üíæ Save Progress
    </button>
    
    <button onclick="loadData()" style="background: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
        üîÑ Refresh Data
    </button>
    
    <button onclick="showRawEditor()" style="background: #6f42c1; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
        üìù Raw Editor
    </button>
    
    <button onclick="showVersionUpgrade()" style="background: #0366d6; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
        üöÄ Upgrade to Version
    </button>
    
    <button onclick="toggleEnvVars()" id="envToggleBtn" style="background: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
        ‚öôÔ∏è Variables
    </button>
    
    <button onclick="toggleClientMenu()" id="menuToggleBtn" style="background: #17a2b8; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
        üìÅ Menu
    </button>
    
    <div class="card client-menu-modal" id="client-menu-card" style="display: none;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h4 style="margin: 0;">Clients & Versions</h4>
            <button onclick="closeClientMenu()" style="background: none; border: none; font-size: 18px; cursor: pointer; color: var(--text);">‚úï</button>
        </div>
        <div id="client-menu-content"></div>
    </div>
    
    <button onclick="showResetModal()" class="reset-btn">
        üîÑ Reset All Done Steps
    </button>
</div>

<div id="stage-tabs-container" class="stage-tabs" style="display: none;"></div>

<div class="container">
    <div id="errorBox" class="error-msg"></div>
    
    <!-- Document Title -->
    <div id="doc-title-container" style="display: none; margin-bottom: 20px;">
        <h2 id="doc-title" class="editable" onclick="editTitle()" style="margin: 0; cursor: pointer;">Document Title</h2>
    </div>
    
    <div id="progress-container" style="display: none;">
        <h4>Stage Progress</h4>
        <div class="progress-bar">
            <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
        </div>
        <div style="font-size: 12px; color: #586069; margin-top: 5px;">
            <span id="progress-text">0 of 0 steps completed</span>
        </div>
    </div>

    <div class="card env-vars-sidebar" id="env-vars-card" style="display: none;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h4 style="margin: 0;">Environment Variables</h4>
            <button onclick="closeEnvVars()" style="background: none; border: none; font-size: 18px; cursor: pointer; color: var(--text);">‚úï</button>
        </div>
        <div id="var-inputs" style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:15px;"></div>
    </div>
    
    <div class="stage-nav" id="stage-nav" style="display: none;">
        <button id="prev-stage-btn" onclick="prevStage()">‚Üê Previous Stage</button>
        <div>
            <button class="add-btn" onclick="addNewStage()">‚ûï Add New Stage</button>
        </div>
        <button id="next-stage-btn" onclick="nextStage()">Next Stage ‚Üí</button>
    </div>

    <div id="steps-list"></div>
    
    <div style="text-align: center; margin: 20px 0;" id="add-step-container" style="display: none;">
        <button class="add-btn" onclick="addNewStep()">‚ûï Add New Step to Current Stage</button>
    </div>
    
    <div class="stage-nav" id="stage-nav-bottom" style="display: none;">
        <button id="prev-stage-btn-bottom" onclick="prevStage()">‚Üê Previous Stage</button>
        <button id="next-stage-btn-bottom" onclick="nextStage()">Next Stage ‚Üí</button>
    </div>
</div>

<!-- Reset Confirmation Modal -->
<div id="resetModal" class="modal">
    <div class="modal-content">
        <h3 style="margin-top: 0;">Reset Completed Steps</h3>
        <p>Are you sure you want to reset all completed steps? This will mark all steps as incomplete.</p>
        <div class="modal-buttons">
            <button onclick="closeResetModal()" style="padding: 8px 16px; border: 1px solid var(--border); border-radius: 6px; cursor: pointer; background: white;">
                Cancel
            </button>
            <button onclick="confirmReset()" class="reset-btn">
                Reset All
            </button>
        </div>
    </div>
</div>

<!-- Raw Editor Modal -->
<div id="rawEditorModal" class="modal">
    <div class="modal-content" style="width: 80%; max-width: 900px;">
        <h3 style="margin-top: 0;">Raw Markdown Editor</h3>
        <textarea id="rawEditorContent" class="raw-editor"></textarea>
        <div class="modal-buttons">
            <button onclick="closeRawEditor()" style="padding: 8px 16px; border: 1px solid var(--border); border-radius: 6px; cursor: pointer; background: var(--card-bg); color: var(--text);">
                Cancel
            </button>
            <button onclick="saveRawEditor()" style="background: var(--primary); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                Apply Changes
            </button>
        </div>
    </div>
</div>

<!-- Version Upgrade Modal -->
<div id="versionUpgradeModal" class="modal">
    <div class="modal-content">
        <h3 style="margin-top: 0;">Upgrade to New Version</h3>
        <p>Select target version to clone this configuration:</p>
        <select id="targetVersionSelect" style="width: 100%; padding: 8px; margin: 10px 0; border: 1px solid var(--border); border-radius: 6px; background: var(--card-bg); color: var(--text);" onchange="onTargetVersionChange()">
            <option value="">Select version...</option>
        </select>
        <div id="newVersionDiv" style="display: none; margin: 10px 0;">
            <label for="newVersionInput" style="display: block; margin-bottom: 5px; font-weight: 500;">New Version Number:</label>
            <input type="text" id="newVersionInput" placeholder="e.g., 24.6" style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 6px; background: var(--card-bg); color: var(--text);">
        </div>
        <div class="modal-buttons">
            <button onclick="closeVersionUpgrade()" style="padding: 8px 16px; border: 1px solid var(--border); border-radius: 6px; cursor: pointer; background: var(--card-bg); color: var(--text);">
                Cancel
            </button>
            <button onclick="confirmVersionUpgrade()" style="background: var(--primary); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                Upgrade
            </button>
        </div>
    </div>
</div>

<!-- Edit Step Modal -->
<div id="editStepModal" class="modal edit-step-modal">
    <div class="modal-content">
        <h3 style="margin-top: 0;">Edit Step</h3>
        <textarea id="editStepContent" class="raw-editor"></textarea>
        <div class="modal-buttons">
            <button onclick="closeEditStep()" style="padding: 8px 16px; border: 1px solid var(--border); border-radius: 6px; cursor: pointer; background: var(--card-bg); color: var(--text);">
                Cancel
            </button>
            <button onclick="saveEditStep()" style="background: var(--primary); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                Apply Changes
            </button>
        </div>
    </div>
</div>

<script>
let GITHUB_TOKEN = sessionStorage.getItem('github_token') || "";
    let FILE_SHA = "";
    let CURRENT_YAML_PATH = "";
    let config = { title: "", config: {}, stages: [] };
    let currentStageIndex = 0;
    let autosaveEnabled = true;
    let autosaveTimeout = null;
    let editingStageIndex, editingStepIndex;
    let menuData = {}; // Store versions and their clients

    // Hardcoded repository information for personal use
    const OWNER = "gianandr4";
    const REPO = "SMAX-Upgrade-Tool"; 
    
    // Dynamic product path based on selection
    function getVersionsBasePath() {
        const product = document.getElementById('selProduct').value;
        return product === 'SMAX' ? 'SMAX' : product;
    } 

    // Initialize token input field if cached and auto-connect
    document.addEventListener('DOMContentLoaded', () => {
        // Set default product to SMAX
        const cachedProduct = sessionStorage.getItem('selected_product') || 'SMAX';
        document.getElementById('selProduct').value = cachedProduct;
        
        // Update app title
        const titleElement = document.getElementById('appTitle');
        titleElement.textContent = `${cachedProduct} Multi-Tenant Operations`;
        
        if (GITHUB_TOKEN) {
            document.getElementById('ghToken').value = GITHUB_TOKEN;
            connect(true); // true indicates auto-connection
        }
    });

    async function connect(autoConnect = false) {
        GITHUB_TOKEN = document.getElementById('ghToken').value;
        if (!GITHUB_TOKEN) {
            if (!autoConnect) {
                showError('Please enter a GitHub token');
            }
            return;
        }
        // Cache token in session storage
        sessionStorage.setItem('github_token', GITHUB_TOKEN);
        if (!autoConnect) {
            console.log('[SMAX Tool] Connecting with GitHub token...');
        } else {
            console.log('[SMAX Tool] Auto-connecting with cached GitHub token...');
        }
        
        // Restore product selection or default to SMAX
        const cachedProduct = sessionStorage.getItem('selected_product') || 'SMAX';
        document.getElementById('selProduct').value = cachedProduct;
        
        // Update app title
        const titleElement = document.getElementById('appTitle');
        titleElement.textContent = `${cachedProduct} Multi-Tenant Operations`;
        
        // Step 1: Dynamically find folders
        await fetchFolders();
        // Step 2: Load data for selected folder (will use cached selections or defaults)
        loadData();
    }

    // NEW: Automatically find version folders (e.g., 24.4, 25.1)
    async function fetchFolders() {
        if (!GITHUB_TOKEN) return;
        try {
            const basePath = getVersionsBasePath();
            console.log(`[SMAX Tool] Fetching folders from ${OWNER}/${REPO}/${basePath}...`);
            const resp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${basePath}`, {
                headers: { Authorization: `token ${GITHUB_TOKEN}` }
            });
            
            if (!resp.ok) {
                const errorData = await resp.json();
                throw new Error(`GitHub API: ${errorData.message || resp.statusText}`);
            }
            
            const items = await resp.json();
            const folderSelect = document.getElementById('selVer');
            
            // Clear existing options
            folderSelect.innerHTML = "";

            // Filter for directories that look like versions (numbers/dots)
            const folders = items.filter(item => item.type === 'dir' && !item.name.startsWith('.'));
            
            if (folders.length === 0) {
                showError('No version folders found in repository');
                return;
            }
            
            folders.forEach(folder => {
                const opt = document.createElement('option');
                opt.value = folder.name;
                opt.innerText = `Version ${folder.name}`;
                folderSelect.appendChild(opt);
                
                // Store in menu data
                menuData[folder.name] = [];
            });
            
            console.log(`[SMAX Tool] Found ${folders.length} version folder(s)`);
            
            renderClientMenu();
            
            // Load clients for cached version or first version
            const cachedVersion = sessionStorage.getItem('selected_version');
            const targetVersion = cachedVersion && folders.some(f => f.name === cachedVersion) ? cachedVersion : folders[0].name;
            
            if (targetVersion) {
                document.getElementById('selVer').value = targetVersion;
                await fetchClients(targetVersion);
            }
        } catch (e) {
            console.error('[SMAX Tool] fetchFolders error:', e);
            showError(`Failed to load folders: ${e.message}`);
        }
    }
    
    // NEW: Fetch clients from version folder
    async function fetchClients(version) {
        if (!GITHUB_TOKEN) return;
        try {
            const basePath = getVersionsBasePath();
            console.log(`[SMAX Tool] Fetching clients from ${basePath}/${version}/...`);
            const resp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${basePath}/${version}`, {
                headers: { Authorization: `token ${GITHUB_TOKEN}` }
            });
            
            if (!resp.ok) {
                const errorData = await resp.json();
                throw new Error(`GitHub API: ${errorData.message || resp.statusText}`);
            }
            
            const items = await resp.json();
            const clientSelect = document.getElementById('selClient');
            
            // Clear existing options
            clientSelect.innerHTML = "";
            
            // Find all client markdown files (excluding README.md)
            const clientFiles = items.filter(item => 
                item.type === 'file' && 
                item.name.endsWith('.md') &&
                item.name !== 'README.md' &&
                item.name !== 'template.md'
            );
            
            if (clientFiles.length === 0) {
                clientSelect.innerHTML = '<option value="">No clients found</option>';
                return;
            }
            
            // Extract client names
            const clients = new Set();
            clientFiles.forEach(file => {
                // Extract client name from filename (e.g., "client-A.md")
                const clientName = file.name.replace(/\.md$/, '');
                clients.add(clientName);
            });
            
            clients.forEach(client => {
                const opt = document.createElement('option');
                opt.value = client;
                opt.innerText = client.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                clientSelect.appendChild(opt);
            });
            
            // Store in menu data
            menuData[version] = Array.from(clients);
            renderClientMenu();
            
            // Restore cached client selection or select first available
            const cachedClient = sessionStorage.getItem('selected_client');
            if (cachedClient && clients.has(cachedClient)) {
                document.getElementById('selClient').value = cachedClient;
            } else if (clients.size > 0) {
                // Select first available client as default
                const firstClient = Array.from(clients)[0];
                document.getElementById('selClient').value = firstClient;
                sessionStorage.setItem('selected_client', firstClient);
            }
            
            console.log(`[SMAX Tool] Found ${clients.size} client(s)`);
        } catch (e) {
            console.error('[SMAX Tool] fetchClients error:', e);
            showError(`Failed to load clients: ${e.message}`);
        }
    }
    
    // NEW: Parse markdown with front-matter
    function parseMarkdownFrontMatter(content) {
        // Extract front-matter (between --- delimiters)
        const frontMatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
        const match = content.match(frontMatterRegex);
        
        if (!match) {
            throw new Error('Invalid markdown format: missing front-matter');
        }
        
        const frontMatter = jsyaml.load(match[1]);
        const markdown = match[2];
        
        return { config: frontMatter.config || {}, markdown };
    }
    
    // NEW: Parse markdown content into title, stages and steps
    // # = Document title
    // ## = Stages
    // ### = Steps
    function parseMarkdownStages(markdown) {
        const stages = [];
        const lines = markdown.split('\n');
        
        let documentTitle = '';
        let currentStage = null;
        let currentStep = null;
        let collectingCommand = false;
        let collectingNotes = false;
        let commandBuffer = [];
        let notesBuffer = [];
        let rawBuffer = [];
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            // H1 = Document Title
            if (line.startsWith('# ') && !line.startsWith('## ')) {
                documentTitle = line.substring(2).trim();
                continue;
            }
            
            // H2 = New Stage
            if (line.startsWith('## ') && !line.startsWith('### ')) {
                if (currentStep && currentStage) {
                    currentStep.rawMd = rawBuffer.join('\n');
                    currentStage.steps.push(currentStep);
                }
                if (currentStage) {
                    stages.push(currentStage);
                }
                
                currentStage = {
                    name: line.substring(3).trim(),
                    steps: []
                };
                currentStep = null;
                collectingCommand = false;
                collectingNotes = false;
                rawBuffer = [];
                continue;
            }
            
            // H3 = New Step
            if (line.startsWith('### ')) {
                if (currentStep && currentStage) {
                    currentStep.rawMd = rawBuffer.join('\n');
                    currentStage.steps.push(currentStep);
                }
                
                const title = line.substring(4).trim();
                currentStep = {
                    id: title.toLowerCase().replace(/[^a-z0-9]+/g, '_'),
                    title: title,
                    notes: '',
                    command: '',
                    done: false,
                    userNotes: ''
                };
                collectingCommand = false;
                collectingNotes = false;
                commandBuffer = [];
                notesBuffer = [];
                rawBuffer = [line]; // Start collecting raw for this step
                continue;
            }
            
            // Collect raw line for current step
            if (currentStep) {
                rawBuffer.push(line);
            }
            
            // Code block start/end
            if (line.trim().startsWith('```')) {
                if (collectingCommand) {
                    // End of command block
                    if (currentStep) {
                        currentStep.command = commandBuffer.join('\n').trim();
                    }
                    collectingCommand = false;
                    commandBuffer = [];
                } else {
                    // Start of command block
                    collectingCommand = true;
                }
                continue;
            }
            
            // Inside command block
            if (collectingCommand) {
                commandBuffer.push(line);
                continue;
            }
            
            // Checkbox for done status
            if (line.trim().startsWith('- [x]') || line.trim().startsWith('- [X]')) {
                if (currentStep) {
                    currentStep.done = true;
                }
                continue;
            }
            
            if (line.trim().startsWith('- [ ]')) {
                if (currentStep) {
                    currentStep.done = false;
                }
                continue;
            }
            
            // H4 = Notes section
            if (line.startsWith('#### ')) {
                const sectionTitle = line.substring(5).trim();
                if (sectionTitle.toLowerCase().includes('notes') || sectionTitle.toLowerCase().includes('note')) {
                    collectingNotes = true;
                    notesBuffer = [];
                }
                continue;
            }
            
            // Collect notes content
            if (collectingNotes && currentStep) {
                // Check if we've reached the next H3, H2, or H1 (end of notes section)
                if (line.startsWith('### ') || line.startsWith('## ') || line.startsWith('# ')) {
                    currentStep.userNotes = notesBuffer.join('\n').trim();
                    collectingNotes = false;
                    // Don't continue here - let the header be processed normally
                } else {
                    notesBuffer.push(line);
                    continue;
                }
            }
            
            // Regular content (step description/notes)
            if (currentStep && line.trim() !== '' && !collectingCommand && !collectingNotes) {
                if (currentStep.notes) {
                    currentStep.notes += '\n' + line.trim();
                } else {
                    currentStep.notes = line.trim();
                }
            }
        }
        
        // Add last step and stage
        if (currentStep && currentStage) {
            if (collectingNotes && notesBuffer.length > 0) {
                currentStep.userNotes = notesBuffer.join('\n').trim();
            }
            currentStep.rawMd = rawBuffer.join('\n');
            currentStage.steps.push(currentStep);
        }
        if (currentStage) {
            stages.push(currentStage);
        }
        
        return { title: documentTitle, stages: stages };
    }
    
    // NEW: Try to load markdown format
    async function tryLoadMarkdown(ver, client, mdPath) {
        try {
            let mdContent;
            
            if (GITHUB_TOKEN) {
                const resp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${mdPath}`, {
                    headers: { Authorization: `token ${GITHUB_TOKEN}` }
                });
                
                if (resp.status === 404) {
                    return false; // File doesn't exist, try YAML
                }
                
                if (!resp.ok) {
                    return false;
                }
                
                const data = await resp.json();
                FILE_SHA = data.sha;
                CURRENT_YAML_PATH = mdPath;
                mdContent = atob(data.content);
            } else {
                const resp = await fetch(mdPath);
                if (!resp.ok) return false;
                CURRENT_YAML_PATH = mdPath;
                mdContent = await resp.text();
            }
            
            console.log(`[SMAX Tool] Loading markdown from ${mdPath}...`);
            
            // Parse markdown
            const { config: configData, markdown } = parseMarkdownFrontMatter(mdContent);
            const { title, stages } = parseMarkdownStages(markdown);
            
            config = {
                title: title,
                config: configData,
                stages: stages
            };
            
            console.log(`[SMAX Tool] Loaded title: "${title}", ${stages.length} stage(s) from markdown`);
            
            if (GITHUB_TOKEN) {
                document.getElementById('syncInd').classList.add('online');
                document.getElementById('syncStat').innerText = `Synced: ${ver}/${client}`;
            }
            
            currentStageIndex = 0;
            renderTitle();
            renderVars();
            renderStageTabs();
            renderCurrentStage();
            updateProgress();
            
            return true;
            
        } catch (e) {
            console.error('[SMAX Tool] Failed to load markdown:', e);
            return false;
        }
    }

    // NEW: Handle version change - refresh client list
    async function onVersionChange() {
        const ver = document.getElementById('selVer').value;
        if (!ver) return;
        
        // Cache selected version
        sessionStorage.setItem('selected_version', ver);
        
        await fetchClients(ver);
        // Don't auto-load data, wait for user to select a client
    }
    
    async function onProductChange() {
        const product = document.getElementById('selProduct').value;
        
        // Update app title
        const titleElement = document.getElementById('appTitle');
        titleElement.textContent = `${product} Multi-Tenant Operations`;
        
        // Cache selected product
        sessionStorage.setItem('selected_product', product);
        
        // Clear version and client selections when product changes
        document.getElementById('selVer').innerHTML = '<option value="">Select version...</option>';
        document.getElementById('selClient').innerHTML = '<option value="">Loading clients...</option>';
        
        // Clear cached selections for this product
        sessionStorage.removeItem('selected_version');
        sessionStorage.removeItem('selected_client');
        
        // Fetch folders for the new product
        await fetchFolders();
    }
    
    async function loadData() {
        showError(""); 
        const ver = document.getElementById('selVer').value;
        const client = document.getElementById('selClient').value;
        
        if (!ver || !client) {
            console.log('[SMAX Tool] Waiting for version and client to be selected...');
            return;
        }

        // Cache selected client
        sessionStorage.setItem('selected_client', client);

        // Only support markdown format now
        const basePath = getVersionsBasePath();
        const mdPath = `${basePath}/${ver}/${client}.md`;
        
        // Try markdown first
        if (await tryLoadMarkdown(ver, client, mdPath)) {
            renderTitle();
            return;
        }
        
        // If no markdown, check for YAML and migrate
        const yamlPath = `${basePath}/${ver}/${client}.yaml`;
        console.log(`[SMAX Tool] No markdown found, checking for YAML to migrate...`);
        
        try {
            let yamlContent;
            let yamlSha = "";
            
            if (GITHUB_TOKEN) {
                const resp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${yamlPath}`, {
                    headers: { Authorization: `token ${GITHUB_TOKEN}` }
                });
                
                if (resp.status === 404) {
                    // Try to migrate from old format
                    console.log('[SMAX Tool] YAML not found, attempting migration from old format...');
                    await migrateFromOldFormat(ver, client);
                    return;
                }
                
                if (!resp.ok) {
                    const errorData = await resp.json();
                    throw new Error(`GitHub API: ${errorData.message || resp.statusText}`);
                }
                
                const data = await resp.json();
                yamlSha = data.sha;
                yamlContent = atob(data.content);
            } else {
                const resp = await fetch(yamlPath);
                if (!resp.ok) throw new Error(`No configuration found for ${client}`);
                yamlContent = await resp.text();
            }
            
            // Parse YAML
            let yamlConfig = jsyaml.load(yamlContent);
            
            if (!yamlConfig) {
                throw new Error('Invalid YAML structure');
            }
            
            // Convert old 'steps' to 'stages'
            if (yamlConfig.steps && !yamlConfig.stages) {
                console.log('[SMAX Tool] Converting old steps format to stages...');
                yamlConfig.stages = [{
                    name: 'Upgrade',
                    steps: yamlConfig.steps
                }];
                delete yamlConfig.steps;
            }
            
            // Migrate to markdown
            console.log('[SMAX Tool] Migrating YAML to Markdown format...');
            config = {
                title: yamlConfig.title || `${client} Upgrade`,
                config: yamlConfig.config || {},
                stages: yamlConfig.stages || []
            };
            
            // Save as markdown
            CURRENT_YAML_PATH = mdPath;
            FILE_SHA = ""; // New file
            await saveData();
            
            console.log('[SMAX Tool] Migration complete, reloading...');
            await loadData();
            
        } catch (e) {
            console.error('[SMAX Tool] loadData error:', e);
            showError(e.message);
        }
    }
    
    // NEW: Migrate from old format to new markdown format
    async function migrateFromOldFormat(ver, client) {
        try {
            console.log('[SMAX Tool] Migrating from old format...');
            
            // Try to load old managed or embedded steps file
            const basePath = getVersionsBasePath();
            let oldStepsPath = `${basePath}/${ver}/${client}-managed-steps.yaml`;
            let oldStatePath = `${basePath}/${ver}/state-${client}.yaml`;
            
            let stepsResp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${oldStepsPath}`, {
                headers: { Authorization: `token ${GITHUB_TOKEN}` }
            });
            
            if (stepsResp.status === 404) {
                // Try embedded format
                oldStepsPath = `${basePath}/${ver}/${client}-embedded-steps.yaml`;
                stepsResp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${oldStepsPath}`, {
                    headers: { Authorization: `token ${GITHUB_TOKEN}` }
                });
            }
            
            if (!stepsResp.ok) {
                throw new Error(`No client configuration found for ${client}`);
            }
            
            const stepsData = await stepsResp.json();
            const oldConfig = jsyaml.load(atob(stepsData.content));
            
            // Load old state file if exists
            let state = {};
            const stateResp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${oldStatePath}`, {
                headers: { Authorization: `token ${GITHUB_TOKEN}` }
            });
            
            if (stateResp.ok) {
                const stateData = await stateResp.json();
                state = jsyaml.load(atob(stateData.content)) || {};
            }
            
            // Create new unified config in markdown format
            config = {
                title: `${client} Upgrade to v${ver}`,
                config: oldConfig.config || {},
                stages: [{
                    name: 'Upgrade',
                    steps: (oldConfig.steps || []).map(step => {
                        return {
                            ...step,
                            done: state[`s_done_${step.id}`] === 'true',
                            userNotes: ''
                        };
                    })
                }]
            };
            
            // Apply variable state
            Object.keys(config.config).forEach(key => {
                if (state[`v_${key}`]) {
                    config.config[key] = state[`v_${key}`];
                }
            });
            
            // Save as markdown
            CURRENT_YAML_PATH = `${basePath}/${ver}/${client}.md`;
            FILE_SHA = ""; // Will create new file
            await saveData();
            
            console.log('[SMAX Tool] Migration complete, reloading...');
            await loadData();
            
        } catch (e) {
            console.error('[SMAX Tool] Migration error:', e);
            showError(`Migration failed: ${e.message}`);
        }
    }

    // Error handling with better logging
    function showError(msg) {
        const box = document.getElementById('errorBox');
        if (msg) {
            console.error('[SMAX Tool Error]:', msg);
            box.innerText = `‚ö†Ô∏è Error: ${msg}`;
            box.style.display = 'block';
        } else {
            box.style.display = 'none';
        }
    }

    // Render environment variables
    function renderVars() {
        const varInputs = document.getElementById('var-inputs');
        varInputs.innerHTML = '';
        
        if (!config.config) return;
        
        Object.entries(config.config).forEach(([key, defaultVal]) => {
            const wrapper = document.createElement('div');
            
            // Create label
            const label = document.createElement('label');
            label.style.fontSize = '12px';
            label.style.color = '#586069';
            label.style.display = 'block';
            label.style.marginBottom = '4px';
            label.textContent = key;
            
            // Create input
            const input = document.createElement('input');
            input.type = 'text';
            input.id = `var_${key}`;
            input.value = defaultVal;
            input.style.width = '100%';
            input.style.boxSizing = 'border-box';
            input.onchange = function() {
                config.config[key] = this.value;
            };
            
            wrapper.appendChild(label);
            wrapper.appendChild(input);
            varInputs.appendChild(wrapper);
        });
    }
    
    // NEW: Render stage tabs
    function renderStageTabs() {
        const container = document.getElementById('stage-tabs-container');
        container.innerHTML = '';
        container.style.display = 'flex';
        
        if (!config.stages || config.stages.length === 0) {
            container.style.display = 'none';
            return;
        }
        
        config.stages.forEach((stage, index) => {
            const tab = document.createElement('div');
            tab.className = 'stage-tab';
            if (index === currentStageIndex) {
                tab.className += ' active';
            }
            
            // Calculate completion for this stage
            const totalSteps = stage.steps.length;
            const completedSteps = stage.steps.filter(s => s.done).length;
            
            const stageName = document.createElement('div');
            stageName.textContent = stage.name;
            stageName.className = 'editable';
            stageName.ondblclick = (e) => {
                e.stopPropagation();
                editStageName(index);
            };
            stageName.title = 'Double-click to edit';
            
            const stageInfo = document.createElement('div');
            stageInfo.style.fontSize = '11px';
            stageInfo.style.color = '#586069';
            stageInfo.style.marginTop = '3px';
            stageInfo.textContent = `${completedSteps}/${totalSteps} steps`;
            
            tab.appendChild(stageName);
            tab.appendChild(stageInfo);
            
            tab.onclick = () => {
                currentStageIndex = index;
                renderStageTabs();
                renderCurrentStage();
                updateProgress();
            };
            
            container.appendChild(tab);
        });
    }
    
    // NEW: Render current stage
    function renderCurrentStage() {
        if (!config.stages || config.stages.length === 0) {
            document.getElementById('steps-list').innerHTML = '<p style="color:#586069;">No stages found.</p>';
            document.getElementById('stage-nav').style.display = 'none';
            document.getElementById('stage-nav-bottom').style.display = 'none';
            return;
        }
        
        const stage = config.stages[currentStageIndex];
        renderSteps(stage.steps);
        
        // Update navigation buttons
        document.getElementById('stage-nav').style.display = 'flex';
        document.getElementById('stage-nav-bottom').style.display = 'flex';
        
        const prevBtn = document.getElementById('prev-stage-btn');
        const nextBtn = document.getElementById('next-stage-btn');
        const prevBtnBottom = document.getElementById('prev-stage-btn-bottom');
        const nextBtnBottom = document.getElementById('next-stage-btn-bottom');
        
        prevBtn.disabled = currentStageIndex === 0;
        nextBtn.disabled = currentStageIndex === config.stages.length - 1;
        prevBtnBottom.disabled = currentStageIndex === 0;
        nextBtnBottom.disabled = currentStageIndex === config.stages.length - 1;
    }
    
    // NEW: Stage navigation
    function prevStage() {
        if (currentStageIndex > 0) {
            currentStageIndex--;
            renderStageTabs();
            renderCurrentStage();
            updateProgress();
            window.scrollTo(0, 0);
        }
    }
    
    function nextStage() {
        if (currentStageIndex < config.stages.length - 1) {
            currentStageIndex++;
            renderStageTabs();
            renderCurrentStage();
            updateProgress();
            window.scrollTo(0, 0);
        }
    }
    
    // NEW: Update progress indicator
    function updateProgress() {
        if (!config.stages || config.stages.length === 0) {
            document.getElementById('progress-container').style.display = 'none';
            return;
        }
        
        document.getElementById('progress-container').style.display = 'block';
        
        // Calculate total progress across all stages
        let totalSteps = 0;
        let completedSteps = 0;
        
        config.stages.forEach(stage => {
            totalSteps += stage.steps.length;
            completedSteps += stage.steps.filter(s => s.done).length;
        });
        
        const percentage = totalSteps > 0 ? (completedSteps / totalSteps * 100).toFixed(0) : 0;
        
        document.getElementById('progress-fill').style.width = `${percentage}%`;
        document.getElementById('progress-text').textContent = `${completedSteps} of ${totalSteps} steps completed (${percentage}%)`;
    }

    // Copy to clipboard function
    function copyToClipboard(text) {
        if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(text).then(() => {
                console.log('[SMAX Tool] Copied to clipboard');
                // Visual feedback could be added here
            }).catch(err => {
                console.error('[SMAX Tool] Failed to copy:', err);
                fallbackCopy(text);
            });
        } else {
            fallbackCopy(text);
        }
    }

    // Fallback copy method for older browsers
    function fallbackCopy(text) {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.select();
        try {
            // Note: execCommand is deprecated but kept as fallback for legacy browser support
            document.execCommand('copy');
            console.log('[SMAX Tool] Copied using fallback method');
        } catch (err) {
            console.error('[SMAX Tool] Fallback copy failed:', err);
            showError('Copy failed. Please copy manually.');
        }
        document.body.removeChild(textarea);
    }

    // Replace placeholders in commands with actual values
    // Replace placeholders in commands with actual values
    // Supports both {{variable}} and <variable> formats
    function interpolate(str) {
        if (!str) return '';
        let result = str;
        Object.keys(config.config || {}).forEach(key => {
            const val = config.config[key] || '';
            // Replace {{key}} format
            result = result.replace(new RegExp(`{{${key}}}`, 'g'), val);
            // Replace <key> format (case-insensitive)
            result = result.replace(new RegExp(`<${key}>`, 'gi'), val);
            // Also try uppercase version for <KEY> format
            const upperKey = key.toUpperCase();
            result = result.replace(new RegExp(`<${upperKey}>`, 'g'), val);
        });
        return result;
    }

    // Render steps with checkboxes, inline editing, and minimal notes UI
    function renderSteps(steps) {
        const stepsList = document.getElementById('steps-list');
        stepsList.innerHTML = '';
        
        if (!steps || steps.length === 0) {
            stepsList.innerHTML = '<p style="color:#586069;">No steps in this stage.</p>';
            document.getElementById('add-step-container').style.display = 'block';
            return;
        }
        
        document.getElementById('add-step-container').style.display = 'block';
        
        steps.forEach((step, stepIndex) => {
            const isDone = step.done || false;
            const card = document.createElement('div');
            card.className = `card ${isDone ? 'step-done' : ''}`;
            card.id = `step_${currentStageIndex}_${stepIndex}`;
            
            // Header with checkbox and title
            const header = document.createElement('div');
            header.style.display = 'flex';
            header.style.justifyContent = 'space-between';
            header.style.alignItems = 'center';
            header.style.marginBottom = '12px';
            
            const leftSection = document.createElement('div');
            leftSection.style.display = 'flex';
            leftSection.style.alignItems = 'center';
            leftSection.style.gap = '8px';
            leftSection.style.flex = '1';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `check_${currentStageIndex}_${stepIndex}`;
            checkbox.checked = isDone;
            checkbox.style.width = '18px';
            checkbox.style.height = '18px';
            checkbox.style.cursor = 'pointer';
            checkbox.onchange = function() {
                toggleStep(currentStageIndex, stepIndex, this.checked);
            };
            
            const title = document.createElement('strong');
            title.className = 'editable';
            title.style.fontSize = '16px';
            title.style.cursor = 'pointer';
            title.textContent = step.title || 'Untitled Step';
            
            leftSection.appendChild(checkbox);
            leftSection.appendChild(title);
            
            // Right section with notes button and edit buttons
            const rightSection = document.createElement('div');
            rightSection.style.display = 'flex';
            rightSection.style.gap = '6px';
            
            // Edit button
            const editBtn = document.createElement('button');
            editBtn.className = 'note-toggle-btn';
            editBtn.innerHTML = 'üìù Edit';
            editBtn.title = 'Edit step';
            editBtn.onclick = () => editStep(currentStageIndex, stepIndex);
            
            // Minimal notes button
            const notesBtn = document.createElement('button');
            notesBtn.className = `note-toggle-btn ${step.userNotes ? 'has-notes' : ''}`;
            notesBtn.innerHTML = step.userNotes ? 'üí¨ Notes' : 'üí¨';
            notesBtn.title = step.userNotes ? 'View/Edit notes' : 'Add notes';
            notesBtn.onclick = () => toggleNoteEditor(currentStageIndex, stepIndex);
            
            rightSection.appendChild(editBtn);
            rightSection.appendChild(notesBtn);
            
            header.appendChild(leftSection);
            header.appendChild(rightSection);
            card.appendChild(header);
            
            // Add default notes if present (editable)
            if (step.notes) {
                const notesDiv = document.createElement('div');
                notesDiv.className = 'editable';
                notesDiv.style.color = 'white';
                notesDiv.style.margin = '8px 0';
                notesDiv.style.fontStyle = 'italic';
                notesDiv.style.cursor = 'pointer';
                notesDiv.textContent = step.notes;
                card.appendChild(notesDiv);
            }
            
            // Add command with copy and edit buttons
            if (step.command) {
                const interpolatedCommand = interpolate(step.command);
                const commandContainer = document.createElement('div');
                commandContainer.style.position = 'relative';
                commandContainer.style.marginTop = '12px';
                
                const pre = document.createElement('pre');
                pre.style.position = 'relative';
                
                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-btn';
                copyBtn.textContent = 'Copy';
                copyBtn.onclick = function(e) {
                    e.stopPropagation();
                    copyToClipboard(interpolatedCommand);
                };
                
                const commandText = document.createTextNode(interpolatedCommand);
                
                pre.appendChild(copyBtn);
                pre.appendChild(commandText);
                commandContainer.appendChild(pre);
                card.appendChild(commandContainer);
            }
            
            // Collapsible note section - shows preview by default
            const noteEditor = document.createElement('div');
            noteEditor.className = 'note-editor';
            noteEditor.id = `note-editor_${currentStageIndex}_${stepIndex}`;
            noteEditor.style.marginTop = '15px';
            noteEditor.style.borderTop = '1px solid var(--border)';
            noteEditor.style.paddingTop = '15px';
            
            // Container for content (preview or textarea)
            const noteContent = document.createElement('div');
            noteContent.id = `note-content_${currentStageIndex}_${stepIndex}`;
            
            // Live preview (shown by default)
            const notePreview = document.createElement('div');
            notePreview.className = 'note-preview';
            notePreview.id = `note-preview_${currentStageIndex}_${stepIndex}`;
            notePreview.style.marginBottom = '10px';
            if (step.userNotes) {
                notePreview.innerHTML = marked.parse(step.userNotes);
            } else {
                notePreview.innerHTML = '<span style="color: #586069; font-style: italic;">No notes yet. Click Edit to add some.</span>';
            }
            
            // Textarea (hidden by default)
            const noteTextarea = document.createElement('textarea');
            noteTextarea.id = `note-textarea_${currentStageIndex}_${stepIndex}`;
            noteTextarea.disabled = false;
            noteTextarea.readOnly = false;
            noteTextarea.value = step.userNotes || '';
            noteTextarea.placeholder = 'Enter notes in Markdown format...\n\nYou can:\n- Paste images directly (Ctrl+V)\n- Drag and drop images\n- Use **bold**, *italic*, lists, etc.';
            noteTextarea.rows = 6;
            noteTextarea.style.marginBottom = '10px';
            noteTextarea.style.display = 'none';
            
            // Setup image paste/drop
            setupImagePaste(noteTextarea);
            
            // Update preview on input
            noteTextarea.oninput = () => {
                const preview = document.getElementById(`note-preview_${currentStageIndex}_${stepIndex}`);
                if (preview) {
                    if (noteTextarea.value) {
                        preview.innerHTML = marked.parse(noteTextarea.value);
                    } else {
                        preview.innerHTML = '<span style="color: #586069; font-style: italic;">No notes yet. Click Edit to add some.</span>';
                    }
                }
            };
            
            noteContent.appendChild(notePreview);
            noteContent.appendChild(noteTextarea);
            
            const noteButtons = document.createElement('div');
            noteButtons.style.display = 'flex';
            noteButtons.style.gap = '10px';
            
            const editNoteBtn = document.createElement('button');
            editNoteBtn.textContent = '‚úèÔ∏è Edit';
            editNoteBtn.style.padding = '8px 16px';
            editNoteBtn.style.border = '1px solid var(--border)';
            editNoteBtn.style.borderRadius = '6px';
            editNoteBtn.style.cursor = 'pointer';
            editNoteBtn.style.background = 'var(--card-bg)';
            editNoteBtn.style.color = 'var(--text)';
            editNoteBtn.onclick = () => toggleNoteEdit(currentStageIndex, stepIndex);
            
            const saveNoteBtn = document.createElement('button');
            saveNoteBtn.textContent = 'üíæ Save Note';
            saveNoteBtn.style.background = 'var(--primary)';
            saveNoteBtn.style.color = 'white';
            saveNoteBtn.style.border = 'none';
            saveNoteBtn.style.padding = '8px 16px';
            saveNoteBtn.style.borderRadius = '6px';
            saveNoteBtn.style.cursor = 'pointer';
            saveNoteBtn.onclick = () => saveNote(currentStageIndex, stepIndex);
            
            const cancelNoteBtn = document.createElement('button');
            cancelNoteBtn.textContent = 'Cancel';
            cancelNoteBtn.style.padding = '8px 16px';
            cancelNoteBtn.style.border = '1px solid var(--border)';
            cancelNoteBtn.style.borderRadius = '6px';
            cancelNoteBtn.style.cursor = 'pointer';
            cancelNoteBtn.style.background = 'var(--card-bg)';
            cancelNoteBtn.style.color = 'var(--text)';
            cancelNoteBtn.onclick = () => toggleNoteEditor(currentStageIndex, stepIndex);
            
            noteButtons.appendChild(editNoteBtn);
            noteButtons.appendChild(saveNoteBtn);
            noteButtons.appendChild(cancelNoteBtn);
            
            noteEditor.appendChild(noteContent);
            noteEditor.appendChild(noteButtons);
            
            card.appendChild(noteEditor);
            stepsList.appendChild(card);
        });
    }
    
    // NEW: Toggle note editor
    function toggleNoteEditor(stageIndex, stepIndex) {
        const editor = document.getElementById(`note-editor_${stageIndex}_${stepIndex}`);
        if (editor) {
            editor.classList.toggle('active');
        }
    }
    
    function toggleNoteEdit(stageIndex, stepIndex) {
        const content = document.getElementById(`note-content_${stageIndex}_${stepIndex}`);
        const preview = document.getElementById(`note-preview_${stageIndex}_${stepIndex}`);
        const textarea = document.getElementById(`note-textarea_${stageIndex}_${stepIndex}`);
        
        if (content && preview && textarea) {
            const isEditing = content.classList.contains('editing');
            
            if (isEditing) {
                // Switch to preview mode
                content.classList.remove('editing');
                preview.style.display = 'block';
                textarea.style.display = 'none';
            } else {
                // Switch to edit mode
                content.classList.add('editing');
                preview.style.display = 'none';
                textarea.style.display = 'block';
                
                // Ensure textarea is interactive
                textarea.disabled = false;
                textarea.readOnly = false;
                textarea.style.pointerEvents = 'auto';
                
                // Focus with a small delay
                setTimeout(() => {
                    textarea.focus();
                    textarea.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 50);
            }
        }
    }
    
    // NEW: Save note
    function saveNote(stageIndex, stepIndex) {
        const textarea = document.getElementById(`note-textarea_${stageIndex}_${stepIndex}`);
        const preview = document.getElementById(`note-preview_${stageIndex}_${stepIndex}`);
        
        config.stages[stageIndex].steps[stepIndex].userNotes = textarea.value;
        
        // Update preview and switch back to preview mode
        if (preview) {
            if (textarea.value) {
                preview.innerHTML = marked.parse(textarea.value);
            } else {
                preview.innerHTML = '<span style="color: #586069; font-style: italic;">No notes yet. Click Edit to add some.</span>';
            }
            preview.style.display = 'block';
        }
        
        // Switch back to preview mode
        const content = document.getElementById(`note-content_${stageIndex}_${stepIndex}`);
        if (content) {
            content.classList.remove('editing');
        }
        
        if (textarea) {
            textarea.style.display = 'none';
        }
        
        // Close editor and re-render to update button
        toggleNoteEditor(stageIndex, stepIndex);
        renderCurrentStage();
        
        console.log('[SMAX Tool] Note saved for step', stepIndex);
        triggerAutosave();
    }

    // Toggle step completion status
    function toggleStep(stageIndex, stepIndex, checked) {
        config.stages[stageIndex].steps[stepIndex].done = checked;
        const card = document.getElementById(`step_${stageIndex}_${stepIndex}`);
        if (card) {
            if (checked) {
                card.classList.add('step-done');
            } else {
                card.classList.remove('step-done');
            }
        }
        console.log(`[SMAX Tool] Step ${stepIndex} in stage ${stageIndex} marked as ${checked ? 'done' : 'pending'}`);
        
        // Update progress and stage tabs
        updateProgress();
        renderStageTabs();
        triggerAutosave();
    }
    
    // Toggle environment variables sidebar
    function toggleEnvVars() {
        const card = document.getElementById('env-vars-card');
        const btn = document.getElementById('envToggleBtn');
        card.classList.toggle('open');
        if (card.classList.contains('open')) {
            card.style.display = 'block';
            btn.textContent = '‚öôÔ∏è Hide Variables';
        } else {
            setTimeout(() => card.style.display = 'none', 300); // Hide after animation
            btn.textContent = '‚öôÔ∏è Variables';
        }
    }
    
    function closeEnvVars() {
        const card = document.getElementById('env-vars-card');
        const btn = document.getElementById('envToggleBtn');
        card.classList.remove('open');
        setTimeout(() => card.style.display = 'none', 300);
        btn.textContent = '‚öôÔ∏è Variables';
    }
    
    // Toggle client menu sidebar
    function toggleClientMenu() {
        const card = document.getElementById('client-menu-card');
        const btn = document.getElementById('menuToggleBtn');
        if (card.style.display === 'none' || card.style.display === '') {
            card.style.display = 'block';
            btn.textContent = 'üìÅ Hide Menu';
        } else {
            card.style.display = 'none';
            btn.textContent = 'üìÅ Menu';
        }
    }
    
    function closeClientMenu() {
        const card = document.getElementById('client-menu-card');
        const btn = document.getElementById('menuToggleBtn');
        card.classList.remove('open');
        setTimeout(() => card.style.display = 'none', 300);
        btn.textContent = 'üìÅ Menu';
    }
    
    // Render client menu
    function renderClientMenu() {
        const content = document.getElementById('client-menu-content');
        content.innerHTML = '';
        
        const currentVersion = document.getElementById('selVer').value;
        
        Object.keys(menuData).forEach(version => {
            const versionDiv = document.createElement('div');
            versionDiv.className = 'menu-item';
            versionDiv.textContent = `üìÅ ${version}`;
            versionDiv.onclick = () => toggleVersionMenu(version);
            
            const clientList = document.createElement('div');
            clientList.className = 'submenu';
            clientList.id = `submenu_${version}`;
            clientList.style.display = 'none'; // collapsed by default
            
            menuData[version].forEach(client => {
                const clientDiv = document.createElement('div');
                clientDiv.className = 'menu-item';
                clientDiv.textContent = `üìÑ ${client}`;
                clientDiv.onclick = () => selectClient(version, client);
                clientList.appendChild(clientDiv);
            });
            
            if (version === currentVersion) {
                clientList.style.display = 'block';
            }
            
            versionDiv.appendChild(clientList);
            content.appendChild(versionDiv);
        });
    }
    
    // Toggle version submenu
    async function toggleVersionMenu(version) {
        // If no clients loaded, fetch them
        if (menuData[version].length === 0) {
            await fetchClients(version);
        }
        
        // Accordion behavior: expand clicked, collapse others
        Object.keys(menuData).forEach(v => {
            const submenu = document.getElementById(`submenu_${v}`);
            if (submenu) {
                submenu.style.display = v === version ? 'block' : 'none';
            }
        });
    }
    
    // Select client from menu
    function selectClient(version, client) {
        document.getElementById('selVer').value = version;
        onVersionChange(); // to load clients
        setTimeout(() => {
            document.getElementById('selClient').value = client;
            loadData();
        }, 100); // small delay to ensure clients are loaded
    }
    
    // NEW: Reset modal functions
    function showResetModal() {
        document.getElementById('resetModal').style.display = 'block';
    }
    
    function closeResetModal() {
        document.getElementById('resetModal').style.display = 'none';
    }
    
    function confirmReset() {
        if (!config.stages) return;
        
        // Reset all steps
        config.stages.forEach(stage => {
            stage.steps.forEach(step => {
                step.done = false;
            });
        });
        
        // Re-render
        renderStageTabs();
        renderCurrentStage();
        updateProgress();
        closeResetModal();
        
        console.log('[SMAX Tool] All steps reset');
        showSuccess('All steps have been reset');
    }

    // Show success message (non-blocking)
    function showSuccess(msg) {
        const box = document.getElementById('errorBox');
        box.innerText = `‚úÖ ${msg}`;
        box.style.display = 'block';
        box.style.background = '#d4edda';
        box.style.color = '#155724';
        box.style.borderColor = '#c3e6cb';
        
        // Auto-hide after 3 seconds
        setTimeout(() => {
            box.style.display = 'none';
            box.style.background = '#ffeef0';
            box.style.color = '#d73a49';
            box.style.borderColor = '#f97583';
        }, 3000);
    }

    // Convert config to markdown format with new structure
    // # = Document title
    // ## = Stages
    // ### = Steps
    function convertToMarkdown() {
        let md = '---\n';
        md += jsyaml.dump({ config: config.config });
        md += '---\n\n';
        
        // Add document title
        if (config.title) {
            md += `# ${config.title}\n\n`;
        }
        
        config.stages.forEach(stage => {
            md += `## ${stage.name}\n\n`;
            
            stage.steps.forEach(step => {
                md += `### ${step.title}\n\n`;
                
                if (step.notes) {
                    md += `${step.notes}\n\n`;
                }
                
                if (step.command) {
                    md += '```bash\n';
                    md += step.command + '\n';
                    md += '```\n\n';
                }
                
                // Checkbox for completion status
                md += step.done ? '- [x] Step completed\n' : '- [ ] Step not completed\n';
                
                if (step.userNotes) {
                    md += '\n#### Notes\n\n';
                    md += step.userNotes + '\n';
                }
                
                md += '\n---\n\n';
            });
        });
        
        return md;
    }
    
    // Save data function to push markdown back to GitHub
    async function saveData() {
        if (!GITHUB_TOKEN) {
            showError('GitHub token required. Please enter token and connect.');
            return;
        }
        
        if (!CURRENT_YAML_PATH) {
            showError('No file path selected. Please load data first.');
            return;
        }
        
        try {
            // Always save as markdown
            const fileContent = convertToMarkdown();
            const encodedContent = btoa(fileContent);
            
            // Update file on GitHub
            const updatePayload = {
                message: `Update ${document.getElementById('selClient').value} configuration`,
                content: encodedContent
            };
            
            // Only include SHA if file exists (for updates)
            if (FILE_SHA) {
                updatePayload.sha = FILE_SHA;
            }
            
            console.log('[SMAX Tool] Saving to GitHub:', CURRENT_YAML_PATH);
            
            const response = await fetch(
                `https://api.github.com/repos/${OWNER}/${REPO}/contents/${CURRENT_YAML_PATH}`,
                {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${GITHUB_TOKEN}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updatePayload)
                }
            );
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`GitHub API error: ${errorData.message || response.statusText}`);
            }
            
            const result = await response.json();
            FILE_SHA = result.content.sha; // Update SHA for next save
            
            document.getElementById('syncInd').classList.add('online');
            document.getElementById('syncStat').innerText = `Synced: ${document.getElementById('selVer').value}/${document.getElementById('selClient').value}`;
            
            console.log('[SMAX Tool] Data saved successfully');
            showSuccess('Progress saved to GitHub!');
            
        } catch (error) {
            console.error('[SMAX Tool] Save failed:', error);
            showError(`Failed to save: ${error.message}`);
        }
    }
    
    // Autosave functionality
    function toggleAutosave() {
        autosaveEnabled = document.getElementById('autosaveToggle').checked;
        const status = document.getElementById('autosave-status');
        if (autosaveEnabled) {
            status.textContent = 'Autosave enabled';
            status.style.color = 'var(--primary)';
        } else {
            status.textContent = '';
            if (autosaveTimeout) {
                clearTimeout(autosaveTimeout);
                autosaveTimeout = null;
            }
        }
    }
    
    function triggerAutosave() {
        if (!autosaveEnabled) return;
        
        // Clear existing timeout
        if (autosaveTimeout) {
            clearTimeout(autosaveTimeout);
        }
        
        // Set new timeout (debounced save after 3 seconds)
        autosaveTimeout = setTimeout(async () => {
            const status = document.getElementById('autosave-status');
            status.textContent = 'Saving...';
            await saveData();
            status.textContent = 'Autosaved';
            setTimeout(() => {
                status.textContent = 'Autosave enabled';
            }, 2000);
        }, 3000);
    }
    
    // Dark mode toggle
    function toggleDarkMode() {
        document.body.classList.toggle('dark-mode');
        const icon = document.getElementById('theme-icon');
        if (document.body.classList.contains('dark-mode')) {
            icon.textContent = '‚òÄÔ∏è';
            localStorage.setItem('darkMode', 'true');
        } else {
            icon.textContent = 'üåô';
            localStorage.setItem('darkMode', 'false');
        }
    }
    
    // Initialize dark mode from localStorage
    if (localStorage.getItem('darkMode') === 'true') {
        document.body.classList.add('dark-mode');
        document.getElementById('theme-icon').textContent = '‚òÄÔ∏è';
    }
    
    // Render document title
    function renderTitle() {
        const titleContainer = document.getElementById('doc-title-container');
        const titleElement = document.getElementById('doc-title');
        if (config.title) {
            titleContainer.style.display = 'block';
            titleElement.textContent = config.title;
        } else {
            titleContainer.style.display = 'none';
        }
    }
    
    // Edit title inline
    function editTitle() {
        const titleElement = document.getElementById('doc-title');
        const currentTitle = config.title || '';
        
        const input = document.createElement('input');
        input.type = 'text';
        input.value = currentTitle;
        input.style.width = '100%';
        input.style.fontSize = '1.5em';
        input.style.fontWeight = 'bold';
        input.style.padding = '4px';
        input.style.border = '1px solid var(--primary)';
        input.style.borderRadius = '4px';
        input.style.background = 'var(--card-bg)';
        input.style.color = 'var(--text)';
        
        titleElement.replaceWith(input);
        input.focus();
        input.select();
        
        const saveTitle = () => {
            const newTitle = input.value.trim();
            config.title = newTitle;
            const newTitleElement = document.createElement('h2');
            newTitleElement.id = 'doc-title';
            newTitleElement.className = 'editable';
            newTitleElement.onclick = editTitle;
            newTitleElement.style.margin = '0';
            newTitleElement.style.cursor = 'pointer';
            newTitleElement.textContent = newTitle || 'Document Title';
            input.replaceWith(newTitleElement);
            triggerAutosave();
        };
        
        input.onblur = saveTitle;
        input.onkeypress = (e) => {
            if (e.key === 'Enter') {
                saveTitle();
            }
        };
    }
    
    // Edit stage name inline
    function editStageName(stageIndex) {
        const stage = config.stages[stageIndex];
        const newName = prompt('Edit stage name:', stage.name);
        if (newName && newName.trim()) {
            stage.name = newName.trim();
            renderStageTabs();
            renderCurrentStage();
            triggerAutosave();
        }
    }
    
    // Edit step
    function editStep(stageIndex, stepIndex) {
        editingStageIndex = stageIndex;
        editingStepIndex = stepIndex;
        const step = config.stages[stageIndex].steps[stepIndex];
        const mdStr = stepToMarkdown(step);
        const textarea = document.getElementById('editStepContent');
        textarea.value = mdStr;
        textarea.addEventListener('keydown', handleMarkdownShortcuts);
        document.getElementById('editStepModal').style.display = 'block';
    }
    
    function closeEditStep() {
        document.getElementById('editStepModal').style.display = 'none';
    }
    
    function saveEditStep() {
        const mdStr = document.getElementById('editStepContent').value;
        try {
            const newStep = markdownToStep(mdStr);
            newStep.rawMd = mdStr; // Preserve the exact edited Markdown
            config.stages[editingStageIndex].steps[editingStepIndex] = newStep;
            renderCurrentStage();
            triggerAutosave();
            closeEditStep();
        } catch (e) {
            showError('Invalid Markdown: ' + e.message);
        }
    }
    
    // Convert step object to Markdown string
    function stepToMarkdown(step) {
        if (step.rawMd) {
            return step.rawMd;
        }
        // Fallback to reconstructed
        let md = `### ${step.title || 'Untitled'}\n\n`;
        md += step.done ? '- [x]\n\n' : '- [ ]\n\n';
        if (step.notes) {
            md += `${step.notes}\n\n`;
        }
        if (step.command) {
            md += `\`\`\`\n${step.command}\n\`\`\`\n\n`;
        }
        if (step.userNotes) {
            md += `#### Notes\n\n${step.userNotes}\n\n`;
        }
        return md.trim();
    }
    
    // Convert Markdown string back to step object
    function markdownToStep(md) {
        const lines = md.split('\n');
        const step = { done: false, notes: '', command: '', userNotes: '' };
        let inCodeBlock = false;
        let codeBuffer = [];
        let notesBuffer = [];
        let collectingNotes = false;
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            if (line.startsWith('### ')) {
                step.title = line.substring(4).trim();
                step.id = step.title.toLowerCase().replace(/[^a-z0-9]+/g, '_');
            } else if (line.trim() === '- [x]' || line.trim() === '- [X]') {
                step.done = true;
            } else if (line.trim() === '- [ ]') {
                step.done = false;
            } else if (line.trim() === '```') {
                if (inCodeBlock) {
                    step.command = codeBuffer.join('\n').trim();
                    inCodeBlock = false;
                    codeBuffer = [];
                } else {
                    inCodeBlock = true;
                }
            } else if (inCodeBlock) {
                codeBuffer.push(line);
            } else if (line.trim().startsWith('**Personal Notes:**')) {
                collectingNotes = true;
                notesBuffer = [];
            } else if (collectingNotes) {
                if (line.trim() !== '') {
                    notesBuffer.push(line);
                }
            } else if (line.trim() !== '') {
                if (step.notes) {
                    step.notes += '\n' + line.trim();
                } else {
                    step.notes = line.trim();
                }
            }
        }
        
        if (notesBuffer.length > 0) {
            step.userNotes = notesBuffer.join('\n').trim();
        }
        
        return step;
    }
    
    // Handle Markdown keyboard shortcuts
    function handleMarkdownShortcuts(e) {
        if (e.ctrlKey) {
            switch (e.key) {
                case 'b':
                    e.preventDefault();
                    insertMarkdown('**', '**');
                    break;
                case 'i':
                    e.preventDefault();
                    insertMarkdown('*', '*');
                    break;
                case '`':
                    e.preventDefault();
                    insertMarkdown('`', '`');
                    break;
            }
        }
    }
    
    // Insert Markdown formatting around selection
    function insertMarkdown(before, after) {
        const textarea = document.getElementById('editStepContent');
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const selected = textarea.value.substring(start, end);
        const replacement = before + selected + after;
        textarea.value = textarea.value.substring(0, start) + replacement + textarea.value.substring(end);
        textarea.selectionStart = textarea.selectionEnd = start + replacement.length;
        textarea.focus();
    }
    
    // Add new stage
    function addNewStage() {
        const stageName = prompt('Enter new stage name:');
        if (stageName && stageName.trim()) {
            config.stages.push({
                name: stageName.trim(),
                steps: []
            });
            currentStageIndex = config.stages.length - 1;
            renderStageTabs();
            renderCurrentStage();
            updateProgress();
            triggerAutosave();
        }
    }
    
    // Add new step to current stage
    function addNewStep() {
        if (currentStageIndex < 0 || currentStageIndex >= config.stages.length) {
            showError('No stage selected');
            return;
        }
        
        const stepTitle = prompt('Enter new step title:');
        if (stepTitle && stepTitle.trim()) {
            config.stages[currentStageIndex].steps.push({
                id: stepTitle.toLowerCase().replace(/[^a-z0-9]+/g, '_'),
                title: stepTitle.trim(),
                notes: '',
                command: '',
                done: false,
                userNotes: ''
            });
            renderCurrentStage();
            updateProgress();
            triggerAutosave();
        }
    }
    
    // Raw editor functions
    function showRawEditor() {
        const modal = document.getElementById('rawEditorModal');
        const textarea = document.getElementById('rawEditorContent');
        textarea.value = convertToMarkdown();
        modal.style.display = 'block';
    }
    
    function closeRawEditor() {
        document.getElementById('rawEditorModal').style.display = 'none';
    }
    
    function saveRawEditor() {
        const content = document.getElementById('rawEditorContent').value;
        try {
            // Parse the markdown content
            const { config: configData, markdown } = parseMarkdownFrontMatter(content);
            const { title, stages } = parseMarkdownStages(markdown);
            
            config = {
                title: title,
                config: configData,
                stages: stages
            };
            
            // Re-render everything
            renderTitle();
            renderVars();
            renderStageTabs();
            renderCurrentStage();
            updateProgress();
            
            closeRawEditor();
            triggerAutosave();
            showSuccess('Changes applied from raw editor');
        } catch (e) {
            showError(`Failed to parse markdown: ${e.message}`);
        }
    }
    
    // Version upgrade functions
    function showVersionUpgrade() {
        const modal = document.getElementById('versionUpgradeModal');
        const select = document.getElementById('targetVersionSelect');
        
        // Populate version options
        const currentVer = document.getElementById('selVer').value;
        const verSelect = document.getElementById('selVer');
        select.innerHTML = '<option value="">Select version...</option>';
        
        Array.from(verSelect.options).forEach(opt => {
            if (opt.value !== currentVer) {
                const newOpt = document.createElement('option');
                newOpt.value = opt.value;
                newOpt.textContent = opt.textContent;
                select.appendChild(newOpt);
            }
        });
        
        // Add option to create new version
        const newVerOpt = document.createElement('option');
        newVerOpt.value = '__new__';
        newVerOpt.textContent = '‚ûï Create New Version...';
        select.appendChild(newVerOpt);
        
        modal.style.display = 'block';
    }
    
    function closeVersionUpgrade() {
        document.getElementById('versionUpgradeModal').style.display = 'none';
        // Reset new version input
        document.getElementById('newVersionDiv').style.display = 'none';
        document.getElementById('newVersionInput').value = '';
    }
    
    function onTargetVersionChange() {
        const select = document.getElementById('targetVersionSelect');
        const newVersionDiv = document.getElementById('newVersionDiv');
        
        if (select.value === '__new__') {
            newVersionDiv.style.display = 'block';
        } else {
            newVersionDiv.style.display = 'none';
            document.getElementById('newVersionInput').value = '';
        }
    }
    
    async function confirmVersionUpgrade() {
        const select = document.getElementById('targetVersionSelect');
        let targetVersion = select.value;
        
        if (!targetVersion) {
            showError('Please select a target version');
            return;
        }
        
        // Handle new version creation
        if (targetVersion === '__new__') {
            const newVersionInput = document.getElementById('newVersionInput');
            targetVersion = newVersionInput.value.trim();
            
            if (!targetVersion) {
                showError('Please enter a version number');
                return;
            }
            
            // Validate version format (should contain numbers and dots)
            if (!/^\d+(\.\d+)*$/.test(targetVersion)) {
                showError('Version should contain only numbers and dots (e.g., 24.6)');
                return;
            }
        }
        
        const currentClient = document.getElementById('selClient').value;
        const currentVersion = document.getElementById('selVer').value;
        
        try {
            // Archive current notes under #### history in each step
            config.stages.forEach(stage => {
                stage.steps.forEach(step => {
                    if (step.userNotes) {
                        const historyEntry = `\n\n---\n\n**üìö Previous Version Notes (v${currentVersion} - ${new Date().toISOString().split('T')[0]})**\n\n${step.userNotes}`;
                        step.userNotes = historyEntry;
                    }
                    // Reset done status
                    step.done = false;
                });
            });
            
            // Update title
            config.title = config.title.replace(currentVersion, targetVersion);
            
            // Update version in config
            if (config.config.version) {
                config.config.version = targetVersion;
            }
            
            // Save to new version folder
            const basePath = getVersionsBasePath();
            const newPath = `${basePath}/${targetVersion}/${currentClient}.md`;
            const oldPath = CURRENT_YAML_PATH;
            CURRENT_YAML_PATH = newPath;
            FILE_SHA = ""; // New file
            
            await saveData();
            
            // Update UI to show new version
            document.getElementById('selVer').value = targetVersion;
            
            console.log(`[SMAX Tool] Upgraded from ${currentVersion} to ${targetVersion}`);
            showSuccess(`Successfully upgraded to version ${targetVersion}`);
            
            closeVersionUpgrade();
            
            // Refresh the version list to include the new version
            await fetchFolders();
            
            await loadData();
            
        } catch (e) {
            console.error('[SMAX Tool] Version upgrade error:', e);
            showError(`Version upgrade failed: ${e.message}`);
        }
    }
    
    // Image upload to notes via GitHub API
    async function uploadImageToGitHub(file, noteTextarea) {
        if (!GITHUB_TOKEN) {
            showError('GitHub token required for image upload');
            return;
        }
        
        try {
            // Read file as base64
            const reader = new FileReader();
            reader.onload = async (e) => {
                const base64Content = e.target.result.split(',')[1];
                const fileName = `images/${Date.now()}-${file.name}`;
                const ver = document.getElementById('selVer').value;
                const basePath = getVersionsBasePath();
                const imagePath = `${basePath}/${ver}/${fileName}`;
                
                // Upload to GitHub
                const response = await fetch(
                    `https://api.github.com/repos/${OWNER}/${REPO}/contents/${imagePath}`,
                    {
                        method: 'PUT',
                        headers: {
                            'Authorization': `token ${GITHUB_TOKEN}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            message: `Upload image ${file.name}`,
                            content: base64Content
                        })
                    }
                );
                
                if (!response.ok) {
                    throw new Error('Failed to upload image');
                }
                
                const result = await response.json();
                const imageUrl = result.content.download_url;
                
                // Insert markdown image link at cursor
                const markdownLink = `\n![${file.name}](${imageUrl})\n`;
                const cursorPos = noteTextarea.selectionStart;
                const textBefore = noteTextarea.value.substring(0, cursorPos);
                const textAfter = noteTextarea.value.substring(cursorPos);
                noteTextarea.value = textBefore + markdownLink + textAfter;
                
                // Trigger preview update
                noteTextarea.dispatchEvent(new Event('input'));
                
                showSuccess('Image uploaded successfully');
            };
            reader.readAsDataURL(file);
        } catch (e) {
            console.error('[SMAX Tool] Image upload error:', e);
            showError(`Image upload failed: ${e.message}`);
        }
    }
    
    // Handle paste events for image upload
    function setupImagePaste(textarea) {
        textarea.addEventListener('paste', async (e) => {
            const items = e.clipboardData.items;
            for (let item of items) {
                if (item.type.indexOf('image') !== -1) {
                    e.preventDefault();
                    const file = item.getAsFile();
                    await uploadImageToGitHub(file, textarea);
                    break;
                }
            }
        });
        
        // Drag and drop support
        textarea.addEventListener('dragover', (e) => {
            e.preventDefault();
            textarea.classList.add('dragging');
        });
        
        textarea.addEventListener('dragleave', () => {
            textarea.classList.remove('dragging');
        });
        
        textarea.addEventListener('drop', async (e) => {
            e.preventDefault();
            textarea.classList.remove('dragging');
            
            const files = e.dataTransfer.files;
            for (let file of files) {
                if (file.type.indexOf('image') !== -1) {
                    await uploadImageToGitHub(file, textarea);
                    break;
                }
            }
        });
    }
</script>
</body>
</html>
