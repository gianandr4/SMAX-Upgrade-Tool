<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SMAX Multi-Client Upgrade Hub</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/1.5.3/jspdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        :root { 
            --primary: #2ea44f; 
            --dark: #24292e; 
            --bg: #f6f8fa; 
            --border: #d1d5da;
            --text: #24292e;
            --card-bg: #ffffff;
        }
        
        /* Dark mode variables */
        body.dark-mode {
            --dark: #f6f8fa;
            --bg: #0d1117;
            --border: #30363d;
            --text: #c9d1d9;
            --card-bg: #161b22;
        }
        
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif; 
            background: var(--bg); 
            margin: 0; 
            color: var(--text);
            transition: background 0.3s, color 0.3s;
        }
        
        /* Header & Controls */
        .header { background: var(--dark); color: white; padding: 1rem 2rem; display: flex; justify-content: space-between; align-items: center; }
        .controls { display: flex; gap: 12px; flex-wrap: wrap; background: #fff; padding: 15px 2rem; border-bottom: 1px solid var(--border); position: sticky; top: 0; z-index: 100; align-items: center; position: relative; }
        
        /* Layout */
        .container { max-width: 1000px; margin: 20px auto; padding: 0 20px; }
        .card { background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; padding: 16px; margin-bottom: 16px; position: relative; }
        .step-done { background: #f0fff4; border-left: 6px solid var(--primary); }
        body.dark-mode .step-done { background: #0d3818; }
        
        /* Elements */
        pre { background: #1b1f23; color: #e1e4e8; padding: 16px; border-radius: 6px; overflow-x: auto; font-family: ui-monospace, monospace; font-size: 13px; position: relative; }
        .copy-btn { position: absolute; top: 8px; right: 8px; background: #0366d6; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; }
        textarea { width: 100%; margin-top: 10px; border: 1px solid var(--border); border-radius: 6px; padding: 10px; font-family: inherit; box-sizing: border-box; }
        input, select { padding: 8px 12px; border: 1px solid var(--border); border-radius: 6px; font-size: 14px; }
        
        /* Status Indicators */
        .status-area { display: flex; align-items: center; gap: 8px; font-size: 12px; }
        .indicator { width: 10px; height: 10px; border-radius: 50%; background: #d1d5da; }
        .online { background: var(--primary); box-shadow: 0 0 5px var(--primary); }
        .error-msg { background: #ffeef0; color: #d73a49; padding: 10px; border-radius: 6px; margin-bottom: 15px; display: none; border: 1px solid #f97583; }
        
        /* Stage Navigation */
        .stage-tabs { display: flex; gap: 8px; background: var(--card-bg); padding: 15px 2rem; border-bottom: 1px solid var(--border); overflow-x: auto; }
        .stage-tab { padding: 10px 20px; border-radius: 6px 6px 0 0; cursor: pointer; background: var(--bg); border: 1px solid var(--border); border-bottom: none; transition: all 0.2s; white-space: nowrap; }
        .stage-tab:hover { background: #e1e4e8; }
        body.dark-mode .stage-tab:hover { background: #21262d; }
        .stage-tab.active { background: var(--card-bg); border-bottom: 2px solid var(--card-bg); margin-bottom: -1px; font-weight: 600; color: var(--primary); }
        
        /* Progress Indicator */
        .progress-bar { height: 8px; background: var(--bg); border-radius: 4px; margin: 10px 0; overflow: hidden; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, var(--primary), #34d058); transition: width 0.3s ease; }
        
        /* Stage Navigation Buttons */
        .stage-nav { display: flex; justify-content: space-between; margin: 20px 0; }
        .stage-nav button { padding: 10px 20px; border: 1px solid var(--border); border-radius: 6px; cursor: pointer; background: var(--card-bg); font-weight: 500; color: var(--text); }
        .stage-nav button:hover { background: var(--bg); }
        .stage-nav button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        /* Markdown Notes */
        .note-section { margin-top: 15px; border-top: 1px solid var(--border); padding-top: 15px; }
        .note-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .note-header h5 { margin: 0; color: #586069; font-size: 14px; }
        .note-toggle { background: none; border: none; color: var(--primary); cursor: pointer; font-size: 12px; text-decoration: underline; }
        .note-editor { display: none; }
        .note-editor.active { display: block; }
        .note-content.editing .note-preview { display: none; }
        .note-content.editing .note-textarea { display: block; }
        .note-content:not(.editing) .note-preview { display: block; }
        .note-content:not(.editing) .note-textarea { display: none; }
        .note-preview { background: var(--bg); border: 1px solid var(--border); border-radius: 6px; padding: 12px; min-height: 40px; color: var(--text); }
        .note-preview h1, .note-preview h2, .note-preview h3 { margin-top: 0; }
        .note-preview code { background: #1b1f23; color: #e1e4e8; padding: 2px 6px; border-radius: 3px; font-family: ui-monospace, monospace; }
        .note-preview pre { background: #1b1f23; color: #e1e4e8; padding: 12px; border-radius: 6px; overflow-x: auto; }
        .note-preview pre code { background: none; padding: 0; }
        .note-preview ul, .note-preview ol { padding-left: 25px; }
        .note-preview blockquote { border-left: 4px solid var(--border); padding-left: 15px; color: #586069; margin: 10px 0; }
        
        /* Reset Button */
        .reset-btn { background: #d73a49; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500; }
        .reset-btn:hover { background: #cb2431; }
        
        /* Modal */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.4); }
        .modal-content { background-color: var(--card-bg); margin: 15% auto; padding: 20px; border: 1px solid var(--border); border-radius: 6px; width: 400px; max-width: 90%; }
        .modal-buttons { display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px; }
        
        /* Inline editing */
        .editable { cursor: pointer; padding: 2px 6px; border-radius: 4px; transition: background 0.2s; }
        .editable:hover { background: var(--bg); }
        .editing { background: var(--card-bg); border: 1px solid var(--primary); padding: 4px 8px; }
        
        /* Notes toggle button */
        .note-toggle-btn { background: none; border: 1px solid var(--border); padding: 4px 12px; border-radius: 6px; cursor: pointer; color: var(--text); font-size: 12px; }
        .note-toggle-btn:hover { background: var(--bg); }
        .note-toggle-btn.has-notes { background: var(--primary); color: white; border-color: var(--primary); }
        
        /* Add buttons */
        .add-btn { background: var(--primary); color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; margin: 10px 0; }
        .add-btn:hover { background: #2c974b; }
        
        /* Autosave indicator */
        .autosave-indicator { font-size: 11px; color: #586069; margin-left: 10px; }
        
        /* Dark mode toggle */
        .theme-toggle { background: none; border: 1px solid var(--border); padding: 6px 12px; border-radius: 6px; cursor: pointer; color: var(--text); }
        .theme-toggle:hover { background: var(--bg); }
        
        /* Raw editor */
        .raw-editor { width: 100%; height: 600px; font-family: ui-monospace, monospace; font-size: 13px; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--card-bg); color: var(--text); }
        
        /* Image upload */
        .image-upload-area { border: 2px dashed var(--border); border-radius: 6px; padding: 20px; text-align: center; margin: 10px 0; cursor: pointer; }
        .image-upload-area:hover { background: var(--bg); }
        .image-upload-area.dragging { border-color: var(--primary); background: var(--bg); }
        
        /* Environment Variables Sidebar */
        .env-vars-sidebar { position: fixed; top: 300px; right: -310px; width: 300px; max-height: 70vh; overflow-y: auto; z-index: 100; box-shadow: 0 4px 12px rgba(0,0,0,0.15); transition: right 0.3s ease; }
        .env-vars-sidebar.open { right: 20px; }
        
        /* Client Menu Modal */
        .client-menu-modal { position: fixed; top: 300px; left: 50px; width: 300px; max-height: 70vh; overflow-y: auto; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        
        /* Edit Step Modal */
        .edit-step-modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 600px; max-height: 80vh; overflow-y: auto; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .menu-item { padding: 8px 12px; cursor: pointer; border-bottom: 1px solid var(--border); }
        .menu-item:hover { background: var(--border); }
        .menu-item.selected { background: var(--primary); color: white; }
        .submenu { margin-left: 20px; }
        .submenu .menu-item { border-bottom: none; }
    </style>
</head>
<body>

<div class="header">
    <strong id="appTitle">SMAX Multi-Tenant Operations</strong>
    <div class="status-area">
        <button class="theme-toggle" onclick="toggleDarkMode()" title="Toggle dark mode">
            <span id="theme-icon">üåô</span>
        </button>
        <div id="syncInd" class="indicator"></div>
        <span id="syncStat">Offline</span>
        <span id="autosave-status" class="autosave-indicator"></span>
    </div>
</div>

<div class="controls">
    <input type="password" id="ghToken" placeholder="Paste GitHub Token">
    
    <select id="selProduct">
        <option value="SMAX">SMAX</option>
        <option value="OTHER">Other Products (Future)</option>
    </select>
    
    <select id="selVer" onchange="onVersionChange()">
        <option value="">Select version...</option>
    </select>

    <select id="selClient" onchange="loadData()">
        <option value="">Loading clients...</option>
    </select>

    <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
        <input type="checkbox" id="autosaveToggle" onchange="toggleAutosave()" checked />
        Autosave
    </label>

    <button onclick="saveData()" style="background: var(--primary); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
        üíæ Save Progress
    </button>
    
    <button onclick="exportToPDF()" style="background: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
        üìÑ Export Full PDF
    </button>
    
    <button onclick="loadData()" style="background: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
        üîÑ Refresh Data
    </button>
    
    <button onclick="showRawEditor()" style="background: #6f42c1; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
        üìù Raw Editor
    </button>
    
    <button onclick="showVersionUpgrade()" style="background: #0366d6; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
        üöÄ Upgrade to Version
    </button>
    
    <button onclick="toggleEnvVars()" id="envToggleBtn" style="background: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
        ‚öôÔ∏è Variables
    </button>
    
    <button onclick="toggleClientMenu()" id="menuToggleBtn" style="background: #17a2b8; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
        üìÅ Menu
    </button>
    
    <div class="card client-menu-modal" id="client-menu-card" style="display: none;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h4 style="margin: 0;">Clients & Versions</h4>
            <button onclick="closeClientMenu()" style="background: none; border: none; font-size: 18px; cursor: pointer; color: var(--text);">‚úï</button>
        </div>
        <div id="client-menu-content"></div>
    </div>
    
    <button onclick="showResetModal()" class="reset-btn">
        üîÑ Reset All Done Steps
    </button>
</div>

<div id="stage-tabs-container" class="stage-tabs" style="display: none;"></div>

<div class="container">
    <div id="errorBox" class="error-msg"></div>
    
    <!-- Document Title -->
    <div id="doc-title-container" style="display: none; margin-bottom: 20px;">
        <h2 id="doc-title" class="editable" onclick="editTitle()" style="margin: 0; cursor: pointer;">Document Title</h2>
    </div>
    
    <div id="progress-container" style="display: none;">
        <h4>Stage Progress</h4>
        <div class="progress-bar">
            <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
        </div>
        <div style="font-size: 12px; color: #586069; margin-top: 5px;">
            <span id="progress-text">0 of 0 steps completed</span>
        </div>
    </div>

    <div class="card env-vars-sidebar" id="env-vars-card" style="display: none;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h4 style="margin: 0;">Environment Variables</h4>
            <div>
                <button onclick="editEnvVars()" style="background: #0366d6; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; margin-right: 8px;">Edit Raw</button>
                <button onclick="closeEnvVars()" style="background: none; border: none; font-size: 18px; cursor: pointer; color: var(--text);">‚úï</button>
            </div>
        </div>
        <div id="var-inputs" style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:15px;"></div>
    </div>
    
    <div class="stage-nav" id="stage-nav" style="display: none;">
        <button id="prev-stage-btn" onclick="prevStage()">‚Üê Previous Stage</button>
        <div>
            <button class="add-btn" onclick="addNewStage()">‚ûï Add New Stage</button>
        </div>
        <button id="next-stage-btn" onclick="nextStage()">Next Stage ‚Üí</button>
    </div>

    <div id="steps-list"></div>
    
    <div style="text-align: center; margin: 20px 0;" id="add-step-container" style="display: none;">
        <button class="add-btn" onclick="addNewStep()">‚ûï Add New Step to Current Stage</button>
    </div>
    
    <div class="stage-nav" id="stage-nav-bottom" style="display: none;">
        <button id="prev-stage-btn-bottom" onclick="prevStage()">‚Üê Previous Stage</button>
        <button id="next-stage-btn-bottom" onclick="nextStage()">Next Stage ‚Üí</button>
    </div>
</div>

<!-- Reset Confirmation Modal -->
<div id="resetModal" class="modal">
    <div class="modal-content">
        <h3 style="margin-top: 0;">Reset Completed Steps</h3>
        <p>Are you sure you want to reset all completed steps? This will mark all steps as incomplete.</p>
        <div class="modal-buttons">
            <button onclick="closeResetModal()" style="padding: 8px 16px; border: 1px solid var(--border); border-radius: 6px; cursor: pointer; background: white;">
                Cancel
            </button>
            <button onclick="confirmReset()" class="reset-btn">
                Reset All
            </button>
        </div>
    </div>
</div>

<!-- Raw Editor Modal -->
<div id="rawEditorModal" class="modal">
    <div class="modal-content" style="width: 80%; max-width: 900px;">
        <h3 style="margin-top: 0;">Raw Markdown Editor</h3>
        <textarea id="rawEditorContent" class="raw-editor"></textarea>
        <div class="modal-buttons">
            <button onclick="closeRawEditor()" style="padding: 8px 16px; border: 1px solid var(--border); border-radius: 6px; cursor: pointer; background: var(--card-bg); color: var(--text);">
                Cancel
            </button>
            <button onclick="saveRawEditor()" style="background: var(--primary); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                Apply Changes
            </button>
        </div>
    </div>
</div>

<!-- Version Upgrade Modal -->
<div id="versionUpgradeModal" class="modal">
    <div class="modal-content">
        <h3 style="margin-top: 0;">Upgrade to New Version</h3>
        <p>Select target version to clone this configuration:</p>
        <select id="targetVersionSelect" style="width: 100%; padding: 8px; margin: 10px 0; border: 1px solid var(--border); border-radius: 6px; background: var(--card-bg); color: var(--text);" onchange="onTargetVersionChange()">
            <option value="">Select version...</option>
        </select>
        <div id="newVersionDiv" style="display: none; margin: 10px 0;">
            <label for="newVersionInput" style="display: block; margin-bottom: 5px; font-weight: 500;">New Version Number:</label>
            <input type="text" id="newVersionInput" placeholder="e.g., 24.6" style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 6px; background: var(--card-bg); color: var(--text);">
        </div>
        <div class="modal-buttons">
            <button onclick="closeVersionUpgrade()" style="padding: 8px 16px; border: 1px solid var(--border); border-radius: 6px; cursor: pointer; background: var(--card-bg); color: var(--text);">
                Cancel
            </button>
            <button onclick="confirmVersionUpgrade()" style="background: var(--primary); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                Upgrade
            </button>
        </div>
    </div>
</div>

<!-- Edit Step Modal -->
<div id="editStepModal" class="modal edit-step-modal">
    <div class="modal-content">
        <h3 style="margin-top: 0;">Edit Step</h3>
        <textarea id="editStepContent" class="raw-editor"></textarea>
        <div class="modal-buttons">
            <button onclick="closeEditStep()" style="padding: 8px 16px; border: 1px solid var(--border); border-radius: 6px; cursor: pointer; background: var(--card-bg); color: var(--text);">
                Cancel
            </button>
            <button onclick="saveEditStep()" style="background: var(--primary); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                Apply Changes
            </button>
        </div>
    </div>
</div>

<!-- Edit Environment Variables Modal -->
<div id="editEnvVarsModal" class="modal">
    <div class="modal-content" style="width: 80%; max-width: 600px;">
        <h3 style="margin-top: 0;">Edit Environment Variables (YAML)</h3>
        <textarea id="editEnvVarsContent" class="raw-editor" style="height: 300px;"></textarea>
        <div class="modal-buttons">
            <button onclick="closeEditEnvVars()" style="padding: 8px 16px; border: 1px solid var(--border); border-radius: 6px; cursor: pointer; background: var(--card-bg); color: var(--text);">
                Cancel
            </button>
            <button onclick="saveEditEnvVars()" style="background: var(--primary); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                Apply Changes
            </button>
        </div>
    </div>
</div>

<script>
// Wait for DOM to be ready
document.addEventListener('DOMContentLoaded', async function() {
    // Initialize the application
    await initializeApp();
});

async function initializeApp() {
    // Global variables
    let GITHUB_TOKEN = sessionStorage.getItem('github_token') || "";
    let FILE_SHA = "";
    let CURRENT_YAML_PATH = "";
    let config = { title: "", config: {}, stages: [] };
    let currentStageIndex = 0;
    let autosaveEnabled = localStorage.getItem('autosave_enabled') !== 'false'; // Default to true
    let autosaveTimeout = null;
    let editingStageIndex, editingStepIndex;
    let menuData = {}; // Store versions and their clients

    // Hardcoded repository information for personal use
    const OWNER = "gianandr4";
    const REPO = "SMAX-Upgrade-Tool";

    // Dynamic product path based on selection
    function getVersionsBasePath() {
        const product = document.getElementById('selProduct').value;
        return product === 'SMAX' ? 'SMAX' : product;
    }

    // Trigger autosave after changes
    function triggerAutosave() {
        if (autosaveEnabled) {
            saveData();
        }
    }

    // Toggle autosave functionality
    function toggleAutosave() {
        const checkbox = document.getElementById('autosaveToggle');
        autosaveEnabled = checkbox.checked;
        console.log('[SMAX Tool] Autosave', autosaveEnabled ? 'enabled' : 'disabled');
        // Optionally save the preference
        localStorage.setItem('autosave_enabled', autosaveEnabled);
    }

    async function connect(autoConnect = false) {
        GITHUB_TOKEN = document.getElementById('ghToken').value;
        if (!GITHUB_TOKEN) {
            if (!autoConnect) {
                showError('Please enter a GitHub token');
            }
            return;
        }
        // Cache token in session storage
        sessionStorage.setItem('github_token', GITHUB_TOKEN);
        console.log('[SMAX Tool] Token set, length:', GITHUB_TOKEN.length);
        if (!autoConnect) {
            console.log('[SMAX Tool] Connecting with GitHub token...');
        } else {
            console.log('[SMAX Tool] Auto-connecting with cached GitHub token...');
        }
        
        // Restore product selection or default to SMAX
        const cachedProduct = sessionStorage.getItem('selected_product') || 'SMAX';
        document.getElementById('selProduct').value = cachedProduct;
        
        // Update app title
        const titleElement = document.getElementById('appTitle');
        titleElement.textContent = `${cachedProduct} Multi-Tenant Operations`;
        
        // Step 1: Dynamically find folders
        await fetchFolders();
        // Step 2: Load data for selected folder (will use cached selections or defaults)
        loadData();
    }

    // NEW: Automatically find version folders (e.g., 24.4, 25.1)
    async function fetchFolders() {
        if (!GITHUB_TOKEN) return;
        try {
            const basePath = getVersionsBasePath();
            console.log(`[SMAX Tool] Fetching folders from ${OWNER}/${REPO}/${basePath}...`);
            const resp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${basePath}`, {
                headers: { Authorization: `token ${GITHUB_TOKEN}` }
            });
            
            console.log(`[SMAX Tool] API call to ${OWNER}/${REPO}/contents/${basePath} returned status: ${resp.status}`);
            
            if (!resp.ok) {
                const errorData = await resp.json();
                console.error(`[SMAX Tool] fetchFolders failed:`, errorData);
                throw new Error(`GitHub API: ${errorData.message || resp.statusText}`);
            }
            
            const items = await resp.json();
            console.log(`[SMAX Tool] fetchFolders received ${items.length} items:`, items.map(item => `${item.name} (${item.type})`));
            const folderSelect = document.getElementById('selVer');
            
            // Clear existing options
            folderSelect.innerHTML = "";

            // Collect directories
            const directories = new Set();
            
            // Add actual directories
            items.filter(item => item.type === 'dir' && !item.name.startsWith('.')).forEach(item => {
                directories.add(item.name);
            });
            
            // Also infer directories from file paths
            items.filter(item => item.type === 'file').forEach(item => {
                const pathParts = item.path.replace(basePath + '/', '').split('/');
                if (pathParts.length > 1) {
                    directories.add(pathParts[0]);
                }
            });
            
            const folders = Array.from(directories).sort();
            
            if (folders.length === 0) {
                showError('No version folders found in repository');
                return;
            }
            
            folders.forEach(folderName => {
                const opt = document.createElement('option');
                opt.value = folderName;
                opt.innerText = `Version ${folderName}`;
                folderSelect.appendChild(opt);
                
                // Store in menu data
                menuData[folderName] = [];
            });
            
            console.log(`[SMAX Tool] Found ${folders.length} version folder(s): ${folders.join(', ')}`);
            
            renderClientMenu();
            
            // Load clients for cached version or first version
            const cachedVersion = sessionStorage.getItem('selected_version');
            const targetVersion = cachedVersion && folders.includes(cachedVersion) ? cachedVersion : folders[0];
            
            if (targetVersion) {
                document.getElementById('selVer').value = targetVersion;
                await fetchClients(targetVersion);
            }
        } catch (e) {
            console.error('[SMAX Tool] fetchFolders error:', e);
            showError(`Failed to load folders: ${e.message}`);
        }
    }
    
    // NEW: Fetch clients from version folder
    async function fetchClients(version) {
        if (!GITHUB_TOKEN) return;
        try {
            const basePath = getVersionsBasePath();
            console.log(`[SMAX Tool] Fetching clients from ${basePath}/${version}/...`);
            const resp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${basePath}/${version}`, {
                headers: { Authorization: `token ${GITHUB_TOKEN}` }
            });
            
            if (!resp.ok) {
                const errorData = await resp.json();
                console.error(`[SMAX Tool] Failed to fetch clients for ${version}:`, errorData);
                throw new Error(`GitHub API: ${errorData.message || resp.statusText}`);
            }
            
            const items = await resp.json();
            console.log(`[SMAX Tool] Found ${items.length} items in ${basePath}/${version}:`, items.map(item => `${item.name} (${item.type})`));
            
            const clientSelect = document.getElementById('selClient');
            
            // Clear existing options
            clientSelect.innerHTML = "";
            
            // Find all client markdown files (excluding README.md)
            const clientFiles = items.filter(item => 
                item.type === 'file' && 
                item.name.endsWith('.md') &&
                item.name !== 'README.md' &&
                item.name !== 'template.md'
            );
            
            console.log(`[SMAX Tool] Found ${clientFiles.length} client files:`, clientFiles.map(f => f.name));
            
            if (clientFiles.length === 0) {
                // If no clients found, it might be a timing issue after upgrade
                // Try again after a short delay
                console.log(`[SMAX Tool] No client files found, retrying in 2 seconds...`);
                setTimeout(() => fetchClients(version), 2000);
                return;
            }
            
            // Extract client names
            const clients = new Set();
            clientFiles.forEach(file => {
                // Extract client name from filename (e.g., "client-A.md")
                const clientName = file.name.replace(/\.md$/, '');
                clients.add(clientName);
                console.log(`[SMAX Tool] Added client: ${clientName} from file: ${file.name}`);
            });
            
            clients.forEach(client => {
                const opt = document.createElement('option');
                opt.value = client;
                opt.innerText = client.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                clientSelect.appendChild(opt);
            });
            
            // Store in menu data
            menuData[version] = Array.from(clients);
            renderClientMenu();
            
            // Restore cached client selection or select first available
            const cachedClient = sessionStorage.getItem('selected_client');
            if (cachedClient && clients.has(cachedClient)) {
                document.getElementById('selClient').value = cachedClient;
            } else if (clients.size > 0) {
                // Select first available client as default
                const firstClient = Array.from(clients)[0];
                document.getElementById('selClient').value = firstClient;
                sessionStorage.setItem('selected_client', firstClient);
            }
            
            console.log(`[SMAX Tool] Found ${clients.size} client(s)`);
        } catch (e) {
            console.error('[SMAX Tool] fetchClients error:', e);
            showError(`Failed to load clients: ${e.message}`);
        }
    }
    
    // NEW: Parse markdown with front-matter
    function parseMarkdownFrontMatter(content) {
        // Extract front-matter (between --- delimiters)
        const frontMatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
        const match = content.match(frontMatterRegex);
        
        if (!match) {
            throw new Error('Invalid markdown format: missing front-matter');
        }
        
        const frontMatter = jsyaml.load(match[1]);
        const markdown = match[2];
        
        return { config: frontMatter.config || {}, markdown };
    }
    
    // NEW: Parse markdown content into title, stages and steps
    // # = Document title
    // ## = Stages
    // ### = Steps
    function parseMarkdownStages(markdown) {
        const stages = [];
        const lines = markdown.split('\n');
        
        let documentTitle = '';
        let currentStage = null;
        let currentStep = null;
        let collectingCommand = false;
        let collectingNotes = false;
        let collectingSubsection = false;
        let commandBuffer = [];
        let notesBuffer = [];
        let subsectionBuffer = [];
        let currentSubsection = '';
        let rawBuffer = [];
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            // H1 = Document Title
            if (line.startsWith('# ') && !line.startsWith('## ')) {
                documentTitle = line.substring(2).trim();
                continue;
            }
            
            // H2 = New Stage
            if (line.startsWith('## ') && !line.startsWith('### ')) {
                if (currentStep && currentStage) {
                    currentStep.rawMd = rawBuffer.join('\n');
                    currentStage.steps.push(currentStep);
                }
                if (currentStage) {
                    stages.push(currentStage);
                }
                
                currentStage = {
                    name: line.substring(3).trim(),
                    steps: []
                };
                currentStep = null;
                collectingCommand = false;
                collectingNotes = false;
                collectingSubsection = false;
                rawBuffer = [];
                continue;
            }
            
            // Collect raw line for current step
            if (currentStep) {
                rawBuffer.push(line);
            }
            
            // Code block start/end
            if (line.trim().startsWith('```')) {
                if (collectingCommand) {
                    // End of command block
                    if (currentStep) {
                        currentStep.command = commandBuffer.join('\n').trim();
                    }
                    collectingCommand = false;
                    commandBuffer = [];
                } else {
                    // Start of command block
                    collectingCommand = true;
                }
                continue;
            }
            
            // Inside command block
            if (collectingCommand) {
                commandBuffer.push(line);
                continue;
            }
            

            // H4 = Notes section
            if (line.startsWith('#### ')) {
                const sectionTitle = line.substring(5).trim();
                if (sectionTitle.toLowerCase().includes('notes') || sectionTitle.toLowerCase().includes('note')) {
                    collectingNotes = true;
                    notesBuffer = [];
                    collectingSubsection = false;
                    currentSubsection = '';
                }
                continue;
            }
            
            // H5 = Subsection within notes (version-specific notes)
            if (collectingNotes && line.startsWith('##### ')) {
                // Save current notes as "Current" if we haven't started a subsection yet
                if (!currentSubsection && notesBuffer.length > 0) {
                    currentStep.userNotes['Current'] = notesBuffer.join('\n').trim();
                    notesBuffer = [];
                }
                // Save previous subsection if any
                if (currentSubsection && subsectionBuffer.length > 0) {
                    currentStep.userNotes[currentSubsection] = subsectionBuffer.join('\n').trim();
                }
                // Start new version-specific subsection
                currentSubsection = line.substring(6).trim();
                subsectionBuffer = [];
                collectingSubsection = true;
                continue;
            }
            
            // Collect notes content
            if (collectingNotes && currentStep) {
                // Check if we've reached the completion marker or next step/stage
                if (line.startsWith('### ')) {
                    const title = line.substring(4).trim();
                    if (title === '- [x] Complete' || title === '- [X] Complete' || title === '- [ ] Complete') {
                        // Save any remaining content
                        if (currentSubsection && subsectionBuffer.length > 0) {
                            currentStep.userNotes[currentSubsection] = subsectionBuffer.join('\n').trim();
                        } else if (!currentSubsection && notesBuffer.length > 0) {
                            currentStep.userNotes['Current'] = notesBuffer.join('\n').trim();
                        }
                        collectingNotes = false;
                        collectingSubsection = false;
                        // Don't continue here - let the completion marker be processed
                    } else {
                        // This is a new step, end notes
                        if (currentSubsection && subsectionBuffer.length > 0) {
                            currentStep.userNotes[currentSubsection] = subsectionBuffer.join('\n').trim();
                        } else if (!currentSubsection && notesBuffer.length > 0) {
                            currentStep.userNotes['Current'] = notesBuffer.join('\n').trim();
                        }
                        collectingNotes = false;
                        collectingSubsection = false;
                        // Don't continue here - let the header be processed normally
                    }
                } else if (line.startsWith('## ') || line.startsWith('# ')) {
                    // End of notes section
                    if (currentSubsection && subsectionBuffer.length > 0) {
                        currentStep.userNotes[currentSubsection] = subsectionBuffer.join('\n').trim();
                    } else if (!currentSubsection && notesBuffer.length > 0) {
                        currentStep.userNotes['Current'] = notesBuffer.join('\n').trim();
                    }
                    collectingNotes = false;
                    collectingSubsection = false;
                    // Don't continue here - let the header be processed normally
                } else if (line.trim() === '---') {
                    // Skip separator lines
                    continue;
                } else if (collectingSubsection) {
                    subsectionBuffer.push(line);
                    continue;
                } else {
                    // Content before first ##### goes to Current
                    notesBuffer.push(line);
                    continue;
                }
            }
            
            // H3 = New Step or Completion Marker
            if (line.startsWith('### ')) {
                const title = line.substring(4).trim();
                
                // Check if this is a completion marker
                if (title === '- [x] Complete' || title === '- [X] Complete') {
                    if (currentStep) {
                        currentStep.done = true;
                        currentStep.rawMd = rawBuffer.join('\n');
                        currentStage.steps.push(currentStep);
                    }
                    currentStep = null;
                    collectingCommand = false;
                    collectingNotes = false;
                    collectingSubsection = false;
                    rawBuffer = [];
                    continue;
                } else if (title === '- [ ] Complete') {
                    if (currentStep) {
                        currentStep.done = false;
                        currentStep.rawMd = rawBuffer.join('\n');
                        currentStage.steps.push(currentStep);
                    }
                    currentStep = null;
                    collectingCommand = false;
                    collectingNotes = false;
                    collectingSubsection = false;
                    rawBuffer = [];
                    continue;
                } else {
                    // This is a regular step title
                    if (currentStep && currentStage) {
                        currentStep.rawMd = rawBuffer.join('\n');
                        currentStage.steps.push(currentStep);
                    }
                    
                    currentStep = {
                        id: title.toLowerCase().replace(/[^a-z0-9]+/g, '_'),
                        title: title,
                        notes: '',
                        command: '',
                        done: false,
                        userNotes: {} // Changed from string to object
                    };
                    collectingCommand = false;
                    collectingNotes = false;
                    collectingSubsection = false;
                    commandBuffer = [];
                    notesBuffer = [];
                    subsectionBuffer = [];
                    currentSubsection = '';
                    rawBuffer = [line]; // Start collecting raw for this step
                    continue;
                }
            }
            
            // Regular content (step description/notes)
            if (currentStep && line.trim() !== '' && !collectingCommand && !collectingNotes) {
                if (line.trim() === '---') continue; // Skip separator lines
                if (currentStep.notes) {
                    currentStep.notes += '\n' + line.trim();
                } else {
                    currentStep.notes = line.trim();
                }
            }
        }
        
        // Add last step and stage
        if (currentStep && currentStage) {
            if (collectingNotes) {
                // Save Current notes if any
                if (!currentSubsection && notesBuffer.length > 0) {
                    currentStep.userNotes['Current'] = notesBuffer.join('\n').trim();
                }
                // Save any remaining subsection
                if (currentSubsection && subsectionBuffer.length > 0) {
                    currentStep.userNotes[currentSubsection] = subsectionBuffer.join('\n').trim();
                }
            }
            currentStep.rawMd = rawBuffer.join('\n');
            currentStage.steps.push(currentStep);
        }
        if (currentStage) {
            stages.push(currentStage);
        }
        
        return { title: documentTitle, stages: stages };
    }
    
    // NEW: Try to load markdown format
    async function tryLoadMarkdown(ver, client, mdPath) {
        try {
            let mdContent;
            
            if (GITHUB_TOKEN) {
                const resp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${mdPath}`, {
                    headers: { Authorization: `token ${GITHUB_TOKEN}` }
                });
                
                if (resp.status === 404) {
                    return false; // File doesn't exist, try YAML
                }
                
                if (!resp.ok) {
                    return false;
                }
                
                const data = await resp.json();
                FILE_SHA = data.sha;
                CURRENT_YAML_PATH = mdPath;
                mdContent = atob(data.content);
            } else {
                const resp = await fetch(mdPath);
                if (!resp.ok) return false;
                CURRENT_YAML_PATH = mdPath;
                mdContent = await resp.text();
            }
            
            console.log(`[SMAX Tool] Loading markdown from ${mdPath}...`);
            
            // Parse markdown
            const { config: configData, markdown } = parseMarkdownFrontMatter(mdContent);
            const { title, stages } = parseMarkdownStages(markdown);
            
            config = {
                title: title,
                config: configData,
                stages: stages
            };
            
            console.log(`[SMAX Tool] Loaded title: "${title}", ${stages.length} stage(s) from markdown`);
            
            if (GITHUB_TOKEN) {
                document.getElementById('syncInd').classList.add('online');
                document.getElementById('syncStat').innerText = `Synced: ${ver}/${client}`;
            }
            
            currentStageIndex = 0;
            renderTitle();
            renderVars();
            renderStageTabs();
            renderCurrentStage();
            updateProgress();
            
            return true;
            
        } catch (e) {
            console.error('[SMAX Tool] Failed to load markdown:', e);
            return false;
        }
    }

    // NEW: Handle version change - refresh client list
    async function onVersionChange() {
        const ver = document.getElementById('selVer').value;
        if (!ver) return;
        
        // Cache selected version
        sessionStorage.setItem('selected_version', ver);
        
        await fetchClients(ver);
        // Don't auto-load data, wait for user to select a client
    }
    
    async function onProductChange() {
        const product = document.getElementById('selProduct').value;
        
        // Update app title
        const titleElement = document.getElementById('appTitle');
        titleElement.textContent = `${product} Multi-Tenant Operations`;
        
        // Cache selected product
        sessionStorage.setItem('selected_product', product);
        
        // Clear version and client selections when product changes
        document.getElementById('selVer').innerHTML = '<option value="">Select version...</option>';
        document.getElementById('selClient').innerHTML = '<option value="">Loading clients...</option>';
        
        // Clear cached selections for this product
        sessionStorage.removeItem('selected_version');
        sessionStorage.removeItem('selected_client');
        
        // Fetch folders for the new product
        await fetchFolders();
    }
    
    async function loadData() {
        showError(""); 
        const ver = document.getElementById('selVer').value;
        const client = document.getElementById('selClient').value;
        
        if (!ver || !client) {
            console.log('[SMAX Tool] Waiting for version and client to be selected...');
            return;
        }

        // Cache selected client
        sessionStorage.setItem('selected_client', client);

        // Only support markdown format now
        const basePath = getVersionsBasePath();
        const mdPath = `${basePath}/${ver}/${client}.md`;
        
        // Try markdown first
        if (await tryLoadMarkdown(ver, client, mdPath)) {
            renderTitle();
            return;
        }
        
        // If no markdown, check for YAML and migrate
        const yamlPath = `${basePath}/${ver}/${client}.yaml`;
        console.log(`[SMAX Tool] No markdown found, checking for YAML to migrate...`);
        
        try {
            let yamlContent;
            let yamlSha = "";
            
            if (GITHUB_TOKEN) {
                const resp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${yamlPath}`, {
                    headers: { Authorization: `token ${GITHUB_TOKEN}` }
                });
                
                if (resp.status === 404) {
                    // Try to migrate from old format
                    console.log('[SMAX Tool] YAML not found, attempting migration from old format...');
                    await migrateFromOldFormat(ver, client);
                    return;
                }
                
                if (!resp.ok) {
                    const errorData = await resp.json();
                    throw new Error(`GitHub API: ${errorData.message || resp.statusText}`);
                }
                
                const data = await resp.json();
                yamlSha = data.sha;
                yamlContent = atob(data.content);
            } else {
                const resp = await fetch(yamlPath);
                if (!resp.ok) throw new Error(`No configuration found for ${client}`);
                yamlContent = await resp.text();
            }
            
            // Parse YAML
            let yamlConfig = jsyaml.load(yamlContent);
            
            if (!yamlConfig) {
                throw new Error('Invalid YAML structure');
            }
            
            // Convert old 'steps' to 'stages'
            if (yamlConfig.steps && !yamlConfig.stages) {
                console.log('[SMAX Tool] Converting old steps format to stages...');
                yamlConfig.stages = [{
                    name: 'Upgrade',
                    steps: yamlConfig.steps
                }];
                delete yamlConfig.steps;
            }
            
            // Migrate to markdown
            console.log('[SMAX Tool] Migrating YAML to Markdown format...');
            config = {
                title: yamlConfig.title || `${client} Upgrade`,
                config: yamlConfig.config || {},
                stages: yamlConfig.stages || []
            };
            
            // Save as markdown
            CURRENT_YAML_PATH = mdPath;
            FILE_SHA = ""; // New file
            await saveData();
            
            console.log('[SMAX Tool] Migration complete, reloading...');
            await loadData();
            
        } catch (e) {
            console.error('[SMAX Tool] loadData error:', e);
            showError(e.message);
        }
    }
    
    // NEW: Migrate from old format to new markdown format
    async function migrateFromOldFormat(ver, client) {
        try {
            console.log('[SMAX Tool] Migrating from old format...');
            
            // Try to load old managed or embedded steps file
            const basePath = getVersionsBasePath();
            let oldStepsPath = `${basePath}/${ver}/${client}-managed-steps.yaml`;
            let oldStatePath = `${basePath}/${ver}/state-${client}.yaml`;
            
            let stepsResp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${oldStepsPath}`, {
                headers: { Authorization: `token ${GITHUB_TOKEN}` }
            });
            
            if (stepsResp.status === 404) {
                // Try embedded format
                oldStepsPath = `${basePath}/${ver}/${client}-embedded-steps.yaml`;
                stepsResp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${oldStepsPath}`, {
                    headers: { Authorization: `token ${GITHUB_TOKEN}` }
                });
            }
            
            if (!stepsResp.ok) {
                throw new Error(`No client configuration found for ${client}`);
            }
            
            const stepsData = await stepsResp.json();
            const oldConfig = jsyaml.load(atob(stepsData.content));
            
            // Load old state file if exists
            let state = {};
            const stateResp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${oldStatePath}`, {
                headers: { Authorization: `token ${GITHUB_TOKEN}` }
            });
            
            if (stateResp.ok) {
                const stateData = await stateResp.json();
                state = jsyaml.load(atob(stateData.content)) || {};
            }
            
            // Create new unified config in markdown format
            config = {
                title: `${client} Upgrade to v${ver}`,
                config: oldConfig.config || {},
                stages: [{
                    name: 'Upgrade',
                    steps: (oldConfig.steps || []).map(step => {
                        return {
                            ...step,
                            done: state[`s_done_${step.id}`] === 'true',
                            userNotes: ''
                        };
                    })
                }]
            };
            
            // Apply variable state
            Object.keys(config.config).forEach(key => {
                if (state[`v_${key}`]) {
                    config.config[key] = state[`v_${key}`];
                }
            });
            
            // Save as markdown
            CURRENT_YAML_PATH = `${basePath}/${ver}/${client}.md`;
            FILE_SHA = ""; // Will create new file
            await saveData();
            
            console.log('[SMAX Tool] Migration complete, reloading...');
            await loadData();
            
        } catch (e) {
            console.error('[SMAX Tool] Migration error:', e);
            showError(`Migration failed: ${e.message}`);
        }
    }

    // Error handling with better logging
    function showError(msg) {
        const box = document.getElementById('errorBox');
        if (msg) {
            console.error('[SMAX Tool Error]:', msg);
            box.innerText = `‚ö†Ô∏è Error: ${msg}`;
            box.style.display = 'block';
        } else {
            box.style.display = 'none';
        }
    }

    // Render environment variables
    function renderVars() {
        const varInputs = document.getElementById('var-inputs');
        varInputs.innerHTML = '';
        
        if (!config.config) return;
        
        Object.entries(config.config).forEach(([key, defaultVal]) => {
            const wrapper = document.createElement('div');
            
            // Create label
            const label = document.createElement('label');
            label.style.fontSize = '12px';
            label.style.color = '#586069';
            label.style.display = 'block';
            label.style.marginBottom = '4px';
            label.textContent = key;
            
            // Create input
            const input = document.createElement('input');
            input.type = 'text';
            input.id = `var_${key}`;
            input.value = defaultVal;
            input.style.width = '100%';
            input.style.boxSizing = 'border-box';
            input.onchange = function() {
                config.config[key] = this.value;
            };
            
            wrapper.appendChild(label);
            wrapper.appendChild(input);
            varInputs.appendChild(wrapper);
        });
    }
    
    // NEW: Render stage tabs
    function renderStageTabs() {
        const container = document.getElementById('stage-tabs-container');
        container.innerHTML = '';
        container.style.display = 'flex';
        
        if (!config.stages || config.stages.length === 0) {
            container.style.display = 'none';
            return;
        }
        
        config.stages.forEach((stage, index) => {
            const tab = document.createElement('div');
            tab.className = 'stage-tab';
            if (index === currentStageIndex) {
                tab.className += ' active';
            }
            
            // Calculate completion for this stage
            const totalSteps = stage.steps.length;
            const completedSteps = stage.steps.filter(s => s.done).length;
            
            const stageName = document.createElement('div');
            stageName.textContent = stage.name;
            stageName.className = 'editable';
            stageName.ondblclick = (e) => {
                e.stopPropagation();
                editStageName(index);
            };
            stageName.title = 'Double-click to edit';
            
            const stageInfo = document.createElement('div');
            stageInfo.style.fontSize = '11px';
            stageInfo.style.color = '#586069';
            stageInfo.style.marginTop = '3px';
            stageInfo.textContent = `${completedSteps}/${totalSteps} steps`;
            
            tab.appendChild(stageName);
            tab.appendChild(stageInfo);
            
            tab.onclick = () => {
                currentStageIndex = index;
                renderStageTabs();
                renderCurrentStage();
                updateProgress();
            };
            
            container.appendChild(tab);
        });
    }
    
    // NEW: Render current stage
    function renderCurrentStage() {
        if (!config.stages || config.stages.length === 0) {
            document.getElementById('steps-list').innerHTML = '<p style="color:#586069;">No stages found.</p>';
            document.getElementById('stage-nav').style.display = 'none';
            document.getElementById('stage-nav-bottom').style.display = 'none';
            return;
        }
        
        const stage = config.stages[currentStageIndex];
        renderSteps(stage.steps);
        
        // Update navigation buttons
        document.getElementById('stage-nav').style.display = 'flex';
        document.getElementById('stage-nav-bottom').style.display = 'flex';
        
        const prevBtn = document.getElementById('prev-stage-btn');
        const nextBtn = document.getElementById('next-stage-btn');
        const prevBtnBottom = document.getElementById('prev-stage-btn-bottom');
        const nextBtnBottom = document.getElementById('next-stage-btn-bottom');
        
        prevBtn.disabled = currentStageIndex === 0;
        nextBtn.disabled = currentStageIndex === config.stages.length - 1;
        prevBtnBottom.disabled = currentStageIndex === 0;
        nextBtnBottom.disabled = currentStageIndex === config.stages.length - 1;
    }
    
    // NEW: Stage navigation
    function prevStage() {
        if (currentStageIndex > 0) {
            currentStageIndex--;
            renderStageTabs();
            renderCurrentStage();
            updateProgress();
            window.scrollTo(0, 0);
        }
    }
    
    function nextStage() {
        if (currentStageIndex < config.stages.length - 1) {
            currentStageIndex++;
            renderStageTabs();
            renderCurrentStage();
            updateProgress();
            window.scrollTo(0, 0);
        }
    }
    
    // NEW: Update progress indicator
    function updateProgress() {
        if (!config.stages || config.stages.length === 0) {
            document.getElementById('progress-container').style.display = 'none';
            return;
        }
        
        document.getElementById('progress-container').style.display = 'block';
        
        // Calculate total progress across all stages
        let totalSteps = 0;
        let completedSteps = 0;
        
        config.stages.forEach(stage => {
            totalSteps += stage.steps.length;
            completedSteps += stage.steps.filter(s => s.done).length;
        });
        
        const percentage = totalSteps > 0 ? (completedSteps / totalSteps * 100).toFixed(0) : 0;
        
        document.getElementById('progress-fill').style.width = `${percentage}%`;
        document.getElementById('progress-text').textContent = `${completedSteps} of ${totalSteps} steps completed (${percentage}%)`;
    }

    // Copy to clipboard function
    function copyToClipboard(text) {
        if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(text).then(() => {
                console.log('[SMAX Tool] Copied to clipboard');
                // Visual feedback could be added here
            }).catch(err => {
                console.error('[SMAX Tool] Failed to copy:', err);
                fallbackCopy(text);
            });
        } else {
            fallbackCopy(text);
        }
    }

    // Fallback copy method for older browsers
    function fallbackCopy(text) {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.select();
        try {
            // Note: execCommand is deprecated but kept as fallback for legacy browser support
            document.execCommand('copy');
            console.log('[SMAX Tool] Copied using fallback method');
        } catch (err) {
            console.error('[SMAX Tool] Fallback copy failed:', err);
            showError('Copy failed. Please copy manually.');
        }
        document.body.removeChild(textarea);
    }

    // Replace placeholders in commands with actual values
    // Replace placeholders in commands with actual values
    // Supports both {{variable}} and <variable> formats
    function interpolate(str) {
        if (!str) return '';
        let result = str;
        Object.keys(config.config || {}).forEach(key => {
            const val = config.config[key] || '';
            // Replace {{key}} format
            result = result.replace(new RegExp(`{{${key}}}`, 'g'), val);
            // Replace <key> format (case-insensitive)
            result = result.replace(new RegExp(`<${key}>`, 'gi'), val);
            // Also try uppercase version for <KEY> format
            const upperKey = key.toUpperCase();
            result = result.replace(new RegExp(`<${upperKey}>`, 'g'), val);
        });
        return result;
    }

    // Render steps with checkboxes, inline editing, and minimal notes UI
    function renderSteps(steps) {
        const stepsList = document.getElementById('steps-list');
        stepsList.innerHTML = '';
        
        if (!steps || steps.length === 0) {
            stepsList.innerHTML = '<p style="color:#586069;">No steps in this stage.</p>';
            document.getElementById('add-step-container').style.display = 'block';
            return;
        }
        
        document.getElementById('add-step-container').style.display = 'block';
        
        steps.forEach((step, stepIndex) => {
            const isDone = step.done || false;
            const card = document.createElement('div');
            card.className = `card ${isDone ? 'step-done' : ''}`;
            card.id = `step_${currentStageIndex}_${stepIndex}`;
            
            // Header with checkbox and title
            const header = document.createElement('div');
            header.style.display = 'flex';
            header.style.justifyContent = 'space-between';
            header.style.alignItems = 'center';
            header.style.marginBottom = '12px';
            
            const leftSection = document.createElement('div');
            leftSection.style.display = 'flex';
            leftSection.style.alignItems = 'center';
            leftSection.style.gap = '8px';
            leftSection.style.flex = '1';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `check_${currentStageIndex}_${stepIndex}`;
            checkbox.checked = isDone;
            checkbox.style.width = '18px';
            checkbox.style.height = '18px';
            checkbox.style.cursor = 'pointer';
            checkbox.onchange = function() {
                toggleStep(currentStageIndex, stepIndex, this.checked);
            };
            
            const title = document.createElement('strong');
            title.className = 'editable';
            title.style.fontSize = '16px';
            title.style.cursor = 'pointer';
            title.textContent = step.title || 'Untitled Step';
            
            leftSection.appendChild(checkbox);
            leftSection.appendChild(title);
            
            // Right section with notes button and edit buttons
            const rightSection = document.createElement('div');
            rightSection.style.display = 'flex';
            rightSection.style.gap = '6px';
            
            // Edit button
            const editBtn = document.createElement('button');
            editBtn.className = 'note-toggle-btn';
            editBtn.innerHTML = 'üìù Edit';
            editBtn.title = 'Edit step';
            editBtn.onclick = () => editStep(currentStageIndex, stepIndex);
            
            // Minimal notes button
            const notesBtn = document.createElement('button');
            notesBtn.className = `note-toggle-btn ${step.userNotes && Object.keys(step.userNotes).length > 0 ? 'has-notes' : ''}`;
            notesBtn.innerHTML = step.userNotes && Object.keys(step.userNotes).length > 0 ? 'üí¨ Notes' : 'üí¨';
            notesBtn.title = step.userNotes && Object.keys(step.userNotes).length > 0 ? 'View/Edit notes' : 'Add notes';
            notesBtn.onclick = () => toggleNoteEditor(currentStageIndex, stepIndex);
            
            rightSection.appendChild(editBtn);
            rightSection.appendChild(notesBtn);
            
            header.appendChild(leftSection);
            header.appendChild(rightSection);
            card.appendChild(header);
            
            // Add default notes if present (editable)
            if (step.notes) {
                const notesDiv = document.createElement('div');
                notesDiv.className = 'editable';
                notesDiv.style.color = 'white';
                notesDiv.style.margin = '8px 0';
                notesDiv.style.fontStyle = 'italic';
                notesDiv.style.cursor = 'pointer';
                notesDiv.textContent = step.notes;
                card.appendChild(notesDiv);
            }
            
            // Add command with copy and edit buttons
            if (step.command) {
                const interpolatedCommand = interpolate(step.command);
                const commandContainer = document.createElement('div');
                commandContainer.style.position = 'relative';
                commandContainer.style.marginTop = '12px';
                
                const pre = document.createElement('pre');
                pre.style.position = 'relative';
                
                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-btn';
                copyBtn.textContent = 'Copy';
                copyBtn.onclick = function(e) {
                    e.stopPropagation();
                    copyToClipboard(interpolatedCommand);
                };
                
                const commandText = document.createTextNode(interpolatedCommand);
                
                pre.appendChild(copyBtn);
                pre.appendChild(commandText);
                commandContainer.appendChild(pre);
                card.appendChild(commandContainer);
            }
            
            // Collapsible note section - shows preview by default
            const noteEditor = document.createElement('div');
            noteEditor.className = 'note-editor';
            noteEditor.id = `note-editor_${currentStageIndex}_${stepIndex}`;
            noteEditor.style.marginTop = '15px';
            noteEditor.style.borderTop = '1px solid var(--border)';
            noteEditor.style.paddingTop = '15px';
            
            // Container for content (preview or textarea)
            const noteContent = document.createElement('div');
            noteContent.id = `note-content_${currentStageIndex}_${stepIndex}`;
            
            // Live preview (shown by default)
            const notePreview = document.createElement('div');
            notePreview.className = 'note-preview';
            notePreview.id = `note-preview_${currentStageIndex}_${stepIndex}`;
            notePreview.style.marginBottom = '10px';
            if (step.userNotes && Object.keys(step.userNotes).length > 0) {
                // Render each version in its own block
                notePreview.innerHTML = '';
                for (const [version, content] of Object.entries(step.userNotes)) {
                    if (content && content.trim()) {
                        const versionBlock = document.createElement('div');
                        versionBlock.className = 'note-version-block';
                        versionBlock.style.border = '1px solid var(--border)';
                        versionBlock.style.borderRadius = '6px';
                        versionBlock.style.padding = '10px';
                        versionBlock.style.marginBottom = '8px';
                        versionBlock.style.backgroundColor = 'var(--bg)';
                        
                        const versionHeader = document.createElement('div');
                        versionHeader.style.fontWeight = 'bold';
                        versionHeader.style.marginBottom = '8px';
                        versionHeader.style.color = 'var(--primary)';
                        versionHeader.textContent = version === 'Current' ? 'üìù Current Notes' : `üìö ${version} Notes`;
                        
                        const versionContent = document.createElement('div');
                        versionContent.innerHTML = marked.parse(content);
                        
                        versionBlock.appendChild(versionHeader);
                        versionBlock.appendChild(versionContent);
                        notePreview.appendChild(versionBlock);
                    }
                }
            } else {
                notePreview.innerHTML = '<span style="color: #586069; font-style: italic;">No notes yet. Click Edit to add some.</span>';
            }
            
            // Textarea (hidden by default)
            const noteTextarea = document.createElement('textarea');
            noteTextarea.id = `note-textarea_${currentStageIndex}_${stepIndex}`;
            noteTextarea.disabled = false;
            noteTextarea.readOnly = false;
            noteTextarea.value = step.userNotes && Object.keys(step.userNotes).length > 0 ? userNotesToMarkdown(step.userNotes) : '';
            console.log('[SMAX Tool] Notes for step', stepIndex, 'userNotes:', step.userNotes);
            console.log('[SMAX Tool] Notes markdown:', noteTextarea.value);
            noteTextarea.placeholder = 'Enter notes in Markdown format...\n\nUse #### Notes to start the notes section\nUse ##### SubsectionName for subsections\n\nExample:\n#### Notes\n\n##### Current\n\nMy current notes here\n\n##### 24.4\n\nNotes from version 24.4\n\nYou can:\n- Paste images directly (Ctrl+V)\n- Drag and drop images\n- Use **bold**, *italic*, lists, etc.';
            noteTextarea.rows = 6;
            noteTextarea.style.marginBottom = '10px';
            noteTextarea.style.display = 'none';
            
            // Setup image paste/drop
            setupImagePaste(noteTextarea);
            
            // Update preview on input
            noteTextarea.oninput = () => {
                const preview = document.getElementById(`note-preview_${currentStageIndex}_${stepIndex}`);
                if (preview) {
                    if (noteTextarea.value) {
                        // Parse the current textarea content and show blocks
                        const parsedNotes = markdownToUserNotes(noteTextarea.value);
                        if (Object.keys(parsedNotes).length > 0) {
                            preview.innerHTML = '';
                            for (const [version, content] of Object.entries(parsedNotes)) {
                                if (content && content.trim()) {
                                    const versionBlock = document.createElement('div');
                                    versionBlock.className = 'note-version-block';
                                    versionBlock.style.border = '1px solid var(--border)';
                                    versionBlock.style.borderRadius = '6px';
                                    versionBlock.style.padding = '10px';
                                    versionBlock.style.marginBottom = '8px';
                                    versionBlock.style.backgroundColor = 'var(--bg)';
                                    
                                    const versionHeader = document.createElement('div');
                                    versionHeader.style.fontWeight = 'bold';
                                    versionHeader.style.marginBottom = '8px';
                                    versionHeader.style.color = 'var(--primary)';
                                    versionHeader.textContent = version === 'Current' ? 'üìù Current Notes' : `üìö ${version} Notes`;
                                    
                                    const versionContent = document.createElement('div');
                                    versionContent.innerHTML = marked.parse(content);
                                    
                                    versionBlock.appendChild(versionHeader);
                                    versionBlock.appendChild(versionContent);
                                    preview.appendChild(versionBlock);
                                }
                            }
                        } else {
                            preview.innerHTML = marked.parse(noteTextarea.value);
                        }
                    } else {
                        preview.innerHTML = '<span style="color: #586069; font-style: italic;">No notes yet. Click Edit to add some.</span>';
                    }
                }
            };
            
            noteContent.appendChild(notePreview);
            noteContent.appendChild(noteTextarea);
            
            const noteButtons = document.createElement('div');
            noteButtons.style.display = 'flex';
            noteButtons.style.gap = '10px';
            
            const editNoteBtn = document.createElement('button');
            editNoteBtn.textContent = '‚úèÔ∏è Edit';
            editNoteBtn.style.padding = '8px 16px';
            editNoteBtn.style.border = '1px solid var(--border)';
            editNoteBtn.style.borderRadius = '6px';
            editNoteBtn.style.cursor = 'pointer';
            editNoteBtn.style.background = 'var(--card-bg)';
            editNoteBtn.style.color = 'var(--text)';
            editNoteBtn.onclick = () => toggleNoteEdit(currentStageIndex, stepIndex);
            
            const saveNoteBtn = document.createElement('button');
            saveNoteBtn.textContent = 'üíæ Save Note';
            saveNoteBtn.style.background = 'var(--primary)';
            saveNoteBtn.style.color = 'white';
            saveNoteBtn.style.border = 'none';
            saveNoteBtn.style.padding = '8px 16px';
            saveNoteBtn.style.borderRadius = '6px';
            saveNoteBtn.style.cursor = 'pointer';
            saveNoteBtn.onclick = () => saveNote(currentStageIndex, stepIndex);
            
            const cancelNoteBtn = document.createElement('button');
            cancelNoteBtn.textContent = 'Cancel';
            cancelNoteBtn.style.padding = '8px 16px';
            cancelNoteBtn.style.border = '1px solid var(--border)';
            cancelNoteBtn.style.borderRadius = '6px';
            cancelNoteBtn.style.cursor = 'pointer';
            cancelNoteBtn.style.background = 'var(--card-bg)';
            cancelNoteBtn.style.color = 'var(--text)';
            cancelNoteBtn.onclick = () => toggleNoteEditor(currentStageIndex, stepIndex);
            
            noteButtons.appendChild(editNoteBtn);
            noteButtons.appendChild(saveNoteBtn);
            noteButtons.appendChild(cancelNoteBtn);
            
            noteEditor.appendChild(noteContent);
            noteEditor.appendChild(noteButtons);
            
            card.appendChild(noteEditor);
            stepsList.appendChild(card);
        });
    }
    
    // NEW: Toggle note editor
    function toggleNoteEditor(stageIndex, stepIndex) {
        const editor = document.getElementById(`note-editor_${stageIndex}_${stepIndex}`);
        if (editor) {
            editor.classList.toggle('active');
        }
    }
    
    function toggleNoteEdit(stageIndex, stepIndex) {
        const content = document.getElementById(`note-content_${stageIndex}_${stepIndex}`);
        const preview = document.getElementById(`note-preview_${stageIndex}_${stepIndex}`);
        const textarea = document.getElementById(`note-textarea_${stageIndex}_${stepIndex}`);
        
        if (content && preview && textarea) {
            const isEditing = content.classList.contains('editing');
            
            if (isEditing) {
                // Switch to preview mode
                content.classList.remove('editing');
                preview.style.display = 'block';
                textarea.style.display = 'none';
            } else {
                // Switch to edit mode
                content.classList.add('editing');
                preview.style.display = 'none';
                textarea.style.display = 'block';
                
                // Ensure textarea is interactive
                textarea.disabled = false;
                textarea.readOnly = false;
                textarea.style.pointerEvents = 'auto';
                
                // Focus with a small delay
                setTimeout(() => {
                    textarea.focus();
                    textarea.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 50);
            }
        }
    }
    
    // NEW: Save note
    function saveNote(stageIndex, stepIndex) {
        const textarea = document.getElementById(`note-textarea_${stageIndex}_${stepIndex}`);
        const preview = document.getElementById(`note-preview_${stageIndex}_${stepIndex}`);
        
        // Parse the markdown back into structured userNotes object
        config.stages[stageIndex].steps[stepIndex].userNotes = markdownToUserNotes(textarea.value);
        
        // Update preview and switch back to preview mode
        if (preview) {
            if (Object.keys(config.stages[stageIndex].steps[stepIndex].userNotes).length > 0) {
                // Render each version in its own block
                preview.innerHTML = '';
                for (const [version, content] of Object.entries(config.stages[stageIndex].steps[stepIndex].userNotes)) {
                    if (content && content.trim()) {
                        const versionBlock = document.createElement('div');
                        versionBlock.className = 'note-version-block';
                        versionBlock.style.border = '1px solid var(--border)';
                        versionBlock.style.borderRadius = '6px';
                        versionBlock.style.padding = '10px';
                        versionBlock.style.marginBottom = '8px';
                        versionBlock.style.backgroundColor = 'var(--bg)';
                        
                        const versionHeader = document.createElement('div');
                        versionHeader.style.fontWeight = 'bold';
                        versionHeader.style.marginBottom = '8px';
                        versionHeader.style.color = 'var(--primary)';
                        versionHeader.textContent = version === 'Current' ? 'üìù Current Notes' : `üìö ${version} Notes`;
                        
                        const versionContent = document.createElement('div');
                        versionContent.innerHTML = marked.parse(content);
                        
                        versionBlock.appendChild(versionHeader);
                        versionBlock.appendChild(versionContent);
                        preview.appendChild(versionBlock);
                    }
                }
            } else {
                preview.innerHTML = '<span style="color: #586069; font-style: italic;">No notes yet. Click Edit to add some.</span>';
            }
            preview.style.display = 'block';
        }
        
        // Switch back to preview mode
        const content = document.getElementById(`note-content_${stageIndex}_${stepIndex}`);
        if (content) {
            content.classList.remove('editing');
        }
        
        if (textarea) {
            textarea.style.display = 'none';
        }
        
        // Close editor and re-render to update button
        toggleNoteEditor(stageIndex, stepIndex);
        renderCurrentStage();
        
        console.log('[SMAX Tool] Note saved for step', stepIndex);
        triggerAutosave();
    }

    // Toggle step completion status
    function toggleStep(stageIndex, stepIndex, checked) {
        config.stages[stageIndex].steps[stepIndex].done = checked;
        const card = document.getElementById(`step_${stageIndex}_${stepIndex}`);
        if (card) {
            if (checked) {
                card.classList.add('step-done');
            } else {
                card.classList.remove('step-done');
            }
        }
        console.log(`[SMAX Tool] Step ${stepIndex} in stage ${stageIndex} marked as ${checked ? 'done' : 'pending'}`);
        
        // Update progress and stage tabs
        updateProgress();
        renderStageTabs();
        triggerAutosave();
    }
    
    // Toggle environment variables sidebar
    function toggleEnvVars() {
        const card = document.getElementById('env-vars-card');
        const btn = document.getElementById('envToggleBtn');
        card.classList.toggle('open');
        if (card.classList.contains('open')) {
            card.style.display = 'block';
            btn.textContent = '‚öôÔ∏è Hide Variables';
        } else {
            setTimeout(() => card.style.display = 'none', 300); // Hide after animation
            btn.textContent = '‚öôÔ∏è Variables';
        }
    }
    
    function closeEnvVars() {
        const card = document.getElementById('env-vars-card');
        const btn = document.getElementById('envToggleBtn');
        card.classList.remove('open');
        setTimeout(() => card.style.display = 'none', 300);
        btn.textContent = '‚öôÔ∏è Variables';
    }
    
    function editEnvVars() {
        const modal = document.getElementById('editEnvVarsModal');
        const textarea = document.getElementById('editEnvVarsContent');
        textarea.value = jsyaml.dump(config.config || {});
        modal.style.display = 'block';
    }
    
    function closeEditEnvVars() {
        document.getElementById('editEnvVarsModal').style.display = 'none';
    }
    
    function saveEditEnvVars() {
        const content = document.getElementById('editEnvVarsContent').value;
        try {
            const newConfig = jsyaml.load(content);
            config.config = newConfig;
            renderVars();
            triggerAutosave();
            closeEditEnvVars();
            showSuccess('Environment variables updated');
        } catch (e) {
            showError(`Invalid YAML: ${e.message}`);
        }
    }
    
    // Toggle client menu sidebar
    function toggleClientMenu() {
        const card = document.getElementById('client-menu-card');
        const btn = document.getElementById('menuToggleBtn');
        if (card.style.display === 'none' || card.style.display === '') {
            card.style.display = 'block';
            btn.textContent = 'üìÅ Hide Menu';
        } else {
            card.style.display = 'none';
            btn.textContent = 'üìÅ Menu';
        }
    }
    
    function closeClientMenu() {
        const card = document.getElementById('client-menu-card');
        const btn = document.getElementById('menuToggleBtn');
        card.classList.remove('open');
        setTimeout(() => card.style.display = 'none', 300);
        btn.textContent = 'üìÅ Menu';
    }
    
    // Render client menu
    function renderClientMenu() {
        const content = document.getElementById('client-menu-content');
        content.innerHTML = '';
        
        const currentVersion = document.getElementById('selVer').value;
        
        Object.keys(menuData).forEach(version => {
            const versionDiv = document.createElement('div');
            versionDiv.className = 'menu-item';
            versionDiv.textContent = `üìÅ ${version}`;
            versionDiv.onclick = () => toggleVersionMenu(version);
            
            const clientList = document.createElement('div');
            clientList.className = 'submenu';
            clientList.id = `submenu_${version}`;
            clientList.style.display = 'none'; // collapsed by default
            
            menuData[version].forEach(client => {
                const clientDiv = document.createElement('div');
                clientDiv.className = 'menu-item';
                clientDiv.textContent = `üìÑ ${client}`;
                clientDiv.onclick = () => selectClient(version, client);
                clientList.appendChild(clientDiv);
            });
            
            if (version === currentVersion) {
                clientList.style.display = 'block';
            }
            
            versionDiv.appendChild(clientList);
            content.appendChild(versionDiv);
        });
    }
    
    // Toggle version submenu
    async function toggleVersionMenu(version) {
        // If no clients loaded, fetch them
        if (menuData[version].length === 0) {
            await fetchClients(version);
        }
        
        // Accordion behavior: expand clicked, collapse others
        Object.keys(menuData).forEach(v => {
            const submenu = document.getElementById(`submenu_${v}`);
            if (submenu) {
                submenu.style.display = v === version ? 'block' : 'none';
            }
        });
    }
    
    // Select client from menu
    function selectClient(version, client) {
        document.getElementById('selVer').value = version;
        onVersionChange(); // to load clients
        setTimeout(() => {
            document.getElementById('selClient').value = client;
            loadData();
        }, 100); // small delay to ensure clients are loaded
    }
    
    // NEW: Reset modal functions
    function showResetModal() {
        document.getElementById('resetModal').style.display = 'block';
    }
    
    function closeResetModal() {
        document.getElementById('resetModal').style.display = 'none';
    }
    
    function confirmReset() {
        if (!config.stages) return;
        
        // Reset all steps
        config.stages.forEach(stage => {
            stage.steps.forEach(step => {
                step.done = false;
            });
        });
        
        // Re-render
        renderStageTabs();
        renderCurrentStage();
        updateProgress();
        closeResetModal();
        
        console.log('[SMAX Tool] All steps reset');
        showSuccess('All steps have been reset');
    }

    // Show success message (non-blocking)
    function showSuccess(msg) {
        const box = document.getElementById('errorBox');
        box.innerText = `‚úÖ ${msg}`;
        box.style.display = 'block';
        box.style.background = '#d4edda';
        box.style.color = '#155724';
        box.style.borderColor = '#c3e6cb';
        
        // Auto-hide after 3 seconds
        setTimeout(() => {
            box.style.display = 'none';
            box.style.background = '#ffeef0';
            box.style.color = '#d73a49';
            box.style.borderColor = '#f97583';
        }, 3000);
    }

    // Convert config to markdown format with new structure
    // # = Document title
    // ## = Stages
    // ### = Steps
    function convertToMarkdown() {
        let md = '---\n';
        md += jsyaml.dump({ config: config.config });
        md += '---\n\n';
        
        // Add document title
        if (config.title) {
            md += `# ${config.title}\n\n`;
        }
        
        config.stages.forEach(stage => {
            md += `## ${stage.name}\n\n`;
            
            stage.steps.forEach(step => {
                md += `### ${step.title}\n\n`;
                
                if (step.notes) {
                    md += `${step.notes}\n\n`;
                }
                
                if (step.command) {
                    md += '```bash\n';
                    md += step.command + '\n';
                    md += '```\n\n';
                }
                
                if (step.userNotes && Object.keys(step.userNotes).length > 0) {
                    md += userNotesToMarkdown(step.userNotes) + '\n\n';
                }
                
                // Completion marker as separate section
                md += step.done ? '### - [x] Complete\n\n' : '### - [ ] Complete\n\n';
                
            });
        });
        
        return md;
    }
    
    // Save data function to push markdown back to GitHub
    async function saveData() {
        if (!GITHUB_TOKEN) {
            showError('GitHub token required. Please enter token and connect.');
            return;
        }
        
        if (!CURRENT_YAML_PATH) {
            showError('No file path selected. Please load data first.');
            return;
        }
        
        try {
            // Always save as markdown
            const fileContent = convertToMarkdown();
            const encodedContent = btoa(unescape(encodeURIComponent(fileContent)));
            
            // Update file on GitHub
            const updatePayload = {
                message: `Update ${document.getElementById('selClient').value} configuration`,
                content: encodedContent
            };
            
            // Only include SHA if file exists (for updates)
            if (FILE_SHA) {
                updatePayload.sha = FILE_SHA;
            }
            
            console.log('[SMAX Tool] Saving to GitHub:', CURRENT_YAML_PATH);
            
            const response = await fetch(
                `https://api.github.com/repos/${OWNER}/${REPO}/contents/${CURRENT_YAML_PATH}`,
                {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${GITHUB_TOKEN}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updatePayload)
                }
            );
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`GitHub API error: ${errorData.message || response.statusText}`);
            }
            
            const result = await response.json();
            FILE_SHA = result.content.sha; // Update SHA for next save
            
            document.getElementById('syncInd').classList.add('online');
            document.getElementById('syncStat').innerText = `Synced: ${document.getElementById('selVer').value}/${document.getElementById('selClient').value}`;
            
            console.log('[SMAX Tool] Data saved successfully, SHA:', result.content.sha);
            clearTimeout(autosaveTimeout);
        } catch (e) {
            console.error('[SMAX Tool] saveData error:', e);
            showError(`Failed to save data: ${e.message}`);
        }
        
        // Set new timeout (debounced save after 3 seconds)
        autosaveTimeout = setTimeout(async () => {
            const status = document.getElementById('autosave-status');
            status.textContent = 'Saving...';
            await saveData();
            status.textContent = 'Autosaved';
            setTimeout(() => {
                status.textContent = 'Autosave enabled';
            }, 2000);
        }, 3000);
    }
    
    // Dark mode toggle
    function toggleDarkMode() {
        document.body.classList.toggle('dark-mode');
        const icon = document.getElementById('theme-icon');
        if (document.body.classList.contains('dark-mode')) {
            icon.textContent = '‚òÄÔ∏è';
            localStorage.setItem('darkMode', 'true');
        } else {
            icon.textContent = 'üåô';
            localStorage.setItem('darkMode', 'false');
        }
    }
    
    // Initialize dark mode from localStorage
    if (localStorage.getItem('darkMode') === 'true') {
        document.body.classList.add('dark-mode');
        document.getElementById('theme-icon').textContent = '‚òÄÔ∏è';
    }
    
    // Render document title
    function renderTitle() {
        const titleContainer = document.getElementById('doc-title-container');
        const titleElement = document.getElementById('doc-title');
        if (config.title) {
            titleContainer.style.display = 'block';
            titleElement.textContent = config.title;
        } else {
            titleContainer.style.display = 'none';
        }
    }
    
    // Edit title inline
    function editTitle() {
        const titleElement = document.getElementById('doc-title');
        const currentTitle = config.title || '';
        
        const input = document.createElement('input');
        input.type = 'text';
        input.value = currentTitle;
        input.style.width = '100%';
        input.style.fontSize = '1.5em';
        input.style.fontWeight = 'bold';
        input.style.padding = '4px';
        input.style.border = '1px solid var(--primary)';
        input.style.borderRadius = '4px';
        input.style.background = 'var(--card-bg)';
        input.style.color = 'var(--text)';
        
        titleElement.replaceWith(input);
        input.focus();
        input.select();
        
        const saveTitle = () => {
            const newTitle = input.value.trim();
            config.title = newTitle;
            const newTitleElement = document.createElement('h2');
            newTitleElement.id = 'doc-title';
            newTitleElement.className = 'editable';
            newTitleElement.onclick = editTitle;
            newTitleElement.style.margin = '0';
            newTitleElement.style.cursor = 'pointer';
            newTitleElement.textContent = newTitle || 'Document Title';
            input.replaceWith(newTitleElement);
            triggerAutosave();
        };
        
        input.onblur = saveTitle;
        input.onkeypress = (e) => {
            if (e.key === 'Enter') {
                saveTitle();
            }
        };
    }
    
    // Edit stage name inline
    function editStageName(stageIndex) {
        const stage = config.stages[stageIndex];
        const newName = prompt('Edit stage name:', stage.name);
        if (newName && newName.trim()) {
            stage.name = newName.trim();
            renderStageTabs();
            renderCurrentStage();
            triggerAutosave();
        }
    }
    
    // Edit step
    function editStep(stageIndex, stepIndex) {
        editingStageIndex = stageIndex;
        editingStepIndex = stepIndex;
        const step = config.stages[stageIndex].steps[stepIndex];
        const mdStr = stepToMarkdown(step);
        const textarea = document.getElementById('editStepContent');
        textarea.value = mdStr;
        textarea.addEventListener('keydown', handleMarkdownShortcuts);
        document.getElementById('editStepModal').style.display = 'block';
    }
    
    function closeEditStep() {
        document.getElementById('editStepModal').style.display = 'none';
    }
    
    function saveEditStep() {
        const mdStr = document.getElementById('editStepContent').value;
        try {
            const newStep = markdownToStep(mdStr);
            newStep.rawMd = mdStr; // Preserve the exact edited Markdown
            config.stages[editingStageIndex].steps[editingStepIndex] = newStep;
            renderCurrentStage();
            triggerAutosave();
            closeEditStep();
        } catch (e) {
            showError('Invalid Markdown: ' + e.message);
        }
    }
    
    // Convert step object to Markdown string
    function stepToMarkdown(step) {
        if (step.rawMd) {
            return step.rawMd;
        }
        // Fallback to reconstructed
        let md = `### ${step.title || 'Untitled'}\n\n`;
        md += step.done ? '- [x]\n\n' : '- [ ]\n\n';
        if (step.notes) {
            md += `${step.notes}\n\n`;
        }
        if (step.command) {
            md += `\`\`\`\n${step.command}\n\`\`\`\n\n`;
        }
        if (step.userNotes && Object.keys(step.userNotes).length > 0) {
            md += `#### Notes\n\n`;
            // Put Current notes first (without ##### header)
            if (step.userNotes['Current']) {
                md += `${step.userNotes['Current']}\n\n`;
            }
            // Then add version-specific notes with ##### headers
            for (const [subsection, content] of Object.entries(step.userNotes)) {
                if (subsection !== 'Current' && content.trim()) {
                    md += `##### ${subsection}\n\n${content}\n\n`;
                }
            }
        }
        return md.trim();
    }
    
    // Helper function to convert userNotes object to markdown string
    function userNotesToMarkdown(userNotes) {
        if (!userNotes || Object.keys(userNotes).length === 0) return '';
        
        let md = '#### Notes\n\n';
        // Put Current notes directly under #### Notes (no ##### header)
        if (userNotes['Current']) {
            md += `${userNotes['Current']}\n\n`;
        }
        // Add version-specific notes with ##### headers in the order they appear in the object (preserves file order)
        for (const [subsection, content] of Object.entries(userNotes)) {
            if (subsection !== 'Current' && content && content.trim()) {
                md += `##### ${subsection}\n\n${content}\n\n`;
            }
        }
        return md.trim();
    }
    
    // Helper function to convert markdown string to userNotes object
    function markdownToUserNotes(md) {
        if (!md) return {};
        
        const lines = md.split('\n');
        const userNotes = {};
        let currentSubsection = '';
        let subsectionBuffer = [];
        let inNotesSection = false;
        let collectingCurrent = false;
        
        for (const line of lines) {
            if (line.startsWith('#### ')) {
                inNotesSection = true;
                collectingCurrent = true; // Start collecting current notes
                continue;
            }
            if (!inNotesSection) continue;
            
            if (line.startsWith('##### ')) {
                // Save current notes as Current if we were collecting them
                if (collectingCurrent && subsectionBuffer.length > 0) {
                    userNotes['Current'] = subsectionBuffer.join('\n').trim();
                    subsectionBuffer = [];
                    collectingCurrent = false;
                }
                // Save previous subsection if any
                if (currentSubsection && subsectionBuffer.length > 0) {
                    userNotes[currentSubsection] = subsectionBuffer.join('\n').trim();
                }
                // Start new version-specific subsection
                currentSubsection = line.substring(6).trim();
                subsectionBuffer = [];
            } else if (line.trim() !== '') {
                subsectionBuffer.push(line);
            }
        }
        
        // Save final content
        if (collectingCurrent && subsectionBuffer.length > 0) {
            userNotes['Current'] = subsectionBuffer.join('\n').trim();
        } else if (currentSubsection && subsectionBuffer.length > 0) {
            userNotes[currentSubsection] = subsectionBuffer.join('\n').trim();
        }
        
        return userNotes;
    }
    
    // Convert Markdown string back to step object
    function markdownToStep(md) {
        const lines = md.split('\n');
        const step = { done: false, notes: '', command: '', userNotes: {} };
        let inCodeBlock = false;
        let codeBuffer = [];
        let notesBuffer = [];
        let collectingNotes = false;
        let currentSubsection = '';
        let subsectionBuffer = [];
        let collectingCurrent = false;
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            if (line.startsWith('### ')) {
                step.title = line.substring(4).trim();
                step.id = step.title.toLowerCase().replace(/[^a-z0-9]+/g, '_');
            } else if (line.trim() === '- [x]' || line.trim() === '- [X]') {
                step.done = true;
            } else if (line.trim() === '- [ ]') {
                step.done = false;
            } else if (line.trim() === '```') {
                if (inCodeBlock) {
                    step.command = codeBuffer.join('\n').trim();
                    inCodeBlock = false;
                    codeBuffer = [];
                } else {
                    inCodeBlock = true;
                }
            } else if (inCodeBlock) {
                codeBuffer.push(line);
            } else if (line.startsWith('#### ')) {
                const sectionTitle = line.substring(5).trim();
                if (sectionTitle.toLowerCase().includes('notes') || sectionTitle.toLowerCase().includes('note')) {
                    collectingNotes = true;
                    currentSubsection = '';
                    subsectionBuffer = [];
                    collectingCurrent = true; // Start with Current notes
                }
            } else if (collectingNotes && line.startsWith('##### ')) {
                // Save current notes as Current if we were collecting them
                if (collectingCurrent && subsectionBuffer.length > 0) {
                    step.userNotes['Current'] = subsectionBuffer.join('\n').trim();
                    subsectionBuffer = [];
                    collectingCurrent = false;
                }
                // Save previous subsection if any
                if (currentSubsection && subsectionBuffer.length > 0) {
                    step.userNotes[currentSubsection] = subsectionBuffer.join('\n').trim();
                }
                // Start new version-specific subsection
                currentSubsection = line.substring(6).trim();
                subsectionBuffer = [];
            } else if (collectingNotes) {
                if (line.trim() !== '') {
                    subsectionBuffer.push(line);
                }
            } else if (line.trim() !== '') {
                if (step.notes) {
                    step.notes += '\n' + line.trim();
                } else {
                    step.notes = line.trim();
                }
            }
        }
        
        // Save final content
        if (collectingCurrent && subsectionBuffer.length > 0) {
            step.userNotes['Current'] = subsectionBuffer.join('\n').trim();
        } else if (currentSubsection && subsectionBuffer.length > 0) {
            step.userNotes[currentSubsection] = subsectionBuffer.join('\n').trim();
        }
        
        return step;
    }
    
    // Handle Markdown keyboard shortcuts
    function handleMarkdownShortcuts(e) {
        if (e.ctrlKey) {
            switch (e.key) {
                case 'b':
                    e.preventDefault();
                    insertMarkdown('**', '**');
                    break;
                case 'i':
                    e.preventDefault();
                    insertMarkdown('*', '*');
                    break;
                case '`':
                    e.preventDefault();
                    insertMarkdown('`', '`');
                    break;
            }
        }
    }
    
    // Insert Markdown formatting around selection
    function insertMarkdown(before, after) {
        const textarea = document.getElementById('editStepContent');
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const selected = textarea.value.substring(start, end);
        const replacement = before + selected + after;
        textarea.value = textarea.value.substring(0, start) + replacement + textarea.value.substring(end);
        textarea.selectionStart = textarea.selectionEnd = start + replacement.length;
        textarea.focus();
    }
    
    // Add new stage
    function addNewStage() {
        const stageName = prompt('Enter new stage name:');
        if (stageName && stageName.trim()) {
            config.stages.push({
                name: stageName.trim(),
                steps: []
            });
            currentStageIndex = config.stages.length - 1;
            renderStageTabs();
            renderCurrentStage();
            updateProgress();
            triggerAutosave();
        }
    }
    
    // Add new step to current stage
    function addNewStep() {
        if (currentStageIndex < 0 || currentStageIndex >= config.stages.length) {
            showError('No stage selected');
            return;
        }
        
        const stepTitle = prompt('Enter new step title:');
        if (stepTitle && stepTitle.trim()) {
            config.stages[currentStageIndex].steps.push({
                id: stepTitle.toLowerCase().replace(/[^a-z0-9]+/g, '_'),
                title: stepTitle.trim(),
                notes: '',
                command: '',
                done: false,
                userNotes: ''
            });
            renderCurrentStage();
            updateProgress();
            triggerAutosave();
        }
    }
    
    // Raw editor functions
    function showRawEditor() {
        const modal = document.getElementById('rawEditorModal');
        const textarea = document.getElementById('rawEditorContent');
        textarea.value = convertToMarkdown();
        modal.style.display = 'block';
    }
    
    function closeRawEditor() {
        document.getElementById('rawEditorModal').style.display = 'none';
    }
    
    function saveRawEditor() {
        const content = document.getElementById('rawEditorContent').value;
        try {
            // Parse the markdown content
            const { config: configData, markdown } = parseMarkdownFrontMatter(content);
            const { title, stages } = parseMarkdownStages(markdown);
            
            config = {
                title: title,
                config: configData,
                stages: stages
            };
            
            // Re-render everything
            renderTitle();
            renderVars();
            renderStageTabs();
            renderCurrentStage();
            updateProgress();
            
            closeRawEditor();
            triggerAutosave();
            showSuccess('Changes applied from raw editor');
        } catch (e) {
            showError(`Failed to parse markdown: ${e.message}`);
        }
    }
    
    // Version upgrade functions
    function showVersionUpgrade() {
        const modal = document.getElementById('versionUpgradeModal');
        const select = document.getElementById('targetVersionSelect');
        
        // Populate version options
        const currentVer = document.getElementById('selVer').value;
        const verSelect = document.getElementById('selVer');
        select.innerHTML = '<option value="">Select version...</option>';
        
        Array.from(verSelect.options).forEach(opt => {
            if (opt.value !== currentVer) {
                const newOpt = document.createElement('option');
                newOpt.value = opt.value;
                newOpt.textContent = opt.textContent;
                select.appendChild(newOpt);
            }
        });
        
        // Add option to create new version
        const newVerOpt = document.createElement('option');
        newVerOpt.value = '__new__';
        newVerOpt.textContent = '‚ûï Create New Version...';
        select.appendChild(newVerOpt);
        
        modal.style.display = 'block';
    }
    
    function closeVersionUpgrade() {
        document.getElementById('versionUpgradeModal').style.display = 'none';
        // Reset new version input
        document.getElementById('newVersionDiv').style.display = 'none';
        document.getElementById('newVersionInput').value = '';
    }
    
    function onTargetVersionChange() {
        const select = document.getElementById('targetVersionSelect');
        const newVersionDiv = document.getElementById('newVersionDiv');
        
        if (select.value === '__new__') {
            newVersionDiv.style.display = 'block';
        } else {
            newVersionDiv.style.display = 'none';
            document.getElementById('newVersionInput').value = '';
        }
    }
    
    async function confirmVersionUpgrade() {
        const select = document.getElementById('targetVersionSelect');
        let targetVersion = select.value;
        
        if (!targetVersion) {
            showError('Please select a target version');
            return;
        }
        
        // Handle new version creation
        if (targetVersion === '__new__') {
            const newVersionInput = document.getElementById('newVersionInput');
            targetVersion = newVersionInput.value.trim();
            
            if (!targetVersion) {
                showError('Please enter a version number');
                return;
            }
            
            // Validate version format (should contain numbers and dots)
            if (!/^\d+(\.\d+)*$/.test(targetVersion)) {
                showError('Version should contain only numbers and dots (e.g., 24.6)');
                return;
            }
        }
        
        const currentClient = document.getElementById('selClient').value;
        const currentVersion = document.getElementById('selVer').value;
        
        try {
            // Archive current notes under #### history in each step
            config.stages.forEach(stage => {
                stage.steps.forEach(step => {
                    if (step.userNotes && step.userNotes['Current']) {
                        const currentVersion = document.getElementById('selVer').value;
                        
                        // Move current notes to the previous version's archive
                        step.userNotes[currentVersion] = step.userNotes['Current'];
                        
                        // Clear current notes for fresh start in new version
                        step.userNotes['Current'] = '';
                    }
                    // Reset done status
                    step.done = false;
                });
            });
            
            // Update title
            config.title = config.title.replace(currentVersion, targetVersion);
            
            // Update version in config
            if (config.config.version) {
                config.config.version = targetVersion;
            }
            
            // Save to new version folder
            const basePath = getVersionsBasePath();
            const newPath = `${basePath}/${targetVersion}/${currentClient}.md`;
            const oldPath = CURRENT_YAML_PATH;
            CURRENT_YAML_PATH = newPath;
            FILE_SHA = ""; // New file
            
            await saveData();
            
            // Update UI to show new version
            document.getElementById('selVer').value = targetVersion;
            
            console.log(`[SMAX Tool] Upgraded from ${currentVersion} to ${targetVersion}`);
            showSuccess(`Successfully upgraded to version ${targetVersion}`);
            
            closeVersionUpgrade();
            
            // Refresh the version list to include the new version
            await fetchFolders();
            
            // Ensure the new version is selected
            document.getElementById('selVer').value = targetVersion;
            
            // Fetch clients for the new version
            await fetchClients(targetVersion);
            
            // Ensure the client is selected
            document.getElementById('selClient').value = currentClient;
            
            // Load the data for the new version
            await loadData();
            
        } catch (e) {
            console.error('[SMAX Tool] Version upgrade error:', e);
            showError(`Version upgrade failed: ${e.message}`);
        }
    }
    
    // Image upload to notes via GitHub API
    async function uploadImageToGitHub(file, noteTextarea) {
        if (!GITHUB_TOKEN) {
            showError('GitHub token required for image upload');
            return;
        }

        try {
            // Read file as base64
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const base64Content = e.target.result.split(',')[1];
                    const fileName = `images/${Date.now()}-${file.name.replace(/[^a-zA-Z0-9.-]/g, '_')}`;
                    const ver = document.getElementById('selVer').value;
                    const basePath = getVersionsBasePath();
                    const imagePath = `${basePath}/${ver}/${fileName}`;

                    console.log(`[SMAX Tool] Uploading image to: ${imagePath}`);

                    // Upload to GitHub
                    const response = await fetch(
                        `https://api.github.com/repos/${OWNER}/${REPO}/contents/${imagePath}`,
                        {
                            method: 'PUT',
                            headers: {
                                'Authorization': `token ${GITHUB_TOKEN}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                message: `Upload image ${file.name}`,
                                content: base64Content
                            })
                        }
                    );

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`GitHub API error: ${errorData.message || response.statusText}`);
                    }

                    const result = await response.json();
                    const imageUrl = result.content.download_url;

                    console.log(`[SMAX Tool] Image uploaded successfully: ${imageUrl}`);

                    // Insert markdown image link at cursor
                    const markdownLink = `\n![${file.name}](${imageUrl})\n`;
                    const cursorPos = noteTextarea.selectionStart;
                    const textBefore = noteTextarea.value.substring(0, cursorPos);
                    const textAfter = noteTextarea.value.substring(cursorPos);
                    noteTextarea.value = textBefore + markdownLink + textAfter;

                    // Trigger preview update
                    noteTextarea.dispatchEvent(new Event('input'));

                    showSuccess('Image uploaded successfully');
                } catch (innerError) {
                    console.error('[SMAX Tool] Image upload error:', innerError);
                    showError(`Image upload failed: ${innerError.message}`);
                }
            };

            reader.onerror = () => {
                showError('Failed to read image file');
            };

            reader.readAsDataURL(file);
        } catch (e) {
            console.error('[SMAX Tool] Image upload setup error:', e);
            showError(`Image upload failed: ${e.message}`);
        }
    }
    
    // Handle paste events for image upload
    function setupImagePaste(textarea) {
        textarea.addEventListener('paste', async (e) => {
            const items = e.clipboardData.items;
            for (let item of items) {
                if (item.type.indexOf('image') !== -1) {
                    e.preventDefault();
                    const file = item.getAsFile();
                    await uploadImageToGitHub(file, textarea);
                    break;
                }
            }
        });
        
        // Drag and drop support
        textarea.addEventListener('dragover', (e) => {
            e.preventDefault();
            textarea.classList.add('dragging');
        });
        
        textarea.addEventListener('dragleave', () => {
            textarea.classList.remove('dragging');
        });
        
        textarea.addEventListener('drop', async (e) => {
            e.preventDefault();
            textarea.classList.remove('dragging');
            
            const files = e.dataTransfer.files;
            for (let file of files) {
                if (file.type.indexOf('image') !== -1) {
                    await uploadImageToGitHub(file, textarea);
                    break;
                }
            }
        });
    }

    // Helper function to process markdown content with images for PDF
    async function processMarkdownForPDF(pdf, content, x, y, maxWidth, colors) {
        try {
            if (!content) return y;

            // Split content by image markdown syntax ![alt](url)
            const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
            let lastIndex = 0;
            let currentY = y;
            let match;

            while ((match = imageRegex.exec(content)) !== null) {
                // Process text before image
                const textBefore = content.substring(lastIndex, match.index);
                if (textBefore.trim()) {
                    const textLines = pdf.splitTextToSize(textBefore, maxWidth);
                    pdf.text(textLines, x, currentY);
                    currentY += textLines.length * 7; // lineHeight
                }

                // Process image
                const altText = match[1];
                const imageUrl = match[2];

                try {
                    // Load image with timeout and error handling
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout

                    const response = await fetch(imageUrl, {
                        signal: controller.signal,
                        mode: 'cors'
                    });
                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const blob = await response.blob();
                    const arrayBuffer = await blob.arrayBuffer();
                    const uint8Array = new Uint8Array(arrayBuffer);

                    // Determine image format
                    let format = 'JPEG';
                    if (imageUrl.toLowerCase().includes('.png')) {
                        format = 'PNG';
                    } else if (imageUrl.toLowerCase().includes('.gif')) {
                        format = 'GIF';
                    }

                    // Add image to PDF
                    const imgWidth = Math.min(maxWidth, 100); // Max width of 100mm
                    const imgHeight = 60; // Fixed height, could be calculated based on aspect ratio

                    pdf.addImage(uint8Array, format, x, currentY, imgWidth, imgHeight);
                    currentY += imgHeight + 5; // Add some padding after image

                    // Add alt text as caption if provided
                    if (altText && altText.trim()) {
                        pdf.setFontSize(9);
                        pdf.setTextColor(...colors.secondaryText);
                        pdf.text(altText, x, currentY);
                        currentY += 7;
                        pdf.setFontSize(11);
                        pdf.setTextColor(...colors.text);
                    }

                } catch (error) {
                    console.warn(`[SMAX Tool] Failed to load image ${imageUrl}:`, error);
                    // Add placeholder text for failed image
                    pdf.setTextColor(...colors.incomplete);
                    pdf.text(`[Image failed to load: ${altText || imageUrl}]`, x, currentY);
                    currentY += 7;
                    pdf.setTextColor(...colors.text);
                }

                lastIndex = imageRegex.lastIndex;
            }

            // Process remaining text after last image
            const remainingText = content.substring(lastIndex);
            if (remainingText.trim()) {
                const textLines = pdf.splitTextToSize(remainingText, maxWidth);
                pdf.text(textLines, x, currentY);
                currentY += textLines.length * 7;
            }

            return currentY;
        } catch (error) {
            console.error('[SMAX Tool] Error in processMarkdownForPDF:', error);
            // Fallback: return original y position
            return y;
        }
    }

    // PDF Export Functionality (Dark Grey Theme)
    async function exportToPDF() {
        if (!config || !config.title) {
            showError('No data loaded. Please load a client first.');
            return;
        }

        try {
            console.log('Global jsPDF:', typeof jsPDF, jsPDF);
            console.log('window.jsPDF:', typeof window.jsPDF, window.jsPDF);
            
            let pdf;
            if (typeof window.jsPDF === 'function') {
                pdf = new window.jsPDF('p', 'mm', 'a4');
                // Ensure proper text encoding
                pdf.setProperties({
                    title: config.title,
                    subject: 'Multi-Tenant Operations Guide',
                    author: 'SMAX Upgrade Tool',
                    keywords: 'SMAX, upgrade, operations',
                    creator: 'SMAX Upgrade Tool'
                });
            } else {
                throw new Error('jsPDF library not found');
            }
            
            // PDF settings
            const pageWidth = pdf.internal.pageSize.width;
            const pageHeight = pdf.internal.pageSize.height;
            const margin = 20;
            let yPosition = margin;
            const lineHeight = 7;
            
            // Dark theme colors (grey theme)
            const colors = {
                background: [32, 33, 36],        // #202124 - dark grey background
                text: [241, 243, 244],           // #f1f3f4 - light grey text
                secondaryText: [154, 160, 166],  // #9aa0a6 - medium grey
                headerBg: [63, 81, 181],         // #3f51b5 - blue for branding
                headerText: [255, 255, 255],     // White
                codeBg: [48, 54, 61],            // #30363d - dark grey for code
                codeBorder: [95, 99, 104],       // #5f6368 - medium grey
                border: [95, 99, 104],           // #5f6368
                complete: [76, 175, 80],         // Keep green for complete
                incomplete: [244, 67, 54],       // Keep red for incomplete
                notes: [33, 150, 243],           // #2196f3 - blue for notes
                footerBg: [48, 54, 61],          // #30363d - dark footer
                footerText: [154, 160, 166]      // #9aa0a6 - medium gray footer
            };
            
            // Set page background to dark
            pdf.setFillColor(...colors.background);
            pdf.rect(0, 0, pageWidth, pageHeight, 'F');
            
            // Add header with gradient background (blue theme)
            pdf.setFillColor(...colors.headerBg);
            pdf.rect(0, 0, pageWidth, 25, 'F');
            pdf.setFillColor(92, 107, 192); // Lighter blue
            pdf.rect(0, 20, pageWidth, 5, 'F');
            
            // Title with white text on gradient
            pdf.setFontSize(24);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor(...colors.headerText);
            pdf.text(config.title, margin, yPosition + 5);
            
            // Add date below title
            pdf.setFontSize(12);
            pdf.setFont('helvetica', 'normal');
            pdf.setTextColor(...colors.secondaryText);
            const currentDate = new Date().toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
            pdf.text(`Generated: ${currentDate}`, margin, yPosition + 10);
            
            yPosition = 60; // Start TOC lower on the page
            
            // Add table of contents
            pdf.setFontSize(16);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor(...colors.headerBg);
            pdf.text('Table of Contents', margin, yPosition);
            yPosition += lineHeight * 1.8;

            pdf.setFontSize(12);
            pdf.setFont('helvetica', 'normal');
            pdf.setTextColor(...colors.text);

            config.stages.forEach((stage, stageIndex) => {
                // Stage title
                const stageTocText = `${stageIndex + 1}. ${stage.name}`;
                pdf.setFont('helvetica', 'bold');
                pdf.setTextColor(...colors.headerBg);
                pdf.text(stageTocText, margin + 10, yPosition);
                yPosition += lineHeight * 1.2;

                // Steps within this stage
                pdf.setFont('helvetica', 'normal');
                pdf.setTextColor(...colors.secondaryText);
                stage.steps.forEach((step, stepIndex) => {
                    const stepTocText = `${stageIndex + 1}.${stepIndex + 1} ${step.title}`;
                    pdf.text(stepTocText, margin + 20, yPosition);
                    yPosition += lineHeight * 0.9;
                });

                yPosition += lineHeight * 0.5; // Small space between stages in TOC
            });

            yPosition += lineHeight * 1.5; // Space after TOC
            
            // Add all stages
            for (const [stageIndex, stage] of config.stages.entries()) {
                // Each stage ALWAYS starts on a new page
                pdf.addPage();
                // Set dark grey background for new page
                pdf.setFillColor(...colors.background);
                pdf.rect(0, 0, pageWidth, pageHeight, 'F');
                yPosition = margin;
                
                // Stage header with enhanced styling
                pdf.setFillColor(...colors.headerBg);
                pdf.rect(margin - 5, yPosition - 8, pageWidth - margin * 2 + 10, 16, 'F');

                // White text on green background
                pdf.setFontSize(18);
                pdf.setFont('helvetica', 'bold');
                pdf.setTextColor(...colors.headerText);
                pdf.text(`${stageIndex + 1}. ${stage.name}`, margin, yPosition);
                yPosition += lineHeight * 2.8;

                pdf.setFontSize(11);
                pdf.setFont('helvetica', 'normal');
                pdf.setTextColor(...colors.text);
                
                for (const [index, step] of stage.steps.entries()) {
                    // Check if we need a new page (more conservative check)
                    if (yPosition > pageHeight - margin * 6) {
                        pdf.addPage();
                        // Set dark grey background for new page
                        pdf.setFillColor(...colors.background);
                        pdf.rect(0, 0, pageWidth, pageHeight, 'F');

                        // Repeat header on new page
                        pdf.setFillColor(...colors.headerBg);
                        pdf.rect(0, 0, pageWidth, 20, 'F');
                        pdf.setFontSize(14);
                        pdf.setFont('helvetica', 'bold');
                        pdf.setTextColor(...colors.headerText);
                        pdf.text(`${config.title} - ${stage.name} (continued)`, margin, 12);
                        yPosition = 30;
                        pdf.setFontSize(11);
                        pdf.setFont('helvetica', 'normal');
                        pdf.setTextColor(...colors.text);
                    }
                    
                    // Step title with icon
                    pdf.setFont('helvetica', 'bold');
                    pdf.setTextColor(...colors.text);
                    const stepTitle = `${index + 1}. ${step.title}`;
                    const titleLines = pdf.splitTextToSize(stepTitle, pageWidth - margin * 2 - 20);
                    pdf.text(titleLines, margin + 10, yPosition);
                    const titleHeight = titleLines.length * lineHeight;
                    yPosition += titleHeight;

                    // Step content with better formatting (now supports images)
                    if (step.notes) {
                        yPosition += lineHeight * 0.8;
                        yPosition = await processMarkdownForPDF(pdf, step.notes, margin + 10, yPosition, pageWidth - margin * 2 - 20, colors);
                    }

                    // Commands with improved code block styling
                    if (step.command) {
                        yPosition += lineHeight * 0.8;
                        const interpolatedCommand = interpolate(step.command);

                        // Calculate exact height needed for command
                        const commandLines = pdf.splitTextToSize(interpolatedCommand, pageWidth - margin * 2 - 30);
                        const codeBlockHeight = Math.max(15, commandLines.length * 5 + 8);

                        // Code block background (dark)
                        pdf.setFillColor(...colors.codeBg);
                        pdf.setDrawColor(...colors.codeBorder);
                        pdf.setLineWidth(0.3);
                        pdf.rect(margin + 8, yPosition - 2, pageWidth - margin * 2 - 16, codeBlockHeight, 'FD');

                        pdf.setFont('courier', 'normal');
                        pdf.setFontSize(9);
                        pdf.setTextColor(...colors.secondaryText);
                        pdf.text('Command:', margin + 12, yPosition + 2);

                        pdf.setTextColor(...colors.text);
                        pdf.text(commandLines, margin + 15, yPosition + 8);

                        yPosition += codeBlockHeight + 2;
                        pdf.setFontSize(11);
                        pdf.setFont('helvetica', 'normal');
                        pdf.setTextColor(...colors.text);
                    }

                    // Notes with enhanced styling
                    if (step.userNotes && Object.keys(step.userNotes).length > 0) {
                        yPosition += lineHeight * 0.8;
                        pdf.setFont('helvetica', 'bold');
                        pdf.setTextColor(...colors.notes);
                        pdf.text('Notes:', margin + 10, yPosition);
                        yPosition += lineHeight;

                        pdf.setFont('helvetica', 'normal');
                        pdf.setTextColor(...colors.text);
                        for (const [key, content] of Object.entries(step.userNotes)) {
                            if (content && content.trim()) {
                                if (key !== 'Current') {
                                    pdf.setFont('helvetica', 'bold');
                                    pdf.setTextColor(...colors.secondaryText);
                                    pdf.text(`Version ${key}:`, margin + 15, yPosition);
                                    yPosition += lineHeight;
                                }
                                pdf.setFont('helvetica', 'normal');
                                pdf.setTextColor(...colors.text);
                                yPosition = await processMarkdownForPDF(pdf, content, margin + 15, yPosition, pageWidth - margin * 2 - 25, colors);
                            }
                        }
                    }

                    // Completion status at the end of the step
                    yPosition += lineHeight * 0.6;
                    pdf.setFont('helvetica', 'bold');
                    if (step.done) {
                        pdf.setFillColor(...colors.complete);
                        pdf.circle(margin + 12, yPosition - 1, 2, 'F');
                        pdf.setTextColor(...colors.complete);
                        pdf.text('Complete', margin + 18, yPosition);
                    } else {
                        pdf.setDrawColor(...colors.incomplete);
                        pdf.setLineWidth(0.5);
                        pdf.circle(margin + 12, yPosition - 1, 2, 'S');
                        pdf.setTextColor(...colors.incomplete);
                        pdf.text('Incomplete', margin + 18, yPosition);
                    }
                    pdf.setTextColor(...colors.text);
                    yPosition += lineHeight * 1.5; // Increased padding between steps
                }
                
                // Add some space between stages
                yPosition += lineHeight * 1.8;
            }
            
            // Enhanced footer (dark theme)
            const totalPages = pdf.internal.getNumberOfPages();
            for (let i = 1; i <= totalPages; i++) {
                pdf.setPage(i);
                
                // Footer background (dark)
                pdf.setFillColor(...colors.footerBg);
                pdf.rect(0, pageHeight - 15, pageWidth, 15, 'F');
                pdf.setDrawColor(...colors.border);
                pdf.line(0, pageHeight - 15, pageWidth, pageHeight - 15);
                
                pdf.setFontSize(8);
                pdf.setFont('helvetica', 'normal');
                pdf.setTextColor(...colors.footerText);
                
                // Left footer
                pdf.text(`Generated by SMAX Upgrade Tool`, margin, pageHeight - 8);
                
                // Center footer
                pdf.text(`Copyright ${new Date().getFullYear()} Multi-Tenant Operations`, pageWidth / 2, pageHeight - 8, { align: 'center' });
                
                // Right footer
                pdf.text(`Page ${i} of ${totalPages}`, pageWidth - margin, pageHeight - 8, { align: 'right' });
            }
            
            // Save the PDF
            const filename = `${config.title.replace(/[^a-z0-9]/gi, '_')}_Dark_Export.pdf`;
            pdf.save(filename);
            
            console.log('[SMAX Tool] Dark theme PDF exported successfully:', filename);
            showSuccess('Dark theme PDF exported successfully!');
            
        } catch (e) {
            console.error('[SMAX Tool] PDF export error:', e);
            showError(`PDF export failed: ${e.message}`);
        }
    }

    // Initialize token input field if cached and auto-connect
    console.log('[SMAX Tool] Initializing application...');
    // Set default product to SMAX
    const cachedProduct = sessionStorage.getItem('selected_product') || 'SMAX';
    document.getElementById('selProduct').value = cachedProduct;
    
    // Update app title
    const titleElement = document.getElementById('appTitle');
    titleElement.textContent = `${cachedProduct} Multi-Tenant Operations`;
    
    // Set autosave checkbox state
    document.getElementById('autosaveToggle').checked = autosaveEnabled;
    
    const cachedToken = sessionStorage.getItem('github_token');
    console.log('[SMAX Tool] Cached token exists:', !!cachedToken);
    if (cachedToken) {
        GITHUB_TOKEN = cachedToken;
        document.getElementById('ghToken').value = cachedToken;
        console.log('[SMAX Tool] Attempting auto-connect');
        connect(true); // true indicates auto-connection
    } else {
        console.log('[SMAX Tool] No cached token, waiting for manual input');
    }

    // Make functions globally accessible for HTML event handlers
    window.connect = connect.bind(this);
    window.onProductChange = onProductChange.bind(this);
    window.onVersionChange = onVersionChange.bind(this);
    window.loadData = loadData.bind(this);
    window.saveData = saveData.bind(this);
    window.exportToPDF = exportToPDF.bind(this);
    window.showRawEditor = showRawEditor;
    window.closeRawEditor = closeRawEditor;
    window.saveRawEditor = saveRawEditor;
    window.closeEditStep = closeEditStep;
    window.saveEditStep = saveEditStep;
    window.showVersionUpgrade = showVersionUpgrade;
    window.toggleEnvVars = toggleEnvVars.bind(this);
    window.toggleClientMenu = toggleClientMenu.bind(this);
    window.closeClientMenu = closeClientMenu.bind(this);
    window.showResetModal = showResetModal.bind(this);
    window.editTitle = editTitle.bind(this);
    window.closeEnvVars = closeEnvVars.bind(this);
    window.editEnvVars = editEnvVars;
    window.closeEditEnvVars = closeEditEnvVars;
    window.saveEditEnvVars = saveEditEnvVars;
    window.prevStage = prevStage.bind(this);
    window.nextStage = nextStage.bind(this);
    window.addNewStage = addNewStage.bind(this);
    window.addNewStep = addNewStep.bind(this);
    window.toggleAutosave = toggleAutosave.bind(this);
    window.toggleDarkMode = toggleDarkMode.bind(this);
    
    // Add event listeners for controls
    document.getElementById('ghToken').addEventListener('change', () => connect());
    document.getElementById('selProduct').addEventListener('change', () => onProductChange());
}
</script>
</body>
</html>
