<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SMAX Multi-Client Upgrade Hub</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/1.5.3/jspdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>
    
    <!-- CodeMirror for live syntax highlighting in edit mode -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/monokai.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/markdown/markdown.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/python/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/shell/shell.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/yaml/yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/fold/foldgutter.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/fold/foldcode.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/fold/markdown-fold.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/fold/foldgutter.min.css" rel="stylesheet">
    <style>
        :root { 
            --primary: #2ea44f; 
            --dark: #24292e; 
            --bg: #f6f8fa; 
            --border: #d1d5da;
            --text: #24292e;
            --card-bg: #ffffff;
        }
        
        /* Dark mode variables */
        body.dark-mode {
            --dark: #f6f8fa;
            --bg: #0d1117;
            --border: #30363d;
            --text: #c9d1d9;
            --card-bg: #161b22;
        }
        
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif; 
            background: var(--bg); 
            margin: 0; 
            color: var(--text);
            transition: background 0.3s, color 0.3s;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        /* Header & Controls */
        .header { background: #24292e; color: white; padding: 1rem 2rem; display: flex; justify-content: space-between; align-items: center; }
        body.dark-mode .header { color: white; }
        .controls { display: flex; gap: 12px; flex-wrap: wrap; background: var(--card-bg); color: var(--text); padding: 15px 2rem; border-bottom: 1px solid var(--border); position: sticky; top: 0; z-index: 100; align-items: center; position: relative; }
        
        /* Layout */
        .container { max-width: 1000px; margin: 20px auto; padding: 0 20px; }
        .card { background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; padding: 16px; margin-bottom: 16px; position: relative; }
        .step-done { background: #f0fff4; border-left: 6px solid var(--primary); }
        body.dark-mode .step-done { background: #0d3818; }
        
        /* Elements */
        pre { background: #1b1f23; color: #e1e4e8; padding: 16px; border-radius: 6px; overflow-x: auto; font-family: ui-monospace, monospace; font-size: 13px; position: relative; }
        .copy-btn { position: absolute; top: 8px; right: 8px; background: #0366d6; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; }
        textarea { 
            width: 100%; 
            margin-top: 10px; 
            border: 1px solid var(--border); 
            border-radius: 6px; 
            padding: 10px; 
            font-family: inherit; 
            box-sizing: border-box;
            color: var(--text);
            text-rendering: optimizeLegibility;
            resize: vertical;
        }
        body.dark-mode textarea {
            background: var(--card-bg);
            border-color: var(--border);
        }
        input, select { 
            padding: 8px 12px; 
            border: 1px solid var(--border); 
            border-radius: 6px; 
            font-size: 14px;
            font-family: inherit;
            color: var(--text);
            text-rendering: optimizeLegibility;
        }
        body.dark-mode input, body.dark-mode select {
            background: var(--card-bg);
            border-color: var(--border);
        }
        
        /* Status Indicators */
        .status-area { display: flex; align-items: center; gap: 8px; font-size: 12px; }
        .indicator { width: 10px; height: 10px; border-radius: 50%; background: #d1d5da; }
        .online { background: var(--primary); box-shadow: 0 0 5px var(--primary); }
        .error-msg { background: #ffeef0; color: #d73a49; padding: 10px; border-radius: 6px; margin-bottom: 15px; display: none; border: 1px solid #f97583; }
        
        /* Stage Navigation */
        .stage-tabs { display: flex; gap: 8px; background: var(--card-bg); padding: 15px 2rem; border-bottom: 1px solid var(--border); overflow-x: auto; }
        .stage-tab { padding: 10px 20px; border-radius: 6px 6px 0 0; cursor: pointer; background: var(--bg); border: 1px solid var(--border); border-bottom: none; transition: all 0.2s; white-space: nowrap; }
        .stage-tab:hover { background: #e1e4e8; }
        body.dark-mode .stage-tab:hover { background: #21262d; }
        .stage-tab.active { background: var(--card-bg); border-bottom: 2px solid var(--card-bg); margin-bottom: -1px; font-weight: 600; color: var(--primary); }
        
        /* Progress Indicator */
        .progress-bar { height: 8px; background: var(--bg); border-radius: 4px; margin: 10px 0; overflow: hidden; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, var(--primary), #34d058); transition: width 0.3s ease; }
        
        /* Stage Navigation Buttons */
        .stage-nav { display: flex; justify-content: space-between; margin: 20px 0; }
        .stage-nav button { padding: 10px 20px; border: 1px solid var(--border); border-radius: 6px; cursor: pointer; background: var(--card-bg); font-weight: 500; color: var(--text); }
        .stage-nav button:hover { background: var(--bg); }
        .stage-nav button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        /* Markdown Notes */
        .note-section { margin-top: 15px; border-top: 1px solid var(--border); padding-top: 15px; }
        .note-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .note-header h5 { margin: 0; color: #586069; font-size: 14px; }
        .note-toggle { background: none; border: none; color: var(--primary); cursor: pointer; font-size: 12px; text-decoration: underline; }
        .note-editor { display: none; }
        .note-editor.active { display: block; }
        .note-content.editing .note-preview { display: none; }
        .note-content.editing .note-textarea { display: block; }
        .note-content:not(.editing) .note-preview { display: block; }
        .note-content:not(.editing) .note-textarea { display: none; }
        .note-preview { background: var(--bg); border: 1px solid var(--border); border-radius: 6px; padding: 12px; min-height: 40px; color: var(--text); }
        .note-preview h1, .note-preview h2, .note-preview h3 { margin-top: 0; }
        .note-preview code { background: #1b1f23; color: #e1e4e8; padding: 2px 6px; border-radius: 3px; font-family: ui-monospace, monospace; }
        .note-preview pre { background: #1b1f23; color: #e1e4e8; padding: 12px; border-radius: 6px; overflow-x: auto; }
        .note-preview pre code { background: none; padding: 0; }
        .note-preview ul, .note-preview ol { padding-left: 25px; }
        .note-preview blockquote { border-left: 4px solid var(--border); padding-left: 15px; color: #586069; margin: 10px 0; }
        
        /* Step content styling */
        .step-content pre { background: #1b1f23; color: #e1e4e8; padding: 16px; border-radius: 6px; overflow-x: auto; font-family: ui-monospace, monospace; font-size: 13px; position: relative; }
        .step-content code { background: #1b1f23; color: #e1e4e8; padding: 2px 6px; border-radius: 3px; font-family: ui-monospace, monospace; }
        .step-content pre code { background: none; padding: 0; }
        
        /* Reset Button */
        .reset-btn { background: #d73a49; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500; }
        .reset-btn:hover { background: #cb2431; }
        
        /* Modal */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.4); }
        .modal-content { background-color: var(--card-bg); margin: 15% auto; padding: 20px; border: 1px solid var(--border); border-radius: 6px; width: 400px; max-width: 90%; }
        .modal-buttons { display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px; }
        
        /* Inline editing */
        .editable { cursor: pointer; padding: 2px 6px; border-radius: 4px; transition: background 0.2s; }
        .editable:hover { background: var(--bg); }
        .editing { background: var(--card-bg); border: 1px solid var(--primary); padding: 4px 8px; }
        
        /* Notes toggle button */
        .note-toggle-btn { background: none; border: 1px solid var(--border); padding: 4px 12px; border-radius: 6px; cursor: pointer; color: var(--text); font-size: 12px; }
        .note-toggle-btn:hover { background: var(--bg); }
        .note-toggle-btn.has-notes { background: var(--primary); color: white; border-color: var(--primary); }
        
        /* Add buttons */
        .add-btn { background: var(--primary); color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; margin: 10px 0; }
        .add-btn:hover { background: #2c974b; }
        
        /* Autosave indicator */
        .autosave-indicator { font-size: 11px; color: #586069; margin-left: 10px; }
        
        /* Dark mode toggle */
        .theme-toggle { background: none; border: 1px solid var(--border); padding: 6px 12px; border-radius: 6px; cursor: pointer; color: var(--text); }
        .theme-toggle:hover { background: var(--bg); }
        
        /* Raw editor */
        .raw-editor { width: 100%; height: 600px; font-family: ui-monospace, monospace; font-size: 13px; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--card-bg); color: var(--text); }
        
        /* Unified Editor */
        .unified-editor { 
            width: 100%; 
            height: 100%; 
            min-height: 400px;
            font-family: ui-monospace, monospace; 
            font-size: 13px; 
            padding: 12px; 
            border: 1px solid var(--border); 
            border-radius: 6px; 
            background: var(--card-bg); 
            color: var(--text); 
            resize: vertical;
            line-height: 1.4;
            white-space: pre;
            overflow-wrap: normal;
            overflow-x: auto;
            box-sizing: border-box;
        }
        .unified-editor.word-wrap { white-space: pre-wrap; overflow-wrap: break-word; overflow-x: hidden; }
        .editor-container { position: relative; }
        .editor-header { 
            border-bottom: 1px solid var(--border); 
            padding: 10px !important;
            margin-bottom: 0 !important;
        }
        .editor-title-section { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-bottom: 8px;
        }
        .editor-buttons { 
            display: flex; 
            gap: 8px; 
        }
        .editor-toolbar { display: flex; gap: 8px; align-items: center; }
        .editor-status { display: flex; justify-content: space-between; font-size: 11px; color: #586069; margin: 8px 0; padding: 4px 8px; background: var(--bg); border-radius: 4px; }
        .editor-preview { 
            width: 100%; 
            height: 100%;
            min-height: 400px;
            padding: 12px; 
            border: 1px solid var(--border); 
            border-radius: 6px; 
            background: var(--card-bg); 
            color: var(--text); 
            overflow-y: auto;
            line-height: 1.6;
            box-sizing: border-box;
        }
        .editor-preview code { background: #1b1f23; color: #e1e4e8; padding: 2px 6px; border-radius: 3px; font-family: ui-monospace, monospace; }
        .editor-preview pre { background: #1b1f23; color: #e1e4e8; padding: 12px; border-radius: 6px; overflow-x: auto; margin: 10px 0; }
        .editor-preview pre code { background: none; padding: 0; }
        
        /* CodeMirror styling */
        .CodeMirror {
            height: 100%;
            min-height: 400px;
            font-family: ui-monospace, monospace;
            font-size: 13px;
            border: 1px solid var(--border);
            border-radius: 6px;
        }
        .CodeMirror-focused {
            outline: none;
            border-color: var(--primary);
        }
        
        /* Monokai theme adjustments for better integration */
        .CodeMirror.cm-s-monokai {
            background: #272822 !important;
            color: #f8f8f2 !important;
        }
        .CodeMirror.cm-s-monokai .CodeMirror-gutters {
            background: #272822 !important;
            border-right: 1px solid #49483e !important;
        }
        .CodeMirror.cm-s-monokai .CodeMirror-linenumber {
            color: #90908a !important;
        }
        .CodeMirror.cm-s-monokai .CodeMirror-foldgutter {
            background: #272822 !important;
            border-right: 1px solid #49483e !important;
        }
        .CodeMirror.cm-s-monokai .CodeMirror-foldgutter-open,
        .CodeMirror.cm-s-monokai .CodeMirror-foldgutter-folded {
            color: #f8f8f2 !important;
        }
        
        /* Image upload */
        .image-upload-area { border: 2px dashed var(--border); border-radius: 6px; padding: 20px; text-align: center; margin: 10px 0; cursor: pointer; }
        .image-upload-area:hover { background: var(--bg); }
        .image-upload-area.dragging { border-color: var(--primary); background: var(--bg); }
        
        /* Environment Variables Sidebar */
        .env-vars-sidebar { position: fixed; top: 300px; right: -310px; width: 300px; max-height: 70vh; overflow-y: auto; z-index: 100; box-shadow: 0 4px 12px rgba(0,0,0,0.15); transition: right 0.3s ease; }
        .env-vars-sidebar.open { right: 20px; }
        
        /* Client Menu Modal */
        .client-menu-modal { position: fixed; top: 300px; left: 50px; width: 300px; max-height: 70vh; overflow-y: auto; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        
        /* Edit Step Modal */
        .edit-step-modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 600px; max-height: 80vh; overflow-y: auto; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .menu-item { padding: 8px 12px; cursor: pointer; border-bottom: 1px solid var(--border); }
        .menu-item:hover { background: var(--border); }
        .menu-item.selected { background: var(--primary); color: white; }
        .submenu { margin-left: 20px; }
        .submenu .menu-item { border-bottom: none; }
        
        /* Unified Editor Modal - Full Screen */
        #unifiedEditorModal.modal {
            background-color: rgba(0,0,0,0.1) !important;
        }
        #unifiedEditorModal .modal-content {
            width: 100vw !important;
            height: 100vh !important;
            max-width: none !important;
            max-height: none !important;
            margin: 0 !important;
            padding: 0 !important;
            border: none !important;
            border-radius: 0 !important;
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
        }
        .unified-editor-modal { 
            width: 100% !important;
            height: 100% !important;
            max-width: none !important;
            margin: 0 !important; 
            max-height: none !important; 
            overflow: hidden !important;
            display: flex !important;
            flex-direction: column !important;
        }
        .unified-editor-modal .editor-container {
            flex: 1 !important;
            min-height: 300px !important;
            overflow: hidden !important;
            padding: 10px !important;
        }
        .unified-editor-modal .editor-status {
            flex-shrink: 0 !important;
            margin-top: 8px !important;
            padding: 8px 10px !important;
            border-top: 1px solid var(--border) !important;
        }
    </style>
    <script>
        // Configure marked.js for proper code block rendering
        const renderer = new marked.Renderer();
        
        // Handle fenced code blocks
        renderer.code = function(code, language, escaped) {
            // Handle both string and object inputs (marked.js can pass objects in some versions)
            let codeStr = '';
            if (typeof code === 'string') {
                codeStr = code;
            } else if (typeof code === 'object' && code !== null) {
                // Try to extract text from object (marked.js token object)
                codeStr = code.text || code.raw || String(code);
            } else {
                codeStr = String(code || '');
            }
            
            const lang = language || 'text';
            let highlighted = codeStr;
            if (typeof Prism !== 'undefined' && Prism.languages[lang]) {
                // Replace variables with placeholders before highlighting
                let placeholderStr = codeStr;
                Object.keys(config.config || {}).forEach(key => {
                    const placeholder = `__INTERP_${key}__`;
                    placeholderStr = placeholderStr.replace(new RegExp(`<${key}>`, 'gi'), placeholder);
                    const upperKey = key.toUpperCase();
                    placeholderStr = placeholderStr.replace(new RegExp(`<${upperKey}>`, 'g'), placeholder);
                });
                console.log(`[SMAX Tool] Code renderer: original codeStr:`, codeStr);
                console.log(`[SMAX Tool] Code renderer: placeholderStr:`, placeholderStr);
                highlighted = Prism.highlight(placeholderStr, Prism.languages[lang], lang);
                console.log(`[SMAX Tool] Code renderer: highlighted with placeholders:`, highlighted);
                // Replace placeholders with styled spans
                Object.keys(config.config || {}).forEach(key => {
                    const placeholder = `__INTERP_${key}__`;
                    const val = config.config[key] || '';
                    const styledVal = `<span style="color: #ffa500; font-weight: bold; background-color: rgba(255, 165, 0, 0.1); padding: 2px 4px; border-radius: 3px;">${val}</span>`;
                    highlighted = highlighted.replace(new RegExp(placeholder, 'g'), styledVal);
                });
                console.log(`[SMAX Tool] Code renderer: final highlighted:`, highlighted);
            }
            return `<pre class="language-${lang}"><code class="language-${lang}">${highlighted}</code></pre>`;
        };
        
        // Handle inline code
        renderer.codespan = function(code) {
            return `<code>${code}</code>`;
        };

        marked.setOptions({
            breaks: true,
            gfm: true,
            renderer: renderer
        });
    </script>
</head>
<body>

<div class="header">
    <strong id="appTitle">SMAX Multi-Tenant Operations</strong>
    <div class="status-area">
        <button class="theme-toggle" onclick="toggleDarkMode()" title="Toggle dark mode">
            <span id="theme-icon">üåô</span>
        </button>
        <div id="syncInd" class="indicator"></div>
        <span id="syncStat">Offline</span>
        <span id="autosave-status" class="autosave-indicator"></span>
    </div>
</div>

<div class="controls">
    <input type="password" id="ghToken" placeholder="Paste GitHub Token">
    
    <select id="selProduct">
        <option value="SMAX">SMAX</option>
        <option value="OTHER">Other Products (Future)</option>
    </select>
    
    <select id="selVer" onchange="onVersionChange()">
        <option value="">Select version...</option>
    </select>

    <select id="selClient" onchange="loadData()">
        <option value="">Loading clients...</option>
    </select>

    <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
        <input type="checkbox" id="autosaveToggle" onchange="toggleAutosave()" checked />
        Autosave
    </label>

    <button onclick="saveData()" style="background: var(--primary); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
        üíæ Save
    </button>
    
    <button onclick="loadData()" style="background: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
        üîÑ Refresh
    </button>

    <button onclick="exportToPDF()" style="background: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
        üñ®Ô∏è PDF
    </button>
    
    <button onclick="showRawEditor()" style="background: #6f42c1; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
        üìù Editor
    </button>
    
    <button onclick="showVersionUpgrade()" style="background: #0366d6; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
        üöÄ Upgrade
    </button>
    
    <button onclick="toggleEnvVars()" id="envToggleBtn" style="background: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
        ‚öôÔ∏è Variables
    </button>
    
    <button onclick="toggleClientMenu()" id="menuToggleBtn" style="background: #17a2b8; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
        üìÅ Menu
    </button>
    
    <div class="card client-menu-modal" id="client-menu-card" style="display: none;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h4 style="margin: 0;">Clients & Versions</h4>
            <button onclick="closeClientMenu()" style="background: none; border: none; font-size: 18px; cursor: pointer; color: var(--text);">‚úï</button>
        </div>
        <div id="client-menu-content"></div>
    </div>
    
    <button onclick="showResetModal()" class="reset-btn">
        üîÑ Reset Steps
    </button>
</div>

<div id="stage-tabs-container" class="stage-tabs" style="display: none;"></div>

<div class="container">
    <div id="errorBox" class="error-msg"></div>
    
    <!-- Document Title -->
    <div id="doc-title-container" style="display: none; margin-bottom: 20px;">
        <h2 id="doc-title" class="editable" onclick="editTitle()" style="margin: 0; cursor: pointer;">Document Title</h2>
    </div>
    
    <div id="progress-container" style="display: none;">
        <h4>Stage Progress</h4>
        <div class="progress-bar">
            <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
        </div>
        <div style="font-size: 12px; color: #586069; margin-top: 5px;">
            <span id="progress-text">0 of 0 steps completed</span>
        </div>
    </div>

    <div class="card env-vars-sidebar" id="env-vars-card" style="display: none;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h4 style="margin: 0;">Environment Variables</h4>
            <div>
                <button onclick="editEnvVars()" style="background: #0366d6; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; margin-right: 8px;">Edit Raw</button>
                <button onclick="closeEnvVars()" style="background: none; border: none; font-size: 18px; cursor: pointer; color: var(--text);">‚úï</button>
            </div>
        </div>
        <div id="var-inputs" style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:15px;"></div>
    </div>
    
    <div class="stage-nav" id="stage-nav" style="display: none;">
        <button id="prev-stage-btn" onclick="prevStage()">‚Üê Previous Stage</button>
        <div>
            <button class="add-btn" onclick="addNewStage()">‚ûï Add New Stage</button>
        </div>
        <button id="next-stage-btn" onclick="nextStage()">Next Stage ‚Üí</button>
    </div>

    <div id="steps-list"></div>
    
    <div style="text-align: center; margin: 20px 0;" id="add-step-container" style="display: none;">
        <button class="add-btn" onclick="addNewStep()">‚ûï Add New Step to Current Stage</button>
    </div>
    
    <div class="stage-nav" id="stage-nav-bottom" style="display: none;">
        <button id="prev-stage-btn-bottom" onclick="prevStage()">‚Üê Previous Stage</button>
        <button id="next-stage-btn-bottom" onclick="nextStage()">Next Stage ‚Üí</button>
    </div>
</div>

<!-- Reset Confirmation Modal -->
<div id="resetModal" class="modal">
    <div class="modal-content">
        <h3 style="margin-top: 0;">Reset Completed Steps</h3>
        <p>Are you sure you want to reset all completed steps? This will mark all steps as incomplete.</p>
        <div class="modal-buttons">
            <button onclick="closeResetModal()" style="padding: 8px 16px; border: 1px solid var(--border); border-radius: 6px; cursor: pointer; background: white;">
                Cancel
            </button>
            <button onclick="confirmReset()" class="reset-btn">
                Reset All
            </button>
        </div>
    </div>
</div>

<div id="unifiedEditorModal" class="modal">
    <div class="modal-content unified-editor-modal">
        <div class="editor-header">
            <div class="editor-title-section">
                <h3 id="editorTitle" style="margin: 0;">Editor</h3>
                <div class="editor-buttons">
                    <button id="cancelEditorBtn" style="padding: 6px 12px; border: 1px solid var(--border); border-radius: 4px; cursor: pointer; background: var(--card-bg); color: var(--text); font-size: 12px;">
                        Cancel
                    </button>
                    <button id="saveEditorBtn" style="background: var(--primary); color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                        Apply Changes
                    </button>
                </div>
            </div>
            <div class="editor-toolbar">
                <button id="editorPreviewBtn" onclick="toggleEditorPreview()" style="display: none; background: #28a745; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; margin-right: 8px;">üëÅÔ∏è Preview</button>
                <button id="expandBtn" style="background: #6c757d; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; margin-right: 8px;">‚è¨ Expand</button>
                <button id="collapseBtn" style="background: #6c757d; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; margin-right: 8px;">‚è´ Collapse</button>
                <button onclick="toggleWordWrap()" id="wordWrapBtn" style="background: #6c757d; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; margin-right: 8px;">‚Ü©Ô∏è Wrap</button>
                <button onclick="toggleSyntaxHighlighting()" id="syntaxHighlightBtn" style="background: #6c757d; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; margin-right: 8px;">üé® Highlight</button>
                <select id="editorFontSize" onchange="changeFontSize()" style="padding: 2px 4px; border: 1px solid var(--border); border-radius: 4px; background: var(--card-bg); color: var(--text); font-size: 12px;">
                    <option value="11">11px</option>
                    <option value="13" selected>13px</option>
                    <option value="15">15px</option>
                    <option value="17">17px</option>
                </select>
            </div>
        </div>
        <div id="editorContainer" class="editor-container">
            <textarea id="unifiedEditorContent" class="unified-editor"></textarea>
            <div id="editorPreview" class="editor-preview" style="display: none;"></div>
        </div>
        <div class="editor-status">
            <span id="editorStatus">Ready</span>
            <span id="editorLineCol">Ln 1, Col 1</span>
        </div>
    </div>
</div>

<!-- Version Upgrade Modal -->
<div id="versionUpgradeModal" class="modal">
    <div class="modal-content">
        <h3 style="margin-top: 0;">Upgrade to New Version</h3>
        <p>Select or create a target version to upgrade to:</p>
        <select id="targetVersionSelect" onchange="onTargetVersionChange()" style="width: 100%; padding: 8px; margin: 10px 0; border: 1px solid var(--border); border-radius: 6px; background: var(--card-bg); color: var(--text);">
            <option value="">Select version...</option>
        </select>
        <div id="newVersionDiv" style="display: none; margin: 10px 0;">
            <label for="newVersionInput" style="display: block; margin-bottom: 5px; color: var(--text);">New Version Number:</label>
            <input type="text" id="newVersionInput" placeholder="e.g., 24.6" style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 6px; background: var(--card-bg); color: var(--text); box-sizing: border-box;">
        </div>
        <p style="font-size: 12px; color: #586069; margin-top: 15px;">
            This will:
            <br>‚Ä¢ Archive current notes under the current version
            <br>‚Ä¢ Reset all step completion statuses
            <br>‚Ä¢ Save to the new version folder
        </p>
        <div class="modal-buttons">
            <button onclick="closeVersionUpgrade()" style="padding: 8px 16px; border: 1px solid var(--border); border-radius: 6px; cursor: pointer; background: var(--card-bg); color: var(--text);">
                Cancel
            </button>
            <button onclick="confirmVersionUpgrade()" style="background: #0366d6; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                Upgrade
            </button>
        </div>
    </div>
</div>

<script>
// Wait for DOM to be ready
document.addEventListener('DOMContentLoaded', async function() {
    // Initialize the application
    await initializeApp();
});

// Global variables (will be set in initializeApp)
let GITHUB_TOKEN = "";
let FILE_SHA = "";
let CURRENT_YAML_PATH = "";
let config = { title: "", config: {}, stages: [] };
let currentStageIndex = 0;
let autosaveEnabled = true;
let autosaveTimeout = null;
let editingStageIndex, editingStepIndex;
let menuData = {};
let syntaxHighlightingEnabled = true;
let currentEditorConfig = null;
let codeMirrorEditor = null; // For live syntax highlighting in edit mode

// Hardcoded repository information for personal use
const OWNER = "gianandr4";
const REPO = "SMAX-Upgrade-Tool";

// Early function definitions to ensure they're available for onclick handlers
function toggleEditorPreview() {
    if (!currentEditorConfig) {
        console.error('[UNIFIED EDITOR] No currentEditorConfig');
        return;
    }
    
    const textarea = document.getElementById('unifiedEditorContent');
    const preview = document.getElementById('editorPreview');
    const previewBtn = document.getElementById('editorPreviewBtn');
    
    if (preview.style.display === 'none') {
        // Show preview
        const content = codeMirrorEditor ? codeMirrorEditor.getValue() : textarea.value;
        if (currentEditorConfig.mode === 'markdown') {
            preview.innerHTML = marked.parse(content);
            // Syntax highlighting is now handled by marked.js highlight function
        } else {
            preview.textContent = content;
        }
        preview.style.height = '100%';
        preview.style.minHeight = '400px';
        preview.style.display = 'block';
        if (codeMirrorEditor) {
            codeMirrorEditor.getWrapperElement().style.display = 'none';
        } else {
            textarea.style.display = 'none';
        }
        previewBtn.textContent = '‚úèÔ∏è Edit';
    } else {
        // Show editor
        preview.style.display = 'none';
        if (codeMirrorEditor) {
            codeMirrorEditor.getWrapperElement().style.display = 'block';
            codeMirrorEditor.refresh();
            codeMirrorEditor.focus();
        } else {
            textarea.style.display = 'block';
            textarea.focus();
        }
        previewBtn.textContent = 'üëÅÔ∏è Preview';
    }
}

function toggleSyntaxHighlighting() {
    const btn = document.getElementById('syntaxHighlightBtn');
    syntaxHighlightingEnabled = !syntaxHighlightingEnabled;
    
    if (syntaxHighlightingEnabled) {
        btn.textContent = 'üé® Highlight';
        btn.style.background = '#6c757d';
        
        // Switch to CodeMirror if not already active
        if (!codeMirrorEditor && typeof CodeMirror !== 'undefined') {
            const textarea = document.getElementById('unifiedEditorContent');
            const content = textarea.value;
            
            codeMirrorEditor = CodeMirror.fromTextArea(textarea, {
                lineNumbers: true,
                mode: 'markdown', // Use markdown mode
                theme: 'monokai', // Use monokai theme for better contrastrast
                lineWrapping: true,
                viewportMargin: Infinity,
                extraKeys: {
                    "Ctrl-B": function(cm) { insertUnifiedMarkdown("**", "**"); },
                    "Ctrl-I": function(cm) { insertUnifiedMarkdown("*", "*"); },
                    "Ctrl-`": function(cm) { insertUnifiedMarkdown("`", "`"); },
                    "Ctrl-K": function(cm) { insertUnifiedMarkdown("[", "](url)"); }
                }
            });
            
            codeMirrorEditor.setValue(content);
            
            // Apply current font size to CodeMirror
            const fontSizeSelect = document.getElementById('editorFontSize');
            const currentFontSize = fontSizeSelect.value + 'px';
            codeMirrorEditor.getWrapperElement().style.fontSize = currentFontSize;
            codeMirrorEditor.refresh();
            
            codeMirrorEditor.on('change', function(cm) {
                textarea.value = cm.getValue();
                updateEditorStatus();
            });
            
            textarea.style.display = 'none';
        }
    } else {
        btn.textContent = 'üö´ No Highlight';
        btn.style.background = '#dc3545';
        
        // Switch back to regular textarea
        if (codeMirrorEditor) {
            const textarea = document.getElementById('unifiedEditorContent');
            codeMirrorEditor.toTextArea();
            codeMirrorEditor = null;
            textarea.style.display = 'block';
        }
    }
    
    // If currently in preview mode, refresh the preview
    const preview = document.getElementById('editorPreview');
    const textarea = document.getElementById('unifiedEditorContent');
    if (preview.style.display !== 'none' && currentEditorConfig && currentEditorConfig.mode === 'markdown') {
        const content = codeMirrorEditor ? codeMirrorEditor.getValue() : textarea.value;
        // Syntax highlighting is now handled by marked.js highlight function
    }
}

// Dynamic product path based on selection
function getVersionsBasePath() {
    const product = document.getElementById('selProduct').value;
    return product === 'SMAX' ? 'SMAX' : product;
}

// Version upgrade functions (moved to global scope)
function showVersionUpgrade() {
    const modal = document.getElementById('versionUpgradeModal');
    const select = document.getElementById('targetVersionSelect');
    
    // Populate version options
    const currentVer = document.getElementById('selVer').value;
    const verSelect = document.getElementById('selVer');
    select.innerHTML = '<option value="">Select version...</option>';
    
    Array.from(verSelect.options).forEach(opt => {
        if (opt.value !== currentVer) {
            const newOpt = document.createElement('option');
            newOpt.value = opt.value;
            newOpt.textContent = opt.textContent;
            select.appendChild(newOpt);
        }
    });
    
    // Add option to create new version
    const newVerOpt = document.createElement('option');
    newVerOpt.value = '__new__';
    newVerOpt.textContent = '‚ûï Create New Version...';
    select.appendChild(newVerOpt);
    
    modal.style.display = 'block';
}

function closeVersionUpgrade() {
    console.log('[SMAX Tool] closeVersionUpgrade called');
    document.getElementById('versionUpgradeModal').style.display = 'none';
    // Reset new version input
    document.getElementById('newVersionDiv').style.display = 'none';
    document.getElementById('newVersionInput').value = '';
}

function onTargetVersionChange() {
    console.log('[SMAX Tool] onTargetVersionChange called');
    const select = document.getElementById('targetVersionSelect');
    const newVersionDiv = document.getElementById('newVersionDiv');
    
    if (select.value === '__new__') {
        newVersionDiv.style.display = 'block';
    } else {
        newVersionDiv.style.display = 'none';
        document.getElementById('newVersionInput').value = '';
    }
}

async function confirmVersionUpgrade() {
    console.log('[SMAX Tool] confirmVersionUpgrade called');
    const select = document.getElementById('targetVersionSelect');
    let targetVersion = select.value;
    
    if (!targetVersion) {
        showError('Please select a target version');
        return;
    }
    
    // Handle new version creation
    if (targetVersion === '__new__') {
        const newVersionInput = document.getElementById('newVersionInput');
        targetVersion = newVersionInput.value.trim();
        
        if (!targetVersion) {
            showError('Please enter a version number');
            return;
        }
        
        // Validate version format (should contain numbers and dots)
        if (!/^\d+(\.\d+)*$/.test(targetVersion)) {
            showError('Version should contain only numbers and dots (e.g., 24.6)');
            return;
        }
    }
    
    const currentClient = document.getElementById('selClient').value;
    const currentVersion = document.getElementById('selVer').value;
    
    try {
        // Archive current notes under #### history in each step
        config.stages.forEach(stage => {
            stage.steps.forEach(step => {
                if (step.userNotes && step.userNotes['Current']) {
                    const currentVersion = document.getElementById('selVer').value;
                    
                    // Move current notes to the previous version's archive
                    step.userNotes[currentVersion] = step.userNotes['Current'];
                    
                    // Clear current notes for fresh start in new version
                    step.userNotes['Current'] = '';
                }
                // Reset done status
                step.done = false;
            });
        });
        
        // Update title
        config.title = config.title.replace(currentVersion, targetVersion);
        
        // Update version in config
        if (config.config.version) {
            config.config.version = targetVersion;
        }
        
        // Save to new version folder
        const basePath = getVersionsBasePath();
        const newPath = `${basePath}/${targetVersion}/${currentClient}.md`;
        const oldPath = CURRENT_YAML_PATH;
        CURRENT_YAML_PATH = newPath;
        FILE_SHA = ""; // New file
        
        // Save to localStorage as backup
        try {
            localStorage.setItem('smax_config_backup', JSON.stringify(config));
            console.log('[SMAX Tool] Config saved to localStorage backup');
            
            // Show temporary success message
            const status = document.getElementById('autosave-status');
            if (status) {
                status.textContent = `Upgraded to ${targetVersion} (saved locally)`;
                status.style.color = 'var(--primary)';
                setTimeout(() => {
                    status.textContent = 'Autosave enabled';
                    status.style.color = '';
                }, 3000);
            }
        } catch (e) {
            console.error('[SMAX Tool] Failed to save to localStorage:', e);
        }
        
        // Try to save to GitHub
        if (GITHUB_TOKEN) {
            await saveData();
        } else {
            console.log('[SMAX Tool] GitHub not connected, upgrade saved locally only');
            // Update status to show local save
            const status = document.getElementById('autosave-status');
            if (status) {
                status.textContent = `Upgraded to ${targetVersion} (GitHub not connected)`;
                status.style.color = '#d73a49'; // Red color for warning
                setTimeout(() => {
                    status.textContent = 'Autosave enabled';
                    status.style.color = '';
                }, 3000);
            }
        }
        
        // Update UI to show new version
        document.getElementById('selVer').value = targetVersion;
        
        console.log(`[SMAX Tool] Upgraded from ${currentVersion} to ${targetVersion}`);
        showSuccess(`Successfully upgraded to version ${targetVersion}`);
        
        closeVersionUpgrade();
        
        // Refresh the version list to include the new version
        if (GITHUB_TOKEN) {
            await fetchFolders();
        } else {
            // Manually add the new version to the dropdown if not already present
            const verSelect = document.getElementById('selVer');
            let versionExists = false;
            for (let i = 0; i < verSelect.options.length; i++) {
                if (verSelect.options[i].value === targetVersion) {
                    versionExists = true;
                    break;
                }
            }
            if (!versionExists) {
                const newOpt = document.createElement('option');
                newOpt.value = targetVersion;
                newOpt.textContent = targetVersion;
                verSelect.appendChild(newOpt);
            }
        }
        
        // Ensure the new version is selected
        document.getElementById('selVer').value = targetVersion;
        
        // Fetch clients for the new version
        if (GITHUB_TOKEN) {
            await fetchClients(targetVersion);
        } else {
            // Manually add the client to the dropdown if not already present
            const clientSelect = document.getElementById('selClient');
            let clientExists = false;
            for (let i = 0; i < clientSelect.options.length; i++) {
                if (clientSelect.options[i].value === currentClient) {
                    clientExists = true;
                    break;
                }
            }
            if (!clientExists) {
                const newOpt = document.createElement('option');
                newOpt.value = currentClient;
                newOpt.textContent = currentClient;
                clientSelect.appendChild(newOpt);
            }
        }
        
        // Ensure the client is selected
        document.getElementById('selClient').value = currentClient;
        
        // Load the data for the new version
        await loadData();
        
    } catch (e) {
        console.error('[SMAX Tool] Version upgrade error:', e);
        showError(`Version upgrade failed: ${e.message}`);
    }
}

async function initializeApp() {

    // Trigger autosave after changes
    function triggerAutosave() {
        if (autosaveEnabled) {
            saveData();
        }
    }

    // Toggle autosave functionality
    function toggleAutosave() {
        const checkbox = document.getElementById('autosaveToggle');
        autosaveEnabled = checkbox.checked;
        console.log('[SMAX Tool] Autosave', autosaveEnabled ? 'enabled' : 'disabled');
        // Optionally save the preference
        localStorage.setItem('autosave_enabled', autosaveEnabled);
    }

    async function connect(autoConnect = false) {
        GITHUB_TOKEN = document.getElementById('ghToken').value;
        if (!GITHUB_TOKEN) {
            if (!autoConnect) {
                showError('Please enter a GitHub token');
            }
            return;
        }
        // Cache token in session storage
        sessionStorage.setItem('github_token', GITHUB_TOKEN);
        console.log('[SMAX Tool] Token set, length:', GITHUB_TOKEN.length);
        if (!autoConnect) {
            console.log('[SMAX Tool] Connecting with GitHub token...');
        } else {
            console.log('[SMAX Tool] Auto-connecting with cached GitHub token...');
        }
        
        // Restore product selection or default to SMAX
        const cachedProduct = sessionStorage.getItem('selected_product') || 'SMAX';
        document.getElementById('selProduct').value = cachedProduct;
        
        // Update app title
        const titleElement = document.getElementById('appTitle');
        titleElement.textContent = `${cachedProduct} Multi-Tenant Operations`;
        
        // Step 1: Dynamically find folders
        await fetchFolders();
        // Step 2: Load data for selected folder (will use cached selections or defaults)
        loadData();
    }

    // NEW: Automatically find version folders (e.g., 24.4, 25.1)
    async function fetchFolders() {
        if (!GITHUB_TOKEN) return;
        try {
            const basePath = getVersionsBasePath();
            console.log(`[SMAX Tool] Fetching folders from ${OWNER}/${REPO}/${basePath}...`);
            const resp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${basePath}`, {
                headers: { Authorization: `token ${GITHUB_TOKEN}` }
            });
            
            console.log(`[SMAX Tool] API call to ${OWNER}/${REPO}/contents/${basePath} returned status: ${resp.status}`);
            
            if (!resp.ok) {
                const errorData = await resp.json();
                console.error(`[SMAX Tool] fetchFolders failed:`, errorData);
                throw new Error(`GitHub API: ${errorData.message || resp.statusText}`);
            }
            
            const items = await resp.json();
            console.log(`[SMAX Tool] fetchFolders received ${items.length} items:`, items.map(item => `${item.name} (${item.type})`));
            const folderSelect = document.getElementById('selVer');
            
            // Clear existing options
            folderSelect.innerHTML = "";

            // Collect directories
            const directories = new Set();
            
            // Add actual directories
            items.filter(item => item.type === 'dir' && !item.name.startsWith('.')).forEach(item => {
                directories.add(item.name);
            });
            
            // Also infer directories from file paths
            items.filter(item => item.type === 'file').forEach(item => {
                const pathParts = item.path.replace(basePath + '/', '').split('/');
                if (pathParts.length > 1) {
                    directories.add(pathParts[0]);
                }
            });
            
            const folders = Array.from(directories).sort();
            
            if (folders.length === 0) {
                showError('No version folders found in repository');
                return;
            }
            
            folders.forEach(folderName => {
                const opt = document.createElement('option');
                opt.value = folderName;
                opt.innerText = `Version ${folderName}`;
                folderSelect.appendChild(opt);
                
                // Store in menu data
                menuData[folderName] = [];
            });
            
            console.log(`[SMAX Tool] Found ${folders.length} version folder(s): ${folders.join(', ')}`);
            
            renderClientMenu();
            
            // Load clients for cached version or first version
            const cachedVersion = sessionStorage.getItem('selected_version');
            const targetVersion = cachedVersion && folders.includes(cachedVersion) ? cachedVersion : folders[0];
            
            if (targetVersion) {
                document.getElementById('selVer').value = targetVersion;
                await fetchClients(targetVersion);
            }
        } catch (e) {
            console.error('[SMAX Tool] fetchFolders error:', e);
            showError(`Failed to load folders: ${e.message}`);
        }
    }
    
    // NEW: Fetch clients from version folder
    async function fetchClients(version) {
        if (!GITHUB_TOKEN) return;
        try {
            const basePath = getVersionsBasePath();
            console.log(`[SMAX Tool] Fetching clients from ${basePath}/${version}/...`);
            const resp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${basePath}/${version}`, {
                headers: { Authorization: `token ${GITHUB_TOKEN}` }
            });
            
            if (!resp.ok) {
                const errorData = await resp.json();
                console.error(`[SMAX Tool] Failed to fetch clients for ${version}:`, errorData);
                throw new Error(`GitHub API: ${errorData.message || resp.statusText}`);
            }
            
            const items = await resp.json();
            console.log(`[SMAX Tool] Found ${items.length} items in ${basePath}/${version}:`, items.map(item => `${item.name} (${item.type})`));
            
            const clientSelect = document.getElementById('selClient');
            
            // Clear existing options
            clientSelect.innerHTML = "";
            
            // Find all client markdown files (excluding README.md)
            const clientFiles = items.filter(item => 
                item.type === 'file' && 
                item.name.endsWith('.md') &&
                item.name !== 'README.md' &&
                item.name !== 'template.md'
            );
            
            console.log(`[SMAX Tool] Found ${clientFiles.length} client files:`, clientFiles.map(f => f.name));
            
            if (clientFiles.length === 0) {
                // If no clients found, it might be a timing issue after upgrade
                // Try again after a short delay
                console.log(`[SMAX Tool] No client files found, retrying in 2 seconds...`);
                setTimeout(() => fetchClients(version), 2000);
                return;
            }
            
            // Extract client names
            const clients = new Set();
            clientFiles.forEach(file => {
                // Extract client name from filename (e.g., "client-A.md")
                const clientName = file.name.replace(/\.md$/, '');
                clients.add(clientName);
                console.log(`[SMAX Tool] Added client: ${clientName} from file: ${file.name}`);
            });
            
            clients.forEach(client => {
                const opt = document.createElement('option');
                opt.value = client;
                opt.innerText = client.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                clientSelect.appendChild(opt);
            });
            
            // Store in menu data
            menuData[version] = Array.from(clients);
            renderClientMenu();
            
            // Restore cached client selection or select first available
            const cachedClient = sessionStorage.getItem('selected_client');
            if (cachedClient && clients.has(cachedClient)) {
                document.getElementById('selClient').value = cachedClient;
            } else if (clients.size > 0) {
                // Select first available client as default
                const firstClient = Array.from(clients)[0];
                document.getElementById('selClient').value = firstClient;
                sessionStorage.setItem('selected_client', firstClient);
            }
            
            console.log(`[SMAX Tool] Found ${clients.size} client(s)`);
        } catch (e) {
            console.error('[SMAX Tool] fetchClients error:', e);
            showError(`Failed to load clients: ${e.message}`);
        }
    }
    
    // NEW: Parse markdown with front-matter
    function parseMarkdownFrontMatter(content) {
        // Extract front-matter (between --- delimiters)
        const frontMatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
        const match = content.match(frontMatterRegex);
        
        if (!match) {
            throw new Error('Invalid markdown format: missing front-matter');
        }
        
        const frontMatter = jsyaml.load(match[1]);
        const markdown = match[2];
        
        return { config: frontMatter.config || {}, markdown };
    }
    
    // NEW: Parse markdown content into title, stages and steps
    // # = Document title
    // ## = Stages
    // ### = Steps
    function parseMarkdownStages(markdown) {
        console.log('[SMAX Tool] parseMarkdownStages called with markdown length:', markdown.length);
        console.log('[SMAX Tool] First 500 chars of markdown:', markdown.substring(0, 500));
        const stages = [];
        const lines = markdown.split('\n');
        
        let documentTitle = '';
        let currentStage = null;
        let currentStep = null;
        let collectingCommand = false;
        let collectingNotes = false;
        let collectingSubsection = false;
        let commandBuffer = [];
        let notesBuffer = [];
        let subsectionBuffer = [];
        let currentSubsection = '';
        let rawBuffer = [];
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            // H1 = Document Title
            if (line.startsWith('# ') && !line.startsWith('## ')) {
                documentTitle = line.substring(2).trim();
                continue;
            }
            
            // H2 = New Stage
            if (line.startsWith('## ') && !line.startsWith('### ')) {
                if (currentStep && currentStage) {
                    currentStep.rawMd = rawBuffer.join('\n');
                    currentStage.steps.push(currentStep);
                }
                if (currentStage) {
                    stages.push(currentStage);
                }
                
                currentStage = {
                    name: line.substring(3).trim(),
                    steps: []
                };
                currentStep = null;
                collectingCommand = false;
                collectingNotes = false;
                collectingSubsection = false;
                rawBuffer = [];
                continue;
            }
            
            // Collect raw line for current step
            if (currentStep) {
                rawBuffer.push(line);
            }
            
            // Code block handling - only skip when extracting commands, otherwise include in content
            // (This was previously skipping all code blocks, but they should be part of step content)
            
            // H4 = Notes section
            if (line.startsWith('#### ')) {
                const sectionTitle = line.substring(5).trim();
                if (sectionTitle.toLowerCase().includes('notes') || sectionTitle.toLowerCase().includes('note')) {
                    collectingNotes = true;
                    notesBuffer = [];
                    collectingSubsection = false;
                    currentSubsection = '';
                    console.log('[SMAX Tool] Started collecting notes for step:', currentStep.title);
                }
                continue;
            }
            
            // H5 = Subsection within notes (version-specific notes)
            if (collectingNotes && line.startsWith('##### ')) {
                // Save current notes as "Current" if we haven't started a subsection yet
                if (!currentSubsection && notesBuffer.length > 0) {
                    currentStep.userNotes['Current'] = notesBuffer.join('\n').trim();
                    console.log('[SMAX Tool] Saved Current notes:', currentStep.userNotes['Current']);
                    notesBuffer = [];
                }
                // Save previous subsection if any
                if (currentSubsection && subsectionBuffer.length > 0) {
                    currentStep.userNotes[currentSubsection] = subsectionBuffer.join('\n').trim();
                }
                // Start new version-specific subsection
                currentSubsection = line.substring(6).trim();
                subsectionBuffer = [];
                collectingSubsection = true;
                continue;
            }
            
            // Collect notes content
            if (collectingNotes && currentStep) {
                // Check if we've reached the completion marker or next step/stage
                if (line.startsWith('### ')) {
                    const title = line.substring(4).trim();
                    if (title === '- [x] Complete' || title === '- [X] Complete' || title === '- [ ] Complete') {
                        // Save any remaining content
                        if (currentSubsection && subsectionBuffer.length > 0) {
                            currentStep.userNotes[currentSubsection] = subsectionBuffer.join('\n').trim();
                        } else if (!currentSubsection && notesBuffer.length > 0) {
                            currentStep.userNotes['Current'] = notesBuffer.join('\n').trim();
                        }
                        collectingNotes = false;
                        collectingSubsection = false;
                        // Don't continue here - let the completion marker be processed
                    } else {
                        // This is a new step, end notes
                        if (currentSubsection && subsectionBuffer.length > 0) {
                            currentStep.userNotes[currentSubsection] = subsectionBuffer.join('\n').trim();
                        } else if (!currentSubsection && notesBuffer.length > 0) {
                            currentStep.userNotes['Current'] = notesBuffer.join('\n').trim();
                        }
                        collectingNotes = false;
                        collectingSubsection = false;
                        // Don't continue here - let the header be processed normally
                    }
                } else if (line.startsWith('## ') || line.startsWith('# ')) {
                    // End of notes section
                    if (currentSubsection && subsectionBuffer.length > 0) {
                        currentStep.userNotes[currentSubsection] = subsectionBuffer.join('\n').trim();
                    } else if (!currentSubsection && notesBuffer.length > 0) {
                        currentStep.userNotes['Current'] = notesBuffer.join('\n').trim();
                    }
                    collectingNotes = false;
                    collectingSubsection = false;
                    // Don't continue here - let the header be processed normally
                } else if (line.trim() === '---') {
                    // Skip separator lines
                    continue;
                } else if (collectingSubsection) {
                    subsectionBuffer.push(line);
                    continue;
                } else {
                    // Content before first ##### goes to Current
                    notesBuffer.push(line);
                    continue;
                }
            }
            
            // H3 = New Step or Completion Marker
            if (line.startsWith('### ')) {
                const title = line.substring(4).trim();
                
                // Check if this is a completion marker
                if (title === '- [x] Complete' || title === '- [X] Complete') {
                    if (currentStep) {
                        currentStep.done = true;
                        currentStep.rawMd = rawBuffer.join('\n');
                        currentStage.steps.push(currentStep);
                    }
                    currentStep = null;
                    collectingCommand = false;
                    collectingNotes = false;
                    collectingSubsection = false;
                    rawBuffer = [];
                    continue;
                } else if (title === '- [ ] Complete') {
                    if (currentStep) {
                        currentStep.done = false;
                        currentStep.rawMd = rawBuffer.join('\n');
                        currentStage.steps.push(currentStep);
                    }
                    currentStep = null;
                    collectingCommand = false;
                    collectingNotes = false;
                    collectingSubsection = false;
                    rawBuffer = [];
                    continue;
                } else {
                    // This is a regular step title
                    if (currentStep && currentStage) {
                        currentStep.rawMd = rawBuffer.join('\n');
                        currentStage.steps.push(currentStep);
                    }
                    
                    currentStep = {
                        id: title.toLowerCase().replace(/[^a-z0-9]+/g, '_'),
                        title: title,
                        notes: '',
                        command: '',
                        done: false,
                        userNotes: {} // Changed from string to object
                    };
                    console.log('[SMAX Tool] Created step with title:', title);
                    collectingCommand = false;
                    collectingNotes = false;
                    collectingSubsection = false;
                    commandBuffer = [];
                    notesBuffer = [];
                    subsectionBuffer = [];
                    currentSubsection = '';
                    rawBuffer = [line]; // Start collecting raw for this step
                    continue;
                }
            }
            
            // Regular content (step description/notes)
            if (currentStep && line.trim() !== '' && !collectingCommand && !collectingNotes) {
                if (line.trim() === '---') continue; // Skip separator lines
                if (currentStep.notes) {
                    currentStep.notes += '\n' + line.trim();
                } else {
                    currentStep.notes = line.trim();
                }
            }
        }
        
        // Add last step and stage
        if (currentStep && currentStage) {
            if (collectingNotes) {
                // Save Current notes if any
                if (!currentSubsection && notesBuffer.length > 0) {
                    currentStep.userNotes['Current'] = notesBuffer.join('\n').trim();
                }
                // Save any remaining subsection
                if (currentSubsection && subsectionBuffer.length > 0) {
                    currentStep.userNotes[currentSubsection] = subsectionBuffer.join('\n').trim();
                }
            }
            console.log('[SMAX Tool] Final userNotes for step', currentStep.title, ':', currentStep.userNotes);
            currentStep.rawMd = rawBuffer.join('\n');
            currentStage.steps.push(currentStep);
        }
        if (currentStage) {
            stages.push(currentStage);
        }
        
        return { title: documentTitle, stages: stages };
    }
    
    // NEW: Try to load markdown format
    async function tryLoadMarkdown(ver, client, mdPath) {
        try {
            let mdContent;
            
            if (GITHUB_TOKEN) {
                const resp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${mdPath}`, {
                    headers: { Authorization: `token ${GITHUB_TOKEN}` }
                });
                
                if (resp.status === 404) {
                    // File doesn't exist, try localStorage backup
                    const backup = localStorage.getItem('smax_config_backup');
                    if (backup) {
                        console.log('[SMAX Tool] File not found, loading from localStorage backup');
                        config = JSON.parse(backup);
                        CURRENT_YAML_PATH = mdPath;
                        currentStageIndex = 0;
                        renderTitle();
                        renderVars();
                        renderStageTabs();
                        renderCurrentStage();
                        updateProgress();
                        return true;
                    }
                    return false; // File doesn't exist, try YAML
                }
                
                if (!resp.ok) {
                    // Try localStorage backup
                    const backup = localStorage.getItem('smax_config_backup');
                    if (backup) {
                        console.log('[SMAX Tool] GitHub failed, loading from localStorage backup');
                        config = JSON.parse(backup);
                        CURRENT_YAML_PATH = mdPath;
                        currentStageIndex = 0;
                        renderTitle();
                        renderVars();
                        renderStageTabs();
                        renderCurrentStage();
                        updateProgress();
                        return true;
                    }
                    return false;
                }
                
                const data = await resp.json();
                FILE_SHA = data.sha;
                CURRENT_YAML_PATH = mdPath;
                
                // Use modern UTF-8 base64 decoding
                const binaryString = atob(data.content);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                mdContent = new TextDecoder('utf-8').decode(bytes);
            } else {
                const resp = await fetch(mdPath);
                if (!resp.ok) {
                    // Try localStorage backup
                    const backup = localStorage.getItem('smax_config_backup');
                    if (backup) {
                        console.log('[SMAX Tool] Local fetch failed, loading from localStorage backup');
                        config = JSON.parse(backup);
                        CURRENT_YAML_PATH = mdPath;
                        currentStageIndex = 0;
                        renderTitle();
                        renderVars();
                        renderStageTabs();
                        renderCurrentStage();
                        updateProgress();
                        return true;
                    }
                    return false;
                }
                CURRENT_YAML_PATH = mdPath;
                mdContent = await resp.text();
            }
            
            console.log(`[SMAX Tool] Loading markdown from ${mdPath}...`);
            
            // Parse markdown
            const { config: configData, markdown } = parseMarkdownFrontMatter(mdContent);
            const { title, stages } = parseMarkdownStages(markdown);
            
            config = {
                title: title,
                config: configData,
                stages: stages
            };
            
            console.log(`[SMAX Tool] Loaded title: "${title}", ${stages.length} stage(s) from markdown`);
            console.log('[SMAX Tool] Loaded config:', config);
            console.log('[SMAX Tool] First stage steps:', stages[0]?.steps?.length || 0);
            
            if (GITHUB_TOKEN) {
                document.getElementById('syncInd').classList.add('online');
                document.getElementById('syncStat').innerText = `Synced: ${ver}/${client}`;
            }
            
            currentStageIndex = 0;
            renderTitle();
            renderVars();
            renderStageTabs();
            renderCurrentStage();
            updateProgress();
            
            return true;
            
        } catch (e) {
            console.error('[SMAX Tool] Failed to load markdown:', e);
            // Try localStorage backup
            const backup = localStorage.getItem('smax_config_backup');
            if (backup) {
                console.log('[SMAX Tool] Error loading, using localStorage backup');
                config = JSON.parse(backup);
                CURRENT_YAML_PATH = mdPath;
                currentStageIndex = 0;
                renderTitle();
                renderVars();
                renderStageTabs();
                renderCurrentStage();
                updateProgress();
                return true;
            }
            return false;
        }
    }

    // NEW: Handle version change - refresh client list
    async function onVersionChange() {
        const ver = document.getElementById('selVer').value;
        if (!ver) return;
        
        // Cache selected version
        sessionStorage.setItem('selected_version', ver);
        
        await fetchClients(ver);
        // Don't auto-load data, wait for user to select a client
    }
    
    async function onProductChange() {
        const product = document.getElementById('selProduct').value;
        
        // Update app title
        const titleElement = document.getElementById('appTitle');
        titleElement.textContent = `${product} Multi-Tenant Operations`;
        
        // Cache selected product
        sessionStorage.setItem('selected_product', product);
        
        // Clear version and client selections when product changes
        document.getElementById('selVer').innerHTML = '<option value="">Select version...</option>';
        document.getElementById('selClient').innerHTML = '<option value="">Loading clients...</option>';
        
        // Clear cached selections for this product
        sessionStorage.removeItem('selected_version');
        sessionStorage.removeItem('selected_client');
        
        // Fetch folders for the new product
        await fetchFolders();
    }
    
    // Try to load from localStorage backup
    function tryLoadFromLocalStorage(ver, client) {
        try {
            const backup = localStorage.getItem('smax_config_backup');
            if (!backup) return false;
            
            const backupConfig = JSON.parse(backup);
            if (!backupConfig || !backupConfig.stages) return false;
            
            // Use the backup config
            config = backupConfig;
            CURRENT_YAML_PATH = `${getVersionsBasePath()}/${ver}/${client}.md`;
            
            console.log(`[SMAX Tool] Loaded backup config with ${config.stages.length} stage(s)`);
            
            currentStageIndex = 0;
            renderTitle();
            renderVars();
            renderStageTabs();
            renderCurrentStage();
            updateProgress();
            
            // Show offline indicator
            document.getElementById('syncInd').classList.remove('online');
            document.getElementById('syncStat').innerText = `Offline: ${ver}/${client} (local backup)`;
            
            return true;
        } catch (e) {
            console.error('[SMAX Tool] Failed to load from localStorage:', e);
            return false;
        }
    }

    async function loadData() {
        showError(""); 
        const ver = document.getElementById('selVer').value;
        const client = document.getElementById('selClient').value;
        
        if (!ver || !client) {
            console.log('[SMAX Tool] Waiting for version and client to be selected...');
            return;
        }

        // Cache selected client
        sessionStorage.setItem('selected_client', client);

        // Only support markdown format now
        const basePath = getVersionsBasePath();
        const mdPath = `${basePath}/${ver}/${client}.md`;
        
        // Try markdown first
        if (await tryLoadMarkdown(ver, client, mdPath)) {
            renderTitle();
            return;
        }
        
        // Try loading from localStorage backup
        if (tryLoadFromLocalStorage(ver, client)) {
            console.log('[SMAX Tool] Loaded from localStorage backup');
            renderTitle();
            return;
        }
        
        // If no markdown, check for YAML and migrate
        const yamlPath = `${basePath}/${ver}/${client}.yaml`;
        console.log(`[SMAX Tool] No markdown found, checking for YAML to migrate...`);
        
        try {
            let yamlContent;
            let yamlSha = "";
            
            if (GITHUB_TOKEN) {
                const resp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${yamlPath}`, {
                    headers: { Authorization: `token ${GITHUB_TOKEN}` }
                });
                
                if (resp.status === 404) {
                    // Try to migrate from old format
                    console.log('[SMAX Tool] YAML not found, attempting migration from old format...');
                    await migrateFromOldFormat(ver, client);
                    return;
                }
                
                if (!resp.ok) {
                    const errorData = await resp.json();
                    throw new Error(`GitHub API: ${errorData.message || resp.statusText}`);
                }
                
                const data = await resp.json();
                yamlSha = data.sha;
                
                // Use modern UTF-8 base64 decoding
                const binaryString = atob(data.content);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                yamlContent = new TextDecoder('utf-8').decode(bytes);
            } else {
                const resp = await fetch(yamlPath);
                if (!resp.ok) throw new Error(`No configuration found for ${client}`);
                yamlContent = await resp.text();
            }
            
            // Parse YAML
            let yamlConfig = jsyaml.load(yamlContent);
            
            if (!yamlConfig) {
                throw new Error('Invalid YAML structure');
            }
            
            // Convert old 'steps' to 'stages'
            if (yamlConfig.steps && !yamlConfig.stages) {
                console.log('[SMAX Tool] Converting old steps format to stages...');
                yamlConfig.stages = [{
                    name: 'Upgrade',
                    steps: yamlConfig.steps
                }];
                delete yamlConfig.steps;
            }
            
            // Migrate to markdown
            console.log('[SMAX Tool] Migrating YAML to Markdown format...');
            config = {
                title: yamlConfig.title || `${client} Upgrade`,
                config: yamlConfig.config || {},
                stages: yamlConfig.stages || []
            };
            
            // Save as markdown
            CURRENT_YAML_PATH = mdPath;
            FILE_SHA = ""; // New file
            await saveData();
            
            console.log('[SMAX Tool] Migration complete, reloading...');
            await loadData();
            
        } catch (e) {
            console.error('[SMAX Tool] loadData error:', e);
            showError(e.message);
        }
    }
    
    // NEW: Migrate from old format to new markdown format
    async function migrateFromOldFormat(ver, client) {
        try {
            console.log('[SMAX Tool] Migrating from old format...');
            
            // Try to load old managed or embedded steps file
            const basePath = getVersionsBasePath();
            let oldStepsPath = `${basePath}/${ver}/${client}-managed-steps.yaml`;
            let oldStatePath = `${basePath}/${ver}/state-${client}.yaml`;
            
            let stepsResp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${oldStepsPath}`, {
                headers: { Authorization: `token ${GITHUB_TOKEN}` }
            });
            
            if (stepsResp.status === 404) {
                // Try embedded format
                oldStepsPath = `${basePath}/${ver}/${client}-embedded-steps.yaml`;
                stepsResp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${oldStepsPath}`, {
                    headers: { Authorization: `token ${GITHUB_TOKEN}` }
                });
            }
            
            if (!stepsResp.ok) {
                throw new Error(`No client configuration found for ${client}`);
            }
            
            const stepsData = await stepsResp.json();
            const oldConfig = jsyaml.load(atob(stepsData.content));
            
            // Load old state file if exists
            let state = {};
            const stateResp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${oldStatePath}`, {
                headers: { Authorization: `token ${GITHUB_TOKEN}` }
            });
            
            if (stateResp.ok) {
                const stateData = await stateResp.json();
                state = jsyaml.load(atob(stateData.content)) || {};
            }
            
            // Create new unified config in markdown format
            config = {
                title: `${client} Upgrade to v${ver}`,
                config: oldConfig.config || {},
                stages: [{
                    name: 'Upgrade',
                    steps: (oldConfig.steps || []).map(step => {
                        return {
                            ...step,
                            done: state[`s_done_${step.id}`] === 'true',
                            userNotes: ''
                        };
                    })
                }]
            };
            
            // Apply variable state
            Object.keys(config.config).forEach(key => {
                if (state[`v_${key}`]) {
                    config.config[key] = state[`v_${key}`];
                }
            });
            
            // Save as markdown
            CURRENT_YAML_PATH = `${basePath}/${ver}/${client}.md`;
            FILE_SHA = ""; // Will create new file
            await saveData();
            
            console.log('[SMAX Tool] Migration complete, reloading...');
            await loadData();
            
        } catch (e) {
            console.error('[SMAX Tool] Migration error:', e);
            showError(`Migration failed: ${e.message}`);
        }
    }

    // Error handling with better logging
    function showError(msg) {
        const box = document.getElementById('errorBox');
        if (msg) {
            console.error('[SMAX Tool Error]:', msg);
            box.innerText = `‚ö†Ô∏è Error: ${msg}`;
            box.style.display = 'block';
        } else {
            box.style.display = 'none';
        }
    }

    // Render environment variables
    function renderVars() {
        const varInputs = document.getElementById('var-inputs');
        varInputs.innerHTML = '';
        
        if (!config.config) return;
        
        Object.entries(config.config).forEach(([key, defaultVal]) => {
            const wrapper = document.createElement('div');
            wrapper.style.display = 'flex';
            wrapper.style.alignItems = 'center';
            wrapper.style.gap = '8px';
            wrapper.style.marginBottom = '8px';
            
            // Create label
            const label = document.createElement('label');
            label.style.fontSize = '14px';
            label.style.color = 'var(--text)';
            label.style.opacity = '0.7';
            label.style.minWidth = '120px';
            label.style.flexShrink = '0';
            label.style.cursor = 'pointer';
            label.style.userSelect = 'none';
            label.textContent = key + ':';
            label.title = 'Click to copy value';
            label.onclick = function() {
                const input = document.getElementById(`var_${key}`);
                if (input) {
                    copyToClipboard(input.value);
                    // Visual feedback
                    const originalText = label.textContent;
                    label.textContent = 'üìã Copied!';
                    label.style.color = 'var(--primary)';
                    setTimeout(() => {
                        label.textContent = originalText;
                        label.style.color = 'var(--text)';
                        label.style.opacity = '0.7';
                    }, 1000);
                }
            };
            
            // Create input
            const input = document.createElement('input');
            input.type = 'text';
            input.id = `var_${key}`;
            input.value = defaultVal;
            input.style.flex = '1';
            input.style.boxSizing = 'border-box';
            input.onchange = function() {
                config.config[key] = this.value;
            };
            
            wrapper.appendChild(label);
            wrapper.appendChild(input);
            varInputs.appendChild(wrapper);
        });
    }
    
    // NEW: Render stage tabs
    function renderStageTabs() {
        const container = document.getElementById('stage-tabs-container');
        container.innerHTML = '';
        container.style.display = 'flex';
        
        if (!config.stages || config.stages.length === 0) {
            container.style.display = 'none';
            return;
        }
        
        config.stages.forEach((stage, index) => {
            const tab = document.createElement('div');
            tab.className = 'stage-tab';
            if (index === currentStageIndex) {
                tab.className += ' active';
            }
            
            // Calculate completion for this stage
            const totalSteps = stage.steps.length;
            const completedSteps = stage.steps.filter(s => s.done).length;
            
            const stageName = document.createElement('div');
            stageName.textContent = stage.name;
            stageName.className = 'editable';
            stageName.ondblclick = (e) => {
                e.stopPropagation();
                editStageName(index);
            };
            stageName.title = 'Double-click to edit';
            
            const stageInfo = document.createElement('div');
            stageInfo.style.fontSize = '11px';
            stageInfo.style.color = '#586069';
            stageInfo.style.marginTop = '3px';
            stageInfo.textContent = `${completedSteps}/${totalSteps} steps`;
            
            tab.appendChild(stageName);
            tab.appendChild(stageInfo);
            
            tab.onclick = () => {
                currentStageIndex = index;
                renderStageTabs();
                renderCurrentStage();
                updateProgress();
            };
            
            container.appendChild(tab);
        });
    }
    
    // NEW: Render current stage
    function renderCurrentStage() {
        if (!config.stages || config.stages.length === 0) {
            document.getElementById('steps-list').innerHTML = '<p style="color:#586069;">No stages found.</p>';
            document.getElementById('stage-nav').style.display = 'none';
            document.getElementById('stage-nav-bottom').style.display = 'none';
            return;
        }
        
        const stage = config.stages[currentStageIndex];
        renderSteps(stage.steps, currentStageIndex);
        
        // Update navigation buttons
        document.getElementById('stage-nav').style.display = 'flex';
        document.getElementById('stage-nav-bottom').style.display = 'flex';
        
        const prevBtn = document.getElementById('prev-stage-btn');
        const nextBtn = document.getElementById('next-stage-btn');
        const prevBtnBottom = document.getElementById('prev-stage-btn-bottom');
        const nextBtnBottom = document.getElementById('next-stage-btn-bottom');
        
        prevBtn.disabled = currentStageIndex === 0;
        nextBtn.disabled = currentStageIndex === config.stages.length - 1;
        prevBtnBottom.disabled = currentStageIndex === 0;
        nextBtnBottom.disabled = currentStageIndex === config.stages.length - 1;
    }
    
    // NEW: Stage navigation
    function prevStage() {
        if (currentStageIndex > 0) {
            currentStageIndex--;
            renderStageTabs();
            renderCurrentStage();
            updateProgress();
            window.scrollTo(0, 0);
        }
    }
    
    function nextStage() {
        if (currentStageIndex < config.stages.length - 1) {
            currentStageIndex++;
            renderStageTabs();
            renderCurrentStage();
            updateProgress();
            window.scrollTo(0, 0);
        }
    }
    
    // NEW: Update progress indicator
    function updateProgress() {
        if (!config.stages || config.stages.length === 0) {
            document.getElementById('progress-container').style.display = 'none';
            return;
        }
        
        document.getElementById('progress-container').style.display = 'block';
        
        // Calculate total progress across all stages
        let totalSteps = 0;
        let completedSteps = 0;
        
        config.stages.forEach(stage => {
            totalSteps += stage.steps.length;
            completedSteps += stage.steps.filter(s => s.done).length;
        });
        
        const percentage = totalSteps > 0 ? (completedSteps / totalSteps * 100).toFixed(0) : 0;
        
        document.getElementById('progress-fill').style.width = `${percentage}%`;
        document.getElementById('progress-text').textContent = `${completedSteps} of ${totalSteps} steps completed (${percentage}%)`;
    }

    // Copy to clipboard function
    function copyToClipboard(text) {
        if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(text).then(() => {
                console.log('[SMAX Tool] Copied to clipboard');
                // Visual feedback could be added here
            }).catch(err => {
                console.error('[SMAX Tool] Failed to copy:', err);
                fallbackCopy(text);
            });
        } else {
            fallbackCopy(text);
        }
    }

    // Fallback copy method for older browsers
    function fallbackCopy(text) {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.select();
        try {
            // Note: execCommand is deprecated but kept as fallback for legacy browser support
            document.execCommand('copy');
            console.log('[SMAX Tool] Copied using fallback method');
        } catch (err) {
            console.error('[SMAX Tool] Fallback copy failed:', err);
            showError('Copy failed. Please copy manually.');
        }
        document.body.removeChild(textarea);
    }

    // Replace placeholders in commands with actual values
    // Replace placeholders in commands with actual values
    // Supports both {{variable}} and <variable> formats
    function interpolate(str) {
        if (!str) return '';
        let result = str;
        Object.keys(config.config || {}).forEach(key => {
            const val = config.config[key] || '';
            const styledVal = `<span style="color: #ffa500; font-weight: bold; background-color: rgba(255, 165, 0, 0.1); padding: 2px 4px; border-radius: 3px;">${val}</span>`;
            // Replace {{key}} format
            result = result.replace(new RegExp(`{{${key}}}`, 'g'), styledVal);
            // Replace <key> format (case-insensitive)
            result = result.replace(new RegExp(`<${key}>`, 'gi'), styledVal);
            // Also try uppercase version for <KEY> format
            const upperKey = key.toUpperCase();
            result = result.replace(new RegExp(`<${upperKey}>`, 'g'), styledVal);
            // Handle HTML-encoded versions (&lt;key&gt;)
            result = result.replace(new RegExp(`&lt;${key}&gt;`, 'gi'), styledVal);
            result = result.replace(new RegExp(`&lt;${upperKey}&gt;`, 'g'), styledVal);
            // Handle Prism-tokenized versions (<span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>)
            const tokenizedPattern = `<span class="token operator">&lt;</span>${key}<span class="token operator">&gt;</span>`;
            result = result.replace(new RegExp(tokenizedPattern, 'gi'), styledVal);
            const tokenizedUpperPattern = `<span class="token operator">&lt;</span>${upperKey}<span class="token operator">&gt;</span>`;
            result = result.replace(new RegExp(tokenizedUpperPattern, 'g'), styledVal);
        });
        return result;
    }

    // Render steps with checkboxes, inline editing, and minimal notes UI
    function renderSteps(steps, stageIndex) {
        console.log('[SMAX Tool] renderSteps called with', steps ? steps.length : 0, 'steps for stage', stageIndex);
        const stepsList = document.getElementById('steps-list');
        console.log('[SMAX Tool] stepsList element:', stepsList);
        stepsList.innerHTML = '';
        console.log('[SMAX Tool] stepsList cleared');
        
        if (!steps || steps.length === 0) {
            stepsList.innerHTML = '<p style="color:#586069;">No steps in this stage.</p>';
            document.getElementById('add-step-container').style.display = 'block';
            return;
        }
        
        document.getElementById('add-step-container').style.display = 'block';
        
        steps.forEach((step, stepIndex) => {
            console.log(`[SMAX Tool] Rendering step ${stepIndex}:`, step.title, 'notes length:', step.notes ? step.notes.length : 0);
            const isDone = step.done || false;
            const card = document.createElement('div');
            card.className = `card ${isDone ? 'step-done' : ''}`;
            card.id = `step_${stageIndex}_${stepIndex}`;
            
            // Header with checkbox and title
            const header = document.createElement('div');
            header.style.display = 'flex';
            header.style.justifyContent = 'space-between';
            header.style.alignItems = 'center';
            header.style.marginBottom = '12px';
            
            const leftSection = document.createElement('div');
            leftSection.style.display = 'flex';
            leftSection.style.alignItems = 'center';
            leftSection.style.gap = '8px';
            leftSection.style.flex = '1';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `check_${stageIndex}_${stepIndex}`;
            checkbox.checked = isDone;
            checkbox.style.width = '18px';
            checkbox.style.height = '18px';
            checkbox.style.cursor = 'pointer';
            checkbox.onchange = function() {
                toggleStep(stageIndex, stepIndex, this.checked);
            };
            
            const title = document.createElement('strong');
            title.className = 'editable';
            title.style.fontSize = '16px';
            title.style.cursor = 'pointer';
            title.textContent = step.title || 'Untitled Step';
            
            leftSection.appendChild(checkbox);
            leftSection.appendChild(title);
            
            // Right section with notes button and edit buttons
            const rightSection = document.createElement('div');
            rightSection.style.display = 'flex';
            rightSection.style.gap = '6px';
            
            // Edit button
            const editBtn = document.createElement('button');
            editBtn.className = 'note-toggle-btn';
            editBtn.innerHTML = 'üìù Edit';
            editBtn.title = 'Edit step';
            editBtn.onclick = () => editStep(stageIndex, stepIndex);
            
            // Minimal notes button
            const notesBtn = document.createElement('button');
            notesBtn.className = `note-toggle-btn ${step.userNotes && Object.keys(step.userNotes).length > 0 ? 'has-notes' : ''}`;
            notesBtn.innerHTML = step.userNotes && Object.keys(step.userNotes).length > 0 ? 'üí¨ Notes' : 'üí¨';
            notesBtn.title = step.userNotes && Object.keys(step.userNotes).length > 0 ? 'View/Edit notes' : 'Add notes';
            notesBtn.onclick = () => toggleNoteEditor(stageIndex, stepIndex);
            
            rightSection.appendChild(editBtn);
            rightSection.appendChild(notesBtn);
            
            header.appendChild(leftSection);
            header.appendChild(rightSection);
            card.appendChild(header);
            
            // Create combined markdown content for the step (notes and command only)
            let stepMarkdown = '';

            // Add notes content, but strip any leading H3 header that matches the step title
            if (step.notes) {
                let notesContent = step.notes.trim();
                // Remove leading H3 header if it matches the step title
                const h3Pattern = new RegExp(`^### ${step.title.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*\\n`, 'm');
                notesContent = notesContent.replace(h3Pattern, '');
                // Interpolate variables in the step content - moved to after parsing
                // notesContent = interpolate(notesContent);
                stepMarkdown += `${notesContent}\n\n`;
            }

            // Add command as code block if present
            if (step.command) {
                // Interpolate variables in the command - now handled in renderer
                // const interpolatedCommand = interpolate(step.command);
                stepMarkdown += `\`\`\`bash\n${step.command}\n\`\`\`\n\n`;
            }

            // Render the combined markdown content
            if (stepMarkdown.trim()) {
                console.log(`[SMAX Tool] Step ${stepIndex} rendering markdown:`, stepMarkdown.trim().substring(0, 200) + '...');
                const contentDiv = document.createElement('div');
                contentDiv.className = 'step-content';
                contentDiv.style.color = 'var(--text)';
                contentDiv.style.marginBottom = '12px';
                const parsedHTML = marked.parse(stepMarkdown.trim());
                console.log(`[SMAX Tool] Step ${stepIndex} parsed HTML length:`, parsedHTML.length);
                // Interpolate variables in the parsed HTML
                const interpolatedHTML = interpolate(parsedHTML);
                contentDiv.innerHTML = interpolatedHTML;
                
                // Add copy buttons to all code blocks
                const preElements = Array.from(contentDiv.querySelectorAll('pre'));
                console.log(`[SMAX Tool] Step ${stepIndex} found ${preElements.length} code blocks`);
                preElements.forEach((pre, index) => {
                    // Create wrapper for pre and button
                    const wrapper = document.createElement('div');
                    wrapper.style.position = 'relative';
                    wrapper.style.marginBottom = '10px';
                    
                    // Replace pre with wrapper
                    pre.parentNode.replaceChild(wrapper, pre);
                    wrapper.appendChild(pre);
                    
                    // Add copy button
                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'copy-btn';
                    copyBtn.textContent = 'Copy';
                    copyBtn.style.position = 'absolute';
                    copyBtn.style.top = '8px';
                    copyBtn.style.right = '8px';
                    copyBtn.style.zIndex = '10';
                    copyBtn.onclick = function(e) {
                        e.stopPropagation();
                        const code = pre.querySelector('code');
                        if (code) {
                            copyToClipboard(code.textContent);
                            // Add visual feedback
                            const originalText = copyBtn.textContent;
                            copyBtn.textContent = 'Copied!';
                            copyBtn.style.background = '#28a745'; // Green for success
                            setTimeout(() => {
                                copyBtn.textContent = originalText;
                                copyBtn.style.background = '#0366d6'; // Back to original
                            }, 2000);
                        }
                    };
                    wrapper.appendChild(copyBtn);
                });
                
                card.appendChild(contentDiv);
                console.log(`[SMAX Tool] Step ${stepIndex} contentDiv added to card`);
            } else {
                console.log(`[SMAX Tool] Step ${stepIndex} has no markdown content to render`);
            }
            
            // Syntax highlighting is now handled by marked.js highlight function
            
            // Collapsible note section - shows preview by default
            const noteEditor = document.createElement('div');
            noteEditor.className = 'note-editor';
            noteEditor.id = `note-editor_${stageIndex}_${stepIndex}`;
            noteEditor.style.marginTop = '15px';
            noteEditor.style.borderTop = '1px solid var(--border)';
            noteEditor.style.paddingTop = '15px';
            
            // Show the editor if there are notes
            if (step.userNotes && Object.keys(step.userNotes).length > 0) {
                noteEditor.classList.add('active');
            }
            
            // Container for content (preview or textarea)
            const noteContent = document.createElement('div');
            noteContent.id = `note-content_${stageIndex}_${stepIndex}`;
            
            // Live preview (shown by default)
            const notePreview = document.createElement('div');
            notePreview.className = 'note-preview';
            notePreview.id = `note-preview_${stageIndex}_${stepIndex}`;
            notePreview.style.marginBottom = '10px';
            if (step.userNotes && Object.keys(step.userNotes).length > 0) {
                // Render each version in its own block
                notePreview.innerHTML = '';
                for (const [version, content] of Object.entries(step.userNotes)) {
                    if (content && content.trim()) {
                        const versionBlock = document.createElement('div');
                        versionBlock.className = 'note-version-block';
                        versionBlock.style.border = '1px solid var(--border)';
                        versionBlock.style.borderRadius = '6px';
                        versionBlock.style.padding = '10px';
                        versionBlock.style.marginBottom = '8px';
                        versionBlock.style.backgroundColor = 'var(--bg)';
                        
                        const versionHeader = document.createElement('div');
                        versionHeader.style.fontWeight = 'bold';
                        versionHeader.style.marginBottom = '8px';
                        versionHeader.style.color = 'var(--primary)';
                        versionHeader.textContent = version === 'Current' ? 'üìù Current Notes' : `üìö ${version} Notes`;
                        
                        const versionContent = document.createElement('div');
                        versionContent.innerHTML = marked.parse(content);
                        
                        versionBlock.appendChild(versionHeader);
                        versionBlock.appendChild(versionContent);
                        notePreview.appendChild(versionBlock);
                    }
                }
            } else {
                notePreview.innerHTML = '<span style="color: #586069; font-style: italic;">No notes yet. Click Edit to add some.</span>';
            }
            
            // Textarea (hidden by default)
            const noteTextarea = document.createElement('textarea');
            noteTextarea.id = `note-textarea_${stageIndex}_${stepIndex}`;
            noteTextarea.disabled = false;
            noteTextarea.readOnly = false;
            noteTextarea.value = step.userNotes && Object.keys(step.userNotes).length > 0 ? userNotesToMarkdown(step.userNotes) : '';
            noteTextarea.placeholder = 'Enter notes in Markdown format...\n\nUse #### Notes to start the notes section\nUse ##### SubsectionName for subsections\n\nExample:\n#### Notes\n\n##### Current\n\nMy current notes here\n\n##### 24.4\n\nNotes from version 24.4\n\nYou can:\n- Paste images directly (Ctrl+V)\n- Drag and drop images\n- Use **bold**, *italic*, lists, etc.';
            noteTextarea.rows = 6;
            noteTextarea.style.marginBottom = '10px';
            noteTextarea.style.display = 'none';
            
            // Setup image paste/drop
            setupImagePaste(noteTextarea);
            
            // Update preview on input
            noteTextarea.oninput = () => {
                const preview = document.getElementById(`note-preview_${stageIndex}_${stepIndex}`);
                if (preview) {
                    if (noteTextarea.value) {
                        // Parse the current textarea content and show blocks
                        const parsedNotes = markdownToUserNotes(noteTextarea.value);
                        if (Object.keys(parsedNotes).length > 0) {
                            preview.innerHTML = '';
                            for (const [version, content] of Object.entries(parsedNotes)) {
                                if (content && content.trim()) {
                                    const versionBlock = document.createElement('div');
                                    versionBlock.className = 'note-version-block';
                                    versionBlock.style.border = '1px solid var(--border)';
                                    versionBlock.style.borderRadius = '6px';
                                    versionBlock.style.padding = '10px';
                                    versionBlock.style.marginBottom = '8px';
                                    versionBlock.style.backgroundColor = 'var(--bg)';
                                    
                                    const versionHeader = document.createElement('div');
                                    versionHeader.style.fontWeight = 'bold';
                                    versionHeader.style.marginBottom = '8px';
                                    versionHeader.style.color = 'var(--primary)';
                                    versionHeader.textContent = version === 'Current' ? 'üìù Current Notes' : `üìö ${version} Notes`;
                                    
                                    const versionContent = document.createElement('div');
                                    const parsedHTML = marked.parse(content);
                                    versionContent.innerHTML = parsedHTML;
                                    
                                    versionBlock.appendChild(versionHeader);
                                    versionBlock.appendChild(versionContent);
                                    preview.appendChild(versionBlock);
                                }
                            }
                        } else {
                            preview.innerHTML = marked.parse(noteTextarea.value);
                        }
                    } else {
                        preview.innerHTML = '<span style="color: #586069; font-style: italic;">No notes yet. Click Edit to add some.</span>';
                    }
                }
            };
            
            noteContent.appendChild(notePreview);
            noteContent.appendChild(noteTextarea);
            
            const noteButtons = document.createElement('div');
            noteButtons.style.display = 'flex';
            noteButtons.style.gap = '10px';
            
            const editNoteBtn = document.createElement('button');
            editNoteBtn.textContent = '‚úèÔ∏è Edit';
            editNoteBtn.style.padding = '8px 16px';
            editNoteBtn.style.border = '1px solid var(--border)';
            editNoteBtn.style.borderRadius = '6px';
            editNoteBtn.style.cursor = 'pointer';
            editNoteBtn.style.background = 'var(--card-bg)';
            editNoteBtn.style.color = 'var(--text)';
            editNoteBtn.onclick = () => toggleNoteEdit(stageIndex, stepIndex);
            
            const saveNoteBtn = document.createElement('button');
            saveNoteBtn.textContent = 'üíæ Save Note';
            saveNoteBtn.style.background = 'var(--primary)';
            saveNoteBtn.style.color = 'white';
            saveNoteBtn.style.border = 'none';
            saveNoteBtn.style.padding = '8px 16px';
            saveNoteBtn.style.borderRadius = '6px';
            saveNoteBtn.style.cursor = 'pointer';
            saveNoteBtn.onclick = () => saveNote(stageIndex, stepIndex);
            
            const cancelNoteBtn = document.createElement('button');
            cancelNoteBtn.textContent = 'Cancel';
            cancelNoteBtn.style.padding = '8px 16px';
            cancelNoteBtn.style.border = '1px solid var(--border)';
            cancelNoteBtn.style.borderRadius = '6px';
            cancelNoteBtn.style.cursor = 'pointer';
            cancelNoteBtn.style.background = 'var(--card-bg)';
            cancelNoteBtn.style.color = 'var(--text)';
            cancelNoteBtn.onclick = () => toggleNoteEditor(stageIndex, stepIndex);
            
            noteButtons.appendChild(editNoteBtn);
            noteButtons.appendChild(saveNoteBtn);
            noteButtons.appendChild(cancelNoteBtn);
            
            noteEditor.appendChild(noteContent);
            noteEditor.appendChild(noteButtons);
            
            card.appendChild(noteEditor);
            console.log(`[SMAX Tool] Step ${stepIndex} card completed, appending to stepsList`);
            stepsList.appendChild(card);
        });
    }
    
    // NEW: Toggle note editor
    function toggleNoteEditor(stageIndex, stepIndex) {
        const editor = document.getElementById(`note-editor_${stageIndex}_${stepIndex}`);
        if (editor) {
            editor.classList.toggle('active');
        }
    }
    
    function toggleNoteEdit(stageIndex, stepIndex) {
        const step = config.stages[stageIndex].steps[stepIndex];
        const currentNotes = step.userNotes && step.userNotes['Current'] ? step.userNotes['Current'] : '';
        
        // Use unified editor for notes
        showUnifiedEditor('notes', currentNotes, { stageIndex, stepIndex });
        
        // Override the save function for notes context
        currentEditorConfig.save = (data) => {
            if (!config.stages[stageIndex].steps[stepIndex].userNotes) {
                config.stages[stageIndex].steps[stepIndex].userNotes = {};
            }
            config.stages[stageIndex].steps[stepIndex].userNotes['Current'] = data;
            renderCurrentStage();
            triggerAutosave();
            showSuccess('Notes updated');
        };
    }
    
    // NEW: Save note
    function saveNote(stageIndex, stepIndex) {
        console.log('[SMAX Tool] saveNote called with stageIndex:', stageIndex, 'stepIndex:', stepIndex);
        
        const textarea = document.getElementById(`note-textarea_${stageIndex}_${stepIndex}`);
        const preview = document.getElementById(`note-preview_${stageIndex}_${stepIndex}`);
        
        if (!textarea) {
            console.error('[SMAX Tool] Textarea not found for step', stepIndex);
            return;
        }
        
        console.log('[SMAX Tool] Textarea value:', textarea.value);
        console.log('[SMAX Tool] Textarea value length:', textarea.value.length);
        
        console.log('[SMAX Tool] Config structure:', {
            hasStages: !!config.stages,
            stagesLength: config.stages ? config.stages.length : 'N/A',
            stageIndex: stageIndex,
            hasCurrentStage: config.stages && config.stages[stageIndex],
            currentStageSteps: config.stages && config.stages[stageIndex] ? config.stages[stageIndex].steps : 'N/A',
            stepIndex: stepIndex
        });
        
        // Parse the markdown back into structured userNotes object
        config.stages[stageIndex].steps[stepIndex].userNotes = markdownToUserNotes(textarea.value);
        
        console.log('[SMAX Tool] Parsed userNotes:', config.stages[stageIndex].steps[stepIndex].userNotes);
        
        // Update preview immediately
        if (preview) {
            const userNotes = config.stages[stageIndex].steps[stepIndex].userNotes;
            if (userNotes && Object.keys(userNotes).length > 0) {
                // Render each version in its own block
                preview.innerHTML = '';
                for (const [version, content] of Object.entries(userNotes)) {
                    if (content && content.trim()) {
                        const versionBlock = document.createElement('div');
                        versionBlock.className = 'note-version-block';
                        versionBlock.style.border = '1px solid var(--border)';
                        versionBlock.style.borderRadius = '6px';
                        versionBlock.style.padding = '10px';
                        versionBlock.style.marginBottom = '8px';
                        versionBlock.style.backgroundColor = 'var(--bg)';
                        
                        const versionHeader = document.createElement('div');
                        versionHeader.style.fontWeight = 'bold';
                        versionHeader.style.marginBottom = '8px';
                        versionHeader.style.color = 'var(--primary)';
                        versionHeader.textContent = version === 'Current' ? 'üìù Current Notes' : `üìö ${version} Notes`;
                        
                        const versionContent = document.createElement('div');
                        versionContent.innerHTML = marked.parse(content);
                        
                        versionBlock.appendChild(versionHeader);
                        versionBlock.appendChild(versionContent);
                        preview.appendChild(versionBlock);
                    }
                }
            } else {
                preview.innerHTML = '<span style="color: #586069; font-style: italic;">No notes yet. Click Edit to add some.</span>';
            }
        }
        
        // Switch back to preview mode
        const content = document.getElementById(`note-content_${stageIndex}_${stepIndex}`);
        if (content) {
            content.classList.remove('editing');
        }
        
        if (textarea) {
            textarea.style.display = 'none';
        }
        
        // Close editor and re-render to update button and preview
        toggleNoteEditor(stageIndex, stepIndex);
        renderCurrentStage();
        
        console.log('[SMAX Tool] Note saved for step', stepIndex);
        // Save to localStorage as backup
        try {
            localStorage.setItem('smax_config_backup', JSON.stringify(config));
            console.log('[SMAX Tool] Notes saved to localStorage backup');
            
            // Show temporary success message
            const status = document.getElementById('autosave-status');
            if (status) {
                status.textContent = 'Notes saved locally';
                status.style.color = 'var(--primary)';
                setTimeout(() => {
                    status.textContent = 'Autosave enabled';
                    status.style.color = '';
                }, 2000);
            }
        } catch (e) {
            console.error('[SMAX Tool] Failed to save to localStorage:', e);
        }
        
        // Try to save to GitHub
        if (GITHUB_TOKEN && CURRENT_YAML_PATH) {
            saveData();
        } else {
            console.log('[SMAX Tool] GitHub not connected, notes saved locally only');
            // Update status to show local save
            const status = document.getElementById('autosave-status');
            if (status) {
                status.textContent = 'Saved locally (GitHub not connected)';
                status.style.color = '#d73a49'; // Red color for warning
                setTimeout(() => {
                    status.textContent = 'Autosave enabled';
                    status.style.color = '';
                }, 3000);
            }
        }
    }

    // Toggle step completion status
    function toggleStep(stageIndex, stepIndex, checked) {
        config.stages[stageIndex].steps[stepIndex].done = checked;
        const card = document.getElementById(`step_${stageIndex}_${stepIndex}`);
        if (card) {
            if (checked) {
                card.classList.add('step-done');
            } else {
                card.classList.remove('step-done');
            }
        }
        console.log(`[SMAX Tool] Step ${stepIndex} in stage ${stageIndex} marked as ${checked ? 'done' : 'pending'}`);
        
        // Update progress and stage tabs
        updateProgress();
        renderStageTabs();
        triggerAutosave();
    }
    
    // Toggle environment variables sidebar
    function toggleEnvVars() {
        const card = document.getElementById('env-vars-card');
        const btn = document.getElementById('envToggleBtn');
        card.classList.toggle('open');
        const isOpen = card.classList.contains('open');
        if (isOpen) {
            card.style.display = 'block';
            btn.textContent = '‚öôÔ∏è Variables';
        } else {
            setTimeout(() => card.style.display = 'none', 300); // Hide after animation
            btn.textContent = '‚öôÔ∏è Variables';
        }
        // Save state to localStorage
        localStorage.setItem('envVarsOpen', isOpen);
    }
    
    function closeEnvVars() {
        const card = document.getElementById('env-vars-card');
        const btn = document.getElementById('envToggleBtn');
        card.classList.remove('open');
        setTimeout(() => card.style.display = 'none', 300);
        btn.textContent = '‚öôÔ∏è Variables';
    }
    
    function editEnvVars() {
        const modal = document.getElementById('editEnvVarsModal');
        const textarea = document.getElementById('editEnvVarsContent');
        textarea.value = jsyaml.dump(config.config || {});
        modal.style.display = 'block';
    }
    
    function closeEditEnvVars() {
        document.getElementById('editEnvVarsModal').style.display = 'none';
    }
    
    function saveEditEnvVars() {
        const content = document.getElementById('editEnvVarsContent').value;
        try {
            const newConfig = jsyaml.load(content);
            config.config = newConfig;
            renderVars();
            triggerAutosave();
            closeEditEnvVars();
            showSuccess('Environment variables updated');
        } catch (e) {
            showError(`Invalid YAML: ${e.message}`);
        }
    }
    
    // Toggle client menu sidebar
    function toggleClientMenu() {
        const card = document.getElementById('client-menu-card');
        const btn = document.getElementById('menuToggleBtn');
        const isOpen = card.style.display === 'none' || card.style.display === '';
        if (isOpen) {
            card.style.display = 'block';
            btn.textContent = 'üìÅ Menu';
        } else {
            card.style.display = 'none';
            btn.textContent = 'üìÅ Menu';
        }
        // Save state to localStorage
        localStorage.setItem('clientMenuOpen', isOpen);
    }
    
    function closeClientMenu() {
        const card = document.getElementById('client-menu-card');
        const btn = document.getElementById('menuToggleBtn');
        card.classList.remove('open');
        setTimeout(() => card.style.display = 'none', 300);
        btn.textContent = 'üìÅ Menu';
    }
    
    // Render client menu
    function renderClientMenu() {
        const content = document.getElementById('client-menu-content');
        
        // Preserve current expansion states before re-rendering
        const expandedVersions = new Set();
        Object.keys(menuData).forEach(version => {
            const submenu = document.getElementById(`submenu_${version}`);
            if (submenu && submenu.style.display === 'block') {
                expandedVersions.add(version);
            }
        });
        
        content.innerHTML = '';
        
        const currentVersion = document.getElementById('selVer').value;
        
        Object.keys(menuData).forEach(version => {
            const versionDiv = document.createElement('div');
            versionDiv.className = 'menu-item';
            versionDiv.textContent = `üìÅ ${version}`;
            versionDiv.onclick = () => toggleVersionMenu(version);
            
            const clientList = document.createElement('div');
            clientList.className = 'submenu';
            clientList.id = `submenu_${version}`;
            clientList.style.display = 'none'; // collapsed by default
            
            menuData[version].forEach(client => {
                const clientDiv = document.createElement('div');
                clientDiv.className = 'menu-item';
                clientDiv.textContent = `üìÑ ${client}`;
                clientDiv.onclick = () => selectClient(version, client);
                clientList.appendChild(clientDiv);
            });
            
            // Show if it's the current version OR was previously expanded
            if (version === currentVersion || expandedVersions.has(version)) {
                clientList.style.display = 'block';
            }
            
            versionDiv.appendChild(clientList);
            content.appendChild(versionDiv);
        });
    }
    
    // Toggle version submenu
    async function toggleVersionMenu(version) {
        // If no clients loaded, fetch them
        if (menuData[version].length === 0) {
            await fetchClients(version);
        }
        
        // Toggle behavior: expand/collapse clicked version without affecting others
        const submenu = document.getElementById(`submenu_${version}`);
        if (submenu) {
            submenu.style.display = submenu.style.display === 'none' ? 'block' : 'none';
        }
    }
    
    // Select client from menu
    function selectClient(version, client) {
        document.getElementById('selVer').value = version;
        onVersionChange(); // to load clients
        setTimeout(() => {
            document.getElementById('selClient').value = client;
            loadData();
        }, 100); // small delay to ensure clients are loaded
    }
    
    // NEW: Reset modal functions
    function showResetModal() {
        document.getElementById('resetModal').style.display = 'block';
    }
    
    function closeResetModal() {
        document.getElementById('resetModal').style.display = 'none';
    }
    
    function confirmReset() {
        if (!config.stages) return;
        
        // Reset all steps
        config.stages.forEach(stage => {
            stage.steps.forEach(step => {
                step.done = false;
            });
        });
        
        // Re-render
        renderStageTabs();
        renderCurrentStage();
        updateProgress();
        closeResetModal();
        
        console.log('[SMAX Tool] All steps reset');
        showSuccess('All steps have been reset');
    }

    // Show success message (non-blocking)
    function showSuccess(msg) {
        const box = document.getElementById('errorBox');
        box.innerText = `‚úÖ ${msg}`;
        box.style.display = 'block';
        box.style.background = '#d4edda';
        box.style.color = '#155724';
        box.style.borderColor = '#c3e6cb';
        
        // Auto-hide after 3 seconds
        setTimeout(() => {
            box.style.display = 'none';
            box.style.background = '#ffeef0';
            box.style.color = '#d73a49';
            box.style.borderColor = '#f97583';
        }, 3000);
    }

    // Convert config to markdown format with new structure
    // # = Document title
    // ## = Stages
    // ### = Steps
    function convertToMarkdown() {
        let md = '---\n';
        md += jsyaml.dump({ config: config.config });
        md += '---\n\n';
        
        // Add document title
        if (config.title) {
            md += `# ${config.title}\n\n`;
        }
        
        config.stages.forEach(stage => {
            md += `## ${stage.name}\n\n`;
            
            stage.steps.forEach(step => {
                // Use rawMd if available (preserves exact formatting from edits)
                if (step.rawMd) {
                    md += step.rawMd + '\n\n';
                } else {
                    // Fallback to reconstructed markdown
                    md += `### ${step.title}\n\n`;
                    
                    if (step.notes) {
                        md += `${step.notes}\n\n`;
                    }
                    
                    if (step.command) {
                        md += '```bash\n';
                        md += step.command + '\n';
                        md += '```\n\n';
                    }
                    
                    if (step.userNotes && Object.keys(step.userNotes).length > 0) {
                        md += userNotesToMarkdown(step.userNotes) + '\n\n';
                    }
                    
                    // Completion marker as separate section
                    md += step.done ? '### - [x] Complete\n\n' : '### - [ ] Complete\n\n';
                }
            });
        });
        
        return md;
    }
    
    // Save data function to push markdown back to GitHub
    async function saveData() {
        if (!GITHUB_TOKEN) {
            showError('GitHub token required. Please enter token and connect.');
            return;
        }
        
        if (!CURRENT_YAML_PATH) {
            showError('No file path selected. Please load data first.');
            return;
        }
        
        try {
            // Always save as markdown
            const fileContent = convertToMarkdown();
            
            // Use modern UTF-8 base64 encoding
            const utf8Bytes = new TextEncoder().encode(fileContent);
            const binaryString = Array.from(utf8Bytes, byte => String.fromCharCode(byte)).join('');
            const encodedContent = btoa(binaryString);
            
            // Update file on GitHub
            const updatePayload = {
                message: `Update ${document.getElementById('selClient').value} configuration`,
                content: encodedContent
            };
            
            // Only include SHA if file exists (for updates)
            if (FILE_SHA) {
                updatePayload.sha = FILE_SHA;
            }
            
            console.log('[SMAX Tool] Saving to GitHub:', CURRENT_YAML_PATH);
            
            const response = await fetch(
                `https://api.github.com/repos/${OWNER}/${REPO}/contents/${CURRENT_YAML_PATH}`,
                {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${GITHUB_TOKEN}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updatePayload)
                }
            );
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`GitHub API error: ${errorData.message || response.statusText}`);
            }
            
            const result = await response.json();
            FILE_SHA = result.content.sha; // Update SHA for next save
            
            document.getElementById('syncInd').classList.add('online');
            document.getElementById('syncStat').innerText = `Synced: ${document.getElementById('selVer').value}/${document.getElementById('selClient').value}`;
            
            console.log('[SMAX Tool] Data saved successfully, SHA:', result.content.sha);
            clearTimeout(autosaveTimeout);
        } catch (e) {
            console.error('[SMAX Tool] saveData error:', e);
            showError(`Failed to save data: ${e.message}`);
        }
        
        // Set new timeout (debounced save after 3 seconds)
        autosaveTimeout = setTimeout(async () => {
            const status = document.getElementById('autosave-status');
            status.textContent = 'Saving...';
            await saveData();
            status.textContent = 'Autosaved';
            setTimeout(() => {
                status.textContent = 'Autosave enabled';
            }, 2000);
        }, 3000);
    }
    
    // Dark mode toggle
    function toggleDarkMode() {
        document.body.classList.toggle('dark-mode');
        const icon = document.getElementById('theme-icon');
        if (document.body.classList.contains('dark-mode')) {
            icon.textContent = '‚òÄÔ∏è';
            localStorage.setItem('darkMode', 'true');
        } else {
            icon.textContent = 'üåô';
            localStorage.setItem('darkMode', 'false');
        }
    }
    
    // Initialize dark mode from localStorage
    if (localStorage.getItem('darkMode') === 'true') {
        document.body.classList.add('dark-mode');
        document.getElementById('theme-icon').textContent = '‚òÄÔ∏è';
    }
    
    // Restore UI panel states from localStorage
    if (localStorage.getItem('envVarsOpen') === 'true') {
        toggleEnvVars();
    }
    if (localStorage.getItem('clientMenuOpen') === 'true') {
        toggleClientMenu();
    }
    
    // Render document title
    function renderTitle() {
        const titleContainer = document.getElementById('doc-title-container');
        const titleElement = document.getElementById('doc-title');
        if (config.title) {
            titleContainer.style.display = 'block';
            titleElement.textContent = config.title;
        } else {
            titleContainer.style.display = 'none';
        }
    }
    
    // Edit title inline
    function editTitle() {
        const titleElement = document.getElementById('doc-title');
        const currentTitle = config.title || '';
        
        const input = document.createElement('input');
        input.type = 'text';
        input.value = currentTitle;
        input.style.width = '100%';
        input.style.fontSize = '1.5em';
        input.style.fontWeight = 'bold';
        input.style.padding = '4px';
        input.style.border = '1px solid var(--primary)';
        input.style.borderRadius = '4px';
        input.style.background = 'var(--card-bg)';
        input.style.color = 'var(--text)';
        
        titleElement.replaceWith(input);
        input.focus();
        input.select();
        
        const saveTitle = () => {
            const newTitle = input.value.trim();
            config.title = newTitle;
            const newTitleElement = document.createElement('h2');
            newTitleElement.id = 'doc-title';
            newTitleElement.className = 'editable';
            newTitleElement.onclick = editTitle;
            newTitleElement.style.margin = '0';
            newTitleElement.style.cursor = 'pointer';
            newTitleElement.textContent = newTitle || 'Document Title';
            input.replaceWith(newTitleElement);
            triggerAutosave();
        };
        
        input.onblur = saveTitle;
        input.onkeypress = (e) => {
            if (e.key === 'Enter') {
                saveTitle();
            }
        };
    }
    
    // Edit stage name inline
    function editStageName(stageIndex) {
        const stage = config.stages[stageIndex];
        const newName = prompt('Edit stage name:', stage.name);
        if (newName && newName.trim()) {
            stage.name = newName.trim();
            renderStageTabs();
            renderCurrentStage();
            triggerAutosave();
        }
    }
    
    // Edit step
    function editStep(stageIndex, stepIndex) {
        editingStageIndex = stageIndex;
        editingStepIndex = stepIndex;
        const step = config.stages[stageIndex].steps[stepIndex];
        const mdStr = stepToMarkdown(step);
        const textarea = document.getElementById('editStepContent');
        textarea.value = mdStr;
        textarea.addEventListener('keydown', handleMarkdownShortcuts);
        document.getElementById('editStepModal').style.display = 'block';
    }
    
    function closeEditStep() {
        document.getElementById('editStepModal').style.display = 'none';
    }
    
    function saveEditStep() {
        const mdStr = document.getElementById('editStepContent').value;
        try {
            const newStep = markdownToStep(mdStr);
            newStep.rawMd = mdStr; // Preserve the exact edited Markdown
            config.stages[editingStageIndex].steps[editingStepIndex] = newStep;
            renderCurrentStage();
            triggerAutosave();
            closeEditStep();
        } catch (e) {
            showError('Invalid Markdown: ' + e.message);
        }
    }
    
    // Convert step object to Markdown string
    function stepToMarkdown(step) {
        if (step.rawMd) {
            return step.rawMd;
        }
        // Fallback to reconstructed
        let md = `### ${step.title || 'Untitled'}\n\n`;
        md += step.done ? '- [x]\n\n' : '- [ ]\n\n';
        if (step.notes) {
            md += `${step.notes}\n\n`;
        }
        if (step.command) {
            md += `\`\`\`\n${step.command}\n\`\`\`\n\n`;
        }
        if (step.userNotes && Object.keys(step.userNotes).length > 0) {
            md += `#### Notes\n\n`;
            // Put Current notes first (without ##### header)
            if (step.userNotes['Current']) {
                md += `${step.userNotes['Current']}\n\n`;
            }
            // Then add version-specific notes with ##### headers
            for (const [subsection, content] of Object.entries(step.userNotes)) {
                if (subsection !== 'Current' && content.trim()) {
                    md += `##### ${subsection}\n\n${content}\n\n`;
                }
            }
        }
        return md.trim();
    }
    
    // Helper function to convert userNotes object to markdown string
    function userNotesToMarkdown(userNotes) {
        if (!userNotes || Object.keys(userNotes).length === 0) return '';
        
        let md = '#### Notes\n\n';
        // Put Current notes directly under #### Notes (no ##### header)
        if (userNotes['Current']) {
            md += `${userNotes['Current']}\n\n`;
        }
        // Add version-specific notes with ##### headers in the order they appear in the object (preserves file order)
        for (const [subsection, content] of Object.entries(userNotes)) {
            if (subsection !== 'Current' && content && content.trim()) {
                md += `##### ${subsection}\n\n${content}\n\n`;
            }
        }
        return md.trim();
    }
    
    // Helper function to convert markdown string to userNotes object
    function markdownToUserNotes(md) {
        console.log('[SMAX Tool] markdownToUserNotes called with:', md);
        
        if (!md) {
            console.log('[SMAX Tool] markdownToUserNotes: empty input, returning {}');
            return {};
        }
        
        const lines = md.split('\n');
        const userNotes = {};
        let currentKey = 'Current';
        let buffer = [];
        
        for (const line of lines) {
            if (line.startsWith('##### ')) {
                // Save previous buffer
                if (buffer.length > 0) {
                    userNotes[currentKey] = buffer.join('\n').trim();
                    buffer = [];
                }
                currentKey = line.substring(6).trim();
            } else if (line.trim() !== '' && !line.startsWith('#### ')) {
                buffer.push(line);
            }
        }
        
        // Save final buffer
        if (buffer.length > 0) {
            userNotes[currentKey] = buffer.join('\n').trim();
        }
        
        console.log('[SMAX Tool] markdownToUserNotes result:', userNotes);
        return userNotes;
    }
    
    // Convert Markdown string back to step object
    function markdownToStep(md) {
        const lines = md.split('\n');
        const step = { done: false, notes: '', command: '', userNotes: {} };
        let collectingNotes = false;
        let currentSubsection = '';
        let subsectionBuffer = [];
        let collectingCurrent = false;
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            if (line.startsWith('### ')) {
                step.title = line.substring(4).trim();
                step.id = step.title.toLowerCase().replace(/[^a-z0-9]+/g, '_');
            } else if (line.trim() === '- [x]' || line.trim() === '- [X]') {
                step.done = true;
            } else if (line.trim() === '- [ ]') {
                step.done = false;
            } else if (line.startsWith('#### ')) {
                const sectionTitle = line.substring(5).trim();
                if (sectionTitle.toLowerCase().includes('notes') || sectionTitle.toLowerCase().includes('note')) {
                    collectingNotes = true;
                    currentSubsection = '';
                    subsectionBuffer = [];
                    collectingCurrent = true; // Start with Current notes
                }
            } else if (collectingNotes && line.startsWith('##### ')) {
                // Save current notes as Current if we were collecting them
                if (collectingCurrent && subsectionBuffer.length > 0) {
                    step.userNotes['Current'] = subsectionBuffer.join('\n').trim();
                    subsectionBuffer = [];
                    collectingCurrent = false;
                }
                // Save previous subsection if any
                if (currentSubsection && subsectionBuffer.length > 0) {
                    step.userNotes[currentSubsection] = subsectionBuffer.join('\n').trim();
                }
                // Start new version-specific subsection
                currentSubsection = line.substring(6).trim();
                subsectionBuffer = [];
            } else if (collectingNotes) {
                if (line.trim() !== '') {
                    subsectionBuffer.push(line);
                }
            } else if (line.trim() !== '') {
                if (step.notes) {
                    step.notes += '\n' + line.trim();
                } else {
                    step.notes = line.trim();
                }
            }
        }
        
        // Save final content
        if (collectingCurrent && subsectionBuffer.length > 0) {
            step.userNotes['Current'] = subsectionBuffer.join('\n').trim();
        } else if (currentSubsection && subsectionBuffer.length > 0) {
            step.userNotes[currentSubsection] = subsectionBuffer.join('\n').trim();
        }
        
        return step;
    }
    
    // Handle Markdown keyboard shortcuts
    function handleMarkdownShortcuts(e) {
        if (e.ctrlKey) {
            switch (e.key) {
                case 'b':
                    e.preventDefault();
                    insertMarkdown('**', '**');
                    break;
                case 'i':
                    e.preventDefault();
                    insertMarkdown('*', '*');
                    break;
                case '`':
                    e.preventDefault();
                    insertMarkdown('`', '`');
                    break;
            }
        }
    }
    
    // Insert Markdown formatting around selection
    function insertMarkdown(before, after) {
        const textarea = document.getElementById('editStepContent');
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const selected = textarea.value.substring(start, end);
        const replacement = before + selected + after;
        textarea.value = textarea.value.substring(0, start) + replacement + textarea.value.substring(end);
        textarea.selectionStart = textarea.selectionEnd = start + replacement.length;
        textarea.focus();
    }
    
    // Add new stage
    function addNewStage() {
        const stageName = prompt('Enter new stage name:');
        if (stageName && stageName.trim()) {
            config.stages.push({
                name: stageName.trim(),
                steps: []
            });
            currentStageIndex = config.stages.length - 1;
            renderStageTabs();
            renderCurrentStage();
            updateProgress();
            triggerAutosave();
        }
    }
    
    // Add new step to current stage
    function addNewStep() {
        if (currentStageIndex < 0 || currentStageIndex >= config.stages.length) {
            showError('No stage selected');
            return;
        }
        
        const stepTitle = prompt('Enter new step title:');
        if (stepTitle && stepTitle.trim()) {
            config.stages[currentStageIndex].steps.push({
                id: stepTitle.toLowerCase().replace(/[^a-z0-9]+/g, '_'),
                title: stepTitle.trim(),
                notes: '#### Notes\n\n',
                command: '',
                done: false,
                userNotes: {}
            });
            renderCurrentStage();
            updateProgress();
            triggerAutosave();
        }
    }
    
    // Raw editor functions
    function showRawEditor() {
        const modal = document.getElementById('rawEditorModal');
        const textarea = document.getElementById('rawEditorContent');
        textarea.value = convertToMarkdown();
        modal.style.display = 'block';
    }
    
    function closeRawEditor() {
        document.getElementById('rawEditorModal').style.display = 'none';
    }
    
    function saveRawEditor() {
        const content = document.getElementById('rawEditorContent').value;
        try {
            // Parse the markdown content
            const { config: configData, markdown } = parseMarkdownFrontMatter(content);
            const { title, stages } = parseMarkdownStages(markdown);
            
            config = {
                title: title,
                config: configData,
                stages: stages
            };
            
            // Re-render everything
            renderTitle();
            renderVars();
            renderStageTabs();
            renderCurrentStage();
            updateProgress();
            
            closeRawEditor();
            triggerAutosave();
            showSuccess('Changes applied from raw editor');
        } catch (e) {
            showError(`Failed to parse markdown: ${e.message}`);
        }
    }
    
    // ============================================================================
    // UNIFIED EDITOR SYSTEM
    // ============================================================================
    
    // Editor configurations for different use cases
    const EDITOR_CONFIGS = {
        raw: {
            title: 'Raw Markdown Editor',
            mode: 'markdown',
            height: '600px',
            showPreview: true,
            validate: (content) => {
                try {
                    const { config: configData, markdown } = parseMarkdownFrontMatter(content);
                    const { title, stages } = parseMarkdownStages(markdown);
                    return { valid: true, data: { title, config: configData, stages } };
                } catch (e) {
                    return { valid: false, error: e.message };
                }
            },
            save: (data) => {
                config = data;
                renderTitle();
                renderVars();
                renderStageTabs();
                renderCurrentStage();
                updateProgress();
                triggerAutosave();
                showSuccess('Changes applied from raw editor');
            }
        },
        step: {
            title: 'Edit Step',
            mode: 'markdown',
            height: '500px',
            showPreview: true,
            validate: (content) => {
                try {
                    const step = markdownToStep(content);
                    return { valid: true, data: step };
                } catch (e) {
                    return { valid: false, error: e.message };
                }
            },
            save: (data) => {
                data.rawMd = document.getElementById('unifiedEditorContent').value;
                config.stages[editingStageIndex].steps[editingStepIndex] = data;
                renderCurrentStage();
                triggerAutosave();
            }
        },
        envVars: {
            title: 'Edit Environment Variables (YAML)',
            mode: 'yaml',
            height: '400px',
            showPreview: false,
            validate: (content) => {
                try {
                    const data = jsyaml.load(content);
                    return { valid: true, data };
                } catch (e) {
                    return { valid: false, error: `Invalid YAML: ${e.message}` };
                }
            },
            save: (data) => {
                config.config = data;
                renderVars();
                triggerAutosave();
                showSuccess('Environment variables updated');
            }
        },
        notes: {
            title: 'Edit Notes',
            mode: 'markdown',
            height: '400px',
            showPreview: true,
            validate: (content) => {
                return { valid: true, data: content }; // Notes don't need validation
            },
            save: (data) => {
                // This will be handled by the calling context
            }
        }
    };
    
    // Show unified editor with specific configuration
    function showUnifiedEditor(configType, initialContent = '', context = {}) {
        console.log('[UNIFIED EDITOR] showUnifiedEditor called with configType:', configType);
        currentEditorConfig = { ...EDITOR_CONFIGS[configType], context };
        console.log('[UNIFIED EDITOR] currentEditorConfig:', currentEditorConfig);
        
        const modal = document.getElementById('unifiedEditorModal');
        const title = document.getElementById('editorTitle');
        const textarea = document.getElementById('unifiedEditorContent');
        const previewBtn = document.getElementById('editorPreviewBtn');
        
        console.log('[UNIFIED EDITOR] Modal element:', modal);
        console.log('[UNIFIED EDITOR] Title element:', title);
        
        title.textContent = currentEditorConfig.title;
        textarea.value = initialContent;
        // Initialize font size (load from localStorage if available)
        const fontSizeSelect = document.getElementById('editorFontSize');
        const savedFontSize = localStorage.getItem('editorFontSize');
        if (savedFontSize) {
            fontSizeSelect.value = savedFontSize;
        }
        const initialFontSize = fontSizeSelect.value + 'px';
        textarea.style.fontSize = initialFontSize;
        document.getElementById('editorPreview').style.fontSize = initialFontSize;
        
        // Show/hide preview button
        previewBtn.style.display = currentEditorConfig.showPreview ? 'inline-block' : 'none';
        
        // Reset preview state
        document.getElementById('editorPreview').style.display = 'none';
        textarea.style.display = 'block';
        previewBtn.textContent = 'üëÅÔ∏è Preview';
        
        // Add event listeners
        textarea.addEventListener('input', updateEditorStatus);
        textarea.addEventListener('keyup', updateEditorStatus);
        textarea.addEventListener('click', updateEditorStatus);
        
        if (currentEditorConfig.mode === 'markdown') {
            textarea.addEventListener('keydown', handleUnifiedMarkdownShortcuts);
        }
        
        // Initialize CodeMirror for live syntax highlighting if enabled
        if (syntaxHighlightingEnabled && typeof CodeMirror !== 'undefined') {
            console.log('[UNIFIED EDITOR] Scheduling CodeMirror initialization');
            // Delay initialization to ensure CodeMirror is fully loaded
            setTimeout(() => {
                console.log('[UNIFIED EDITOR] Initializing CodeMirror for live syntax highlighting');
                codeMirrorEditor = CodeMirror.fromTextArea(textarea, {
                    lineNumbers: true,
                    mode: 'markdown', // Use markdown mode
                    theme: 'monokai', // Use monokai theme for better contrast
                    lineWrapping: true,
                    viewportMargin: Infinity,
                    foldGutter: true,
                    gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
                    extraKeys: {
                        "Ctrl-B": function(cm) { insertUnifiedMarkdown("**", "**"); },
                        "Ctrl-I": function(cm) { insertUnifiedMarkdown("*", "*"); },
                        "Ctrl-`": function(cm) { insertUnifiedMarkdown("`", "`"); },
                        "Ctrl-K": function(cm) { insertUnifiedMarkdown("[", "](url)"); }
                    }
                });
                
                // Set initial content
                codeMirrorEditor.setValue(initialContent);
                
                // Apply saved font size to CodeMirror
                const currentFontSize = fontSizeSelect.value + 'px';
                codeMirrorEditor.getWrapperElement().style.fontSize = currentFontSize;
                codeMirrorEditor.refresh();
                
                // Sync CodeMirror changes back to textarea for form submission
                codeMirrorEditor.on('change', function(cm) {
                    textarea.value = cm.getValue();
                    updateEditorStatus();
                });
                
                // Hide the original textarea
                textarea.style.display = 'none';
                console.log('[UNIFIED EDITOR] CodeMirror initialized successfully', codeMirrorEditor);
            }, 100);
        } else {
            console.log('[UNIFIED EDITOR] CodeMirror not initialized:', { syntaxHighlightingEnabled, codeMirrorAvailable: typeof CodeMirror !== 'undefined' });
        }
        
        modal.style.display = 'block';
        modal.style.visibility = 'visible';
        modal.style.opacity = '1';
        console.log('[UNIFIED EDITOR] Modal display set to block');
        
        // Setup image paste functionality for unified editor
        setupImagePaste(textarea);
        
        // Add button event listeners
        document.getElementById('cancelEditorBtn').onclick = closeUnifiedEditor;
        document.getElementById('saveEditorBtn').onclick = saveUnifiedEditor;
        document.getElementById('expandBtn').onclick = expandAllHeaders;
        document.getElementById('collapseBtn').onclick = collapseAllHeaders;
        document.getElementById('editorFontSize').addEventListener('change', changeFontSize);
        
        textarea.focus();
        updateEditorStatus();
    }
    
    // Close unified editor
    function closeUnifiedEditor() {
        console.log('[UNIFIED EDITOR] closeUnifiedEditor called');
        const modal = document.getElementById('unifiedEditorModal');
        modal.style.display = 'none';
        modal.style.visibility = 'hidden';
        modal.style.opacity = '0';
        currentEditorConfig = null;
        
        // Clean up event listeners
        const textarea = document.getElementById('unifiedEditorContent');
        textarea.removeEventListener('input', updateEditorStatus);
        textarea.removeEventListener('keyup', updateEditorStatus);
        textarea.removeEventListener('click', updateEditorStatus);
        textarea.removeEventListener('keydown', handleUnifiedMarkdownShortcuts);
        
        // Clean up CodeMirror
        if (codeMirrorEditor) {
            codeMirrorEditor.toTextArea();
            codeMirrorEditor = null;
        }
        
        // Clean up button event listeners
        document.getElementById('cancelEditorBtn').onclick = null;
        document.getElementById('saveEditorBtn').onclick = null;
        document.getElementById('expandBtn').onclick = null;
        document.getElementById('collapseBtn').onclick = null;
        document.getElementById('editorFontSize').removeEventListener('change', changeFontSize);
    }
    
    // Expand all headers (unfold all)
    function expandAllHeaders() {
        if (codeMirrorEditor) {
            codeMirrorEditor.execCommand('unfoldAll');
        }
    }
    
    // Collapse all ## headers
    function collapseAllHeaders() {
        if (codeMirrorEditor) {
            const doc = codeMirrorEditor.getDoc();
            const lines = doc.lineCount();
            for (let i = 0; i < lines; i++) {
                const line = doc.getLine(i);
                if (line.trim().startsWith('## ')) {
                    // Find the end of this section (next header or end)
                    let end = i + 1;
                    while (end < lines) {
                        const nextLine = doc.getLine(end);
                        if (nextLine.trim().match(/^#{1,6} /)) {
                            break;
                        }
                        end++;
                    }
                    // Fold from i to end-1
                    codeMirrorEditor.foldCode({line: i, ch: 0}, null, 'fold');
                }
            }
        }
    }
    
    // Save unified editor
    function saveUnifiedEditor() {
        console.log('[UNIFIED EDITOR] saveUnifiedEditor called');
        if (!currentEditorConfig) {
            console.error('[UNIFIED EDITOR] No currentEditorConfig');
            return;
        }
        
        const content = document.getElementById('unifiedEditorContent').value;
        console.log('[UNIFIED EDITOR] Content length:', content.length);
        const validation = currentEditorConfig.validate(content);
        console.log('[UNIFIED EDITOR] Validation result:', validation);
        
        if (!validation.valid) {
            showError(validation.error);
            return;
        }
        
        try {
            currentEditorConfig.save(validation.data, currentEditorConfig.context);
            closeUnifiedEditor();
        } catch (e) {
            console.error('[UNIFIED EDITOR] Save error:', e);
            showError(`Save failed: ${e.message}`);
        }
    }
    
    // Toggle word wrap
    function toggleWordWrap() {
        const textarea = document.getElementById('unifiedEditorContent');
        const btn = document.getElementById('wordWrapBtn');
        
        if (textarea.classList.contains('word-wrap')) {
            textarea.classList.remove('word-wrap');
            btn.textContent = '‚Ü©Ô∏è Wrap';
        } else {
            textarea.classList.add('word-wrap');
            btn.textContent = '‚Üµ No Wrap';
        }
    }
    
    // Change font size
    function changeFontSize() {
        const select = document.getElementById('editorFontSize');
        const fontSize = select.value + 'px';
        const textarea = document.getElementById('unifiedEditorContent');
        const preview = document.getElementById('editorPreview');
        
        console.log('[UNIFIED EDITOR] Changing font size to:', fontSize);
        
        // Save to localStorage
        localStorage.setItem('editorFontSize', select.value);
        
        textarea.style.fontSize = fontSize;
        preview.style.fontSize = fontSize;
        
        // Also update CodeMirror font size
        if (codeMirrorEditor) {
            codeMirrorEditor.getWrapperElement().style.fontSize = fontSize;
            codeMirrorEditor.refresh();
        }
    }
    
    // Update editor status (line/column position)
    function updateEditorStatus() {
        const status = document.getElementById('editorStatus');
        const lineCol = document.getElementById('editorLineCol');
        
        let text, cursorPos;
        
        if (codeMirrorEditor) {
            const doc = codeMirrorEditor.getDoc();
            const cursor = doc.getCursor();
            text = doc.getValue();
            cursorPos = doc.indexFromPos(cursor);
            
            lineCol.textContent = `Ln ${cursor.line + 1}, Col ${cursor.ch + 1}`;
        } else {
            const textarea = document.getElementById('unifiedEditorContent');
            text = textarea.value;
            cursorPos = textarea.selectionStart;
            
            let line = 1;
            let col = 1;
            
            for (let i = 0; i < cursorPos; i++) {
                if (text[i] === '\n') {
                    line++;
                    col = 1;
                } else {
                    col++;
                }
            }
            
            lineCol.textContent = `Ln ${line}, Col ${col}`;
        }
        
        // Show validation status
        if (currentEditorConfig && currentEditorConfig.validate) {
            const validation = currentEditorConfig.validate(text);
            status.textContent = validation.valid ? '‚úì Valid' : '‚úó Invalid';
            status.style.color = validation.valid ? '#28a745' : '#dc3545';
        }
    }
    
    // Handle markdown shortcuts in unified editor
    function handleUnifiedMarkdownShortcuts(e) {
        if (e.ctrlKey) {
            switch (e.key) {
                case 'b':
                    e.preventDefault();
                    insertUnifiedMarkdown('**', '**');
                    break;
                case 'i':
                    e.preventDefault();
                    insertUnifiedMarkdown('*', '*');
                    break;
                case '`':
                    e.preventDefault();
                    insertUnifiedMarkdown('`', '`');
                    break;
                case 'k':
                    e.preventDefault();
                    insertUnifiedMarkdown('[', '](url)');
                    break;
            }
        }
    }
    
    // Insert markdown formatting in unified editor
    function insertUnifiedMarkdown(before, after) {
        if (codeMirrorEditor) {
            // Use CodeMirror API
            const doc = codeMirrorEditor.getDoc();
            const selection = doc.getSelection();
            const cursor = doc.getCursor();
            
            if (selection) {
                // Replace selection
                const replacement = before + selection + after;
                doc.replaceSelection(replacement);
            } else {
                // Insert at cursor
                doc.replaceRange(before + after, cursor);
                doc.setCursor({line: cursor.line, ch: cursor.ch + before.length});
            }
            codeMirrorEditor.focus();
        } else {
            // Use regular textarea
            const textarea = document.getElementById('unifiedEditorContent');
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const selected = textarea.value.substring(start, end);
            const replacement = before + selected + after;
            textarea.value = textarea.value.substring(0, start) + replacement + textarea.value.substring(end);
            textarea.selectionStart = textarea.selectionEnd = start + replacement.length;
            textarea.focus();
        }
        updateEditorStatus();
    }
    
    // ============================================================================
    // UPDATED EDITOR FUNCTIONS (using unified editor)
    // ============================================================================
    
    function showRawEditor() {
        const content = convertToMarkdown();
        showUnifiedEditor('raw', content);
    }
    
    function editStep(stageIndex, stepIndex) {
        editingStageIndex = stageIndex;
        editingStepIndex = stepIndex;
        const step = config.stages[stageIndex].steps[stepIndex];
        const mdStr = stepToMarkdown(step);
        showUnifiedEditor('step', mdStr);
    }
    
    function editEnvVars() {
        const content = jsyaml.dump(config.config || {});
        showUnifiedEditor('envVars', content);
    }
    
    // Make functions global so onclick handlers work
    window.showVersionUpgrade = showVersionUpgrade;
    window.closeVersionUpgrade = closeVersionUpgrade;
    window.onTargetVersionChange = onTargetVersionChange;
    window.confirmVersionUpgrade = confirmVersionUpgrade;
    async function uploadImageToGitHub(file, noteTextarea) {
        if (!GITHUB_TOKEN) {
            showError('GitHub token required for image upload');
            return;
        }

        try {
            // Read file as base64
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const base64Content = e.target.result.split(',')[1];
                    const fileName = `images/${Date.now()}-${file.name.replace(/[^a-zA-Z0-9.-]/g, '_')}`;
                    const ver = document.getElementById('selVer').value;
                    const basePath = getVersionsBasePath();
                    const imagePath = `${basePath}/${ver}/${fileName}`;

                    console.log(`[SMAX Tool] Uploading image to: ${imagePath}`);

                    // Upload to GitHub
                    const response = await fetch(
                        `https://api.github.com/repos/${OWNER}/${REPO}/contents/${imagePath}`,
                        {
                            method: 'PUT',
                            headers: {
                                'Authorization': `token ${GITHUB_TOKEN}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                message: `Upload image ${file.name}`,
                                content: base64Content
                            })
                        }
                    );

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`GitHub API error: ${errorData.message || response.statusText}`);
                    }

                    const result = await response.json();
                    const imageUrl = result.content.download_url;

                    console.log(`[SMAX Tool] Image uploaded successfully: ${imageUrl}`);

                    // Insert markdown image link at cursor
                    const markdownLink = `\n![${file.name}](${imageUrl})\n`;
                    const cursorPos = noteTextarea.selectionStart;
                    const textBefore = noteTextarea.value.substring(0, cursorPos);
                    const textAfter = noteTextarea.value.substring(cursorPos);
                    noteTextarea.value = textBefore + markdownLink + textAfter;

                    // Trigger preview update
                    noteTextarea.dispatchEvent(new Event('input'));

                    showSuccess('Image uploaded successfully');
                } catch (innerError) {
                    console.error('[SMAX Tool] Image upload error:', innerError);
                    showError(`Image upload failed: ${innerError.message}`);
                }
            };

            reader.onerror = () => {
                showError('Failed to read image file');
            };

            reader.readAsDataURL(file);
        } catch (e) {
            console.error('[SMAX Tool] Image upload setup error:', e);
            showError(`Image upload failed: ${e.message}`);
        }
    }
    
    // Handle paste events for image upload
    function setupImagePaste(textarea) {
        textarea.addEventListener('paste', async (e) => {
            const items = e.clipboardData.items;
            for (let item of items) {
                if (item.type.indexOf('image') !== -1) {
                    e.preventDefault();
                    const file = item.getAsFile();
                    await uploadImageToGitHub(file, textarea);
                    break;
                }
            }
        });
        
        // Drag and drop support
        textarea.addEventListener('dragover', (e) => {
            e.preventDefault();
            textarea.classList.add('dragging');
        });
        
        textarea.addEventListener('dragleave', () => {
            textarea.classList.remove('dragging');
        });
        
        textarea.addEventListener('drop', async (e) => {
            e.preventDefault();
            textarea.classList.remove('dragging');
            
            const files = e.dataTransfer.files;
            for (let file of files) {
                if (file.type.indexOf('image') !== -1) {
                    await uploadImageToGitHub(file, textarea);
                    break;
                }
            }
        });
    }

    // Helper function to process markdown content with images for PDF
    async function processMarkdownForPDF(pdf, content, x, y, maxWidth, colors) {
        try {
            if (!content) return y;

            // Split content by image markdown syntax ![alt](url)
            const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
            let lastIndex = 0;
            let currentY = y;
            let match;

            while ((match = imageRegex.exec(content)) !== null) {
                // Process text before image
                const textBefore = content.substring(lastIndex, match.index);
                if (textBefore.trim()) {
                    const textLines = pdf.splitTextToSize(textBefore, maxWidth);
                    pdf.text(textLines, x, currentY);
                    currentY += textLines.length * 7; // lineHeight
                }

                // Process image
                const altText = match[1];
                const imageUrl = match[2];

                try {
                    // Load image with timeout and error handling
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout

                    const response = await fetch(imageUrl, {
                        signal: controller.signal,
                        mode: 'cors'
                    });
                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const blob = await response.blob();
                    const arrayBuffer = await blob.arrayBuffer();
                    const uint8Array = new Uint8Array(arrayBuffer);

                    // Determine image format
                    let format = 'JPEG';
                    if (imageUrl.toLowerCase().includes('.png')) {
                        format = 'PNG';
                    } else if (imageUrl.toLowerCase().includes('.gif')) {
                        format = 'GIF';
                    }

                    // Add image to PDF
                    const imgWidth = Math.min(maxWidth, 100); // Max width of 100mm
                    const imgHeight = 60; // Fixed height, could be calculated based on aspect ratio

                    pdf.addImage(uint8Array, format, x, currentY, imgWidth, imgHeight);
                    currentY += imgHeight + 5; // Add some padding after image

                    // Add alt text as caption if provided
                    if (altText && altText.trim()) {
                        pdf.setFontSize(9);
                        pdf.setTextColor(...colors.secondaryText);
                        pdf.text(altText, x, currentY);
                        currentY += 7;
                        pdf.setFontSize(11);
                        pdf.setTextColor(...colors.text);
                    }

                } catch (error) {
                    console.warn(`[SMAX Tool] Failed to load image ${imageUrl}:`, error);
                    // Add placeholder text for failed image
                    pdf.setTextColor(...colors.incomplete);
                    pdf.text(`[Image failed to load: ${altText || imageUrl}]`, x, currentY);
                    currentY += 7;
                    pdf.setTextColor(...colors.text);
                }

                lastIndex = imageRegex.lastIndex;
            }

            // Process remaining text after last image
            const remainingText = content.substring(lastIndex);
            if (remainingText.trim()) {
                const textLines = pdf.splitTextToSize(remainingText, maxWidth);
                pdf.text(textLines, x, currentY);
                currentY += textLines.length * 7;
            }

            return currentY;
        } catch (error) {
            console.error('[SMAX Tool] Error in processMarkdownForPDF:', error);
            // Fallback: return original y position
            return y;
        }
    }

    // PDF Export Functionality (Dark Grey Theme)
    async function exportToPDF() {
        if (!config || !config.title) {
            showError('No data loaded. Please load a client first.');
            return;
        }

        try {
            console.log('Global jsPDF:', typeof jsPDF, jsPDF);
            console.log('window.jsPDF:', typeof window.jsPDF, window.jsPDF);
            
            let pdf;
            if (typeof window.jsPDF === 'function') {
                pdf = new window.jsPDF('p', 'mm', 'a4');
                // Ensure proper text encoding
                pdf.setProperties({
                    title: config.title,
                    subject: 'Multi-Tenant Operations Guide',
                    author: 'SMAX Upgrade Tool',
                    keywords: 'SMAX, upgrade, operations',
                    creator: 'SMAX Upgrade Tool'
                });
            } else {
                throw new Error('jsPDF library not found');
            }
            
            // PDF settings
            const pageWidth = pdf.internal.pageSize.width;
            const pageHeight = pdf.internal.pageSize.height;
            const margin = 20;
            let yPosition = margin;
            const lineHeight = 7;
            
            // Dark theme colors (grey theme)
            const colors = {
                background: [32, 33, 36],        // #202124 - dark grey background
                text: [241, 243, 244],           // #f1f3f4 - light grey text
                secondaryText: [154, 160, 166],  // #9aa0a6 - medium grey
                headerBg: [63, 81, 181],         // #3f51b5 - blue for branding
                headerText: [255, 255, 255],     // White
                codeBg: [48, 54, 61],            // #30363d - dark grey for code
                codeBorder: [95, 99, 104],       // #5f6368 - medium grey
                border: [95, 99, 104],           // #5f6368
                complete: [76, 175, 80],         // Keep green for complete
                incomplete: [244, 67, 54],       // Keep red for incomplete
                notes: [33, 150, 243],           // #2196f3 - blue for notes
                footerBg: [48, 54, 61],          // #30363d - dark footer
                footerText: [154, 160, 166]      // #9aa0a6 - medium gray footer
            };
            
            // Set page background to dark
            pdf.setFillColor(...colors.background);
            pdf.rect(0, 0, pageWidth, pageHeight, 'F');
            
            // Add header with gradient background (blue theme)
            pdf.setFillColor(...colors.headerBg);
            pdf.rect(0, 0, pageWidth, 25, 'F');
            pdf.setFillColor(92, 107, 192); // Lighter blue
            pdf.rect(0, 20, pageWidth, 5, 'F');
            
            // Title with white text on gradient
            pdf.setFontSize(24);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor(...colors.headerText);
            pdf.text(config.title, margin, yPosition + 5);
            
            // Add date below title
            pdf.setFontSize(12);
            pdf.setFont('helvetica', 'normal');
            pdf.setTextColor(...colors.secondaryText);
            const currentDate = new Date().toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
            pdf.text(`Generated: ${currentDate}`, margin, yPosition + 10);
            
            yPosition = 60; // Start TOC lower on the page
            
            // Add table of contents
            pdf.setFontSize(16);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor(...colors.headerBg);
            pdf.text('Table of Contents', margin, yPosition);
            yPosition += lineHeight * 1.8;

            pdf.setFontSize(12);
            pdf.setFont('helvetica', 'normal');
            pdf.setTextColor(...colors.text);

            config.stages.forEach((stage, stageIndex) => {
                // Stage title
                const stageTocText = `${stageIndex + 1}. ${stage.name}`;
                pdf.setFont('helvetica', 'bold');
                pdf.setTextColor(...colors.headerBg);
                pdf.text(stageTocText, margin + 10, yPosition);
                yPosition += lineHeight * 1.2;

                // Steps within this stage
                pdf.setFont('helvetica', 'normal');
                pdf.setTextColor(...colors.secondaryText);
                stage.steps.forEach((step, stepIndex) => {
                    const stepTocText = `${stageIndex + 1}.${stepIndex + 1} ${step.title}`;
                    pdf.text(stepTocText, margin + 20, yPosition);
                    yPosition += lineHeight * 0.9;
                });

                yPosition += lineHeight * 0.5; // Small space between stages in TOC
            });

            yPosition += lineHeight * 1.5; // Space after TOC
            
            // Add all stages
            for (const [stageIndex, stage] of config.stages.entries()) {
                // Each stage ALWAYS starts on a new page
                pdf.addPage();
                // Set dark grey background for new page
                pdf.setFillColor(...colors.background);
                pdf.rect(0, 0, pageWidth, pageHeight, 'F');
                yPosition = margin;
                
                // Stage header with enhanced styling
                pdf.setFillColor(...colors.headerBg);
                pdf.rect(margin - 5, yPosition - 8, pageWidth - margin * 2 + 10, 16, 'F');

                // White text on green background
                pdf.setFontSize(18);
                pdf.setFont('helvetica', 'bold');
                pdf.setTextColor(...colors.headerText);
                pdf.text(`${stageIndex + 1}. ${stage.name}`, margin, yPosition);
                yPosition += lineHeight * 2.8;

                pdf.setFontSize(11);
                pdf.setFont('helvetica', 'normal');
                pdf.setTextColor(...colors.text);
                
                for (const [index, step] of stage.steps.entries()) {
                    // Check if we need a new page (more conservative check)
                    if (yPosition > pageHeight - margin * 6) {
                        pdf.addPage();
                        // Set dark grey background for new page
                        pdf.setFillColor(...colors.background);
                        pdf.rect(0, 0, pageWidth, pageHeight, 'F');

                        // Repeat header on new page
                        pdf.setFillColor(...colors.headerBg);
                        pdf.rect(0, 0, pageWidth, 20, 'F');
                        pdf.setFontSize(14);
                        pdf.setFont('helvetica', 'bold');
                        pdf.setTextColor(...colors.headerText);
                        pdf.text(`${config.title} - ${stage.name} (continued)`, margin, 12);
                        yPosition = 30;
                        pdf.setFontSize(11);
                        pdf.setFont('helvetica', 'normal');
                        pdf.setTextColor(...colors.text);
                    }
                    
                    // Step title with icon
                    pdf.setFont('helvetica', 'bold');
                    pdf.setTextColor(...colors.text);
                    const stepTitle = `${index + 1}. ${step.title}`;
                    const titleLines = pdf.splitTextToSize(stepTitle, pageWidth - margin * 2 - 20);
                    pdf.text(titleLines, margin + 10, yPosition);
                    const titleHeight = titleLines.length * lineHeight;
                    yPosition += titleHeight;

                    // Step content with better formatting (now supports images)
                    if (step.notes) {
                        yPosition += lineHeight * 0.8;
                        yPosition = await processMarkdownForPDF(pdf, step.notes, margin + 10, yPosition, pageWidth - margin * 2 - 20, colors);
                    }

                    // Commands with improved code block styling
                    if (step.command) {
                        yPosition += lineHeight * 0.8;
                        const interpolatedCommand = interpolate(step.command);

                        // Calculate exact height needed for command
                        const commandLines = pdf.splitTextToSize(interpolatedCommand, pageWidth - margin * 2 - 30);
                        const codeBlockHeight = Math.max(15, commandLines.length * 5 + 8);

                        // Code block background (dark)
                        pdf.setFillColor(...colors.codeBg);
                        pdf.setDrawColor(...colors.codeBorder);
                        pdf.setLineWidth(0.3);
                        pdf.rect(margin + 8, yPosition - 2, pageWidth - margin * 2 - 16, codeBlockHeight, 'FD');

                        pdf.setFont('courier', 'normal');
                        pdf.setFontSize(9);
                        pdf.setTextColor(...colors.secondaryText);
                        pdf.text('Command:', margin + 12, yPosition + 2);

                        pdf.setTextColor(...colors.text);
                        pdf.text(commandLines, margin + 15, yPosition + 8);

                        yPosition += codeBlockHeight + 2;
                        pdf.setFontSize(11);
                        pdf.setFont('helvetica', 'normal');
                        pdf.setTextColor(...colors.text);
                    }

                    // Notes with enhanced styling
                    if (step.userNotes && Object.keys(step.userNotes).length > 0) {
                        yPosition += lineHeight * 0.8;
                        pdf.setFont('helvetica', 'bold');
                        pdf.setTextColor(...colors.notes);
                        pdf.text('Notes:', margin + 10, yPosition);
                        yPosition += lineHeight;

                        pdf.setFont('helvetica', 'normal');
                        pdf.setTextColor(...colors.text);
                        for (const [key, content] of Object.entries(step.userNotes)) {
                            if (content && content.trim()) {
                                if (key !== 'Current') {
                                    pdf.setFont('helvetica', 'bold');
                                    pdf.setTextColor(...colors.secondaryText);
                                    pdf.text(`Version ${key}:`, margin + 15, yPosition);
                                    yPosition += lineHeight;
                                }
                                pdf.setFont('helvetica', 'normal');
                                pdf.setTextColor(...colors.text);
                                yPosition = await processMarkdownForPDF(pdf, content, margin + 15, yPosition, pageWidth - margin * 2 - 25, colors);
                            }
                        }
                    }

                    // Completion status at the end of the step
                    yPosition += lineHeight * 0.6;
                    pdf.setFont('helvetica', 'bold');
                    if (step.done) {
                        pdf.setFillColor(...colors.complete);
                        pdf.circle(margin + 12, yPosition - 1, 2, 'F');
                        pdf.setTextColor(...colors.complete);
                        pdf.text('Complete', margin + 18, yPosition);
                    } else {
                        pdf.setDrawColor(...colors.incomplete);
                        pdf.setLineWidth(0.5);
                        pdf.circle(margin + 12, yPosition - 1, 2, 'S');
                        pdf.setTextColor(...colors.incomplete);
                        pdf.text('Incomplete', margin + 18, yPosition);
                    }
                    pdf.setTextColor(...colors.text);
                    yPosition += lineHeight * 1.5; // Increased padding between steps
                }
                
                // Add some space between stages
                yPosition += lineHeight * 1.8;
            }
            
            // Enhanced footer (dark theme)
            const totalPages = pdf.internal.getNumberOfPages();
            for (let i = 1; i <= totalPages; i++) {
                pdf.setPage(i);
                
                // Footer background (dark)
                pdf.setFillColor(...colors.footerBg);
                pdf.rect(0, pageHeight - 15, pageWidth, 15, 'F');
                pdf.setDrawColor(...colors.border);
                pdf.line(0, pageHeight - 15, pageWidth, pageHeight - 15);
                
                pdf.setFontSize(8);
                pdf.setFont('helvetica', 'normal');
                pdf.setTextColor(...colors.footerText);
                
                // Left footer
                pdf.text(`Generated by SMAX Upgrade Tool`, margin, pageHeight - 8);
                
                // Center footer
                pdf.text(`Copyright ${new Date().getFullYear()} Multi-Tenant Operations`, pageWidth / 2, pageHeight - 8, { align: 'center' });
                
                // Right footer
                pdf.text(`Page ${i} of ${totalPages}`, pageWidth - margin, pageHeight - 8, { align: 'right' });
            }
            
            // Save the PDF
            const filename = `${config.title.replace(/[^a-z0-9]/gi, '_')}_Dark_Export.pdf`;
            pdf.save(filename);
            
            console.log('[SMAX Tool] Dark theme PDF exported successfully:', filename);
            showSuccess('Dark theme PDF exported successfully!');
            
        } catch (e) {
            console.error('[SMAX Tool] PDF export error:', e);
            showError(`PDF export failed: ${e.message}`);
        }
    }

    // Initialize token input field if cached and auto-connect
    console.log('[SMAX Tool] Initializing application...');
    // Set default product to SMAX
    const cachedProduct = sessionStorage.getItem('selected_product') || 'SMAX';
    document.getElementById('selProduct').value = cachedProduct;
    
    // Update app title
    const titleElement = document.getElementById('appTitle');
    titleElement.textContent = `${cachedProduct} Multi-Tenant Operations`;
    
    // Set autosave checkbox state
    document.getElementById('autosaveToggle').checked = autosaveEnabled;
    
    // Open environment variables sidebar by default
    toggleEnvVars();
    
    const cachedToken = sessionStorage.getItem('github_token');
    console.log('[SMAX Tool] Cached token exists:', !!cachedToken);
    if (cachedToken) {
        GITHUB_TOKEN = cachedToken;
        document.getElementById('ghToken').value = cachedToken;
        console.log('[SMAX Tool] Attempting auto-connect');
        connect(true); // true indicates auto-connection
    } else {
        console.log('[SMAX Tool] No cached token, waiting for manual input');
    }

    // Make functions globally accessible for HTML event handlers
    window.connect = connect.bind(this);
    window.onProductChange = onProductChange.bind(this);
    window.onVersionChange = onVersionChange.bind(this);
    window.loadData = loadData.bind(this);
    window.saveData = saveData.bind(this);
    window.exportToPDF = exportToPDF.bind(this);
    window.showRawEditor = showRawEditor;
    window.closeRawEditor = closeRawEditor;
    window.saveRawEditor = saveRawEditor;
    window.closeEditStep = closeEditStep;
    window.saveEditStep = saveEditStep;
    window.showVersionUpgrade = showVersionUpgrade;
    window.toggleEnvVars = toggleEnvVars.bind(this);
    window.toggleClientMenu = toggleClientMenu.bind(this);
    window.closeClientMenu = closeClientMenu.bind(this);
    window.showResetModal = showResetModal.bind(this);
    window.editTitle = editTitle.bind(this);
    window.closeEnvVars = closeEnvVars.bind(this);
    window.editEnvVars = editEnvVars;
    window.closeEditEnvVars = closeEditEnvVars;
    window.saveEditEnvVars = saveEditEnvVars;
    window.prevStage = prevStage.bind(this);
    window.nextStage = nextStage.bind(this);
    window.addNewStage = addNewStage.bind(this);
    window.addNewStep = addNewStep.bind(this);
    window.toggleAutosave = toggleAutosave.bind(this);
    window.toggleDarkMode = toggleDarkMode.bind(this);
    window.toggleNoteEdit = toggleNoteEdit.bind(this);
    window.saveNote = saveNote.bind(this);
    
    // Add event listeners for controls
    document.getElementById('ghToken').addEventListener('change', () => connect());
    document.getElementById('selProduct').addEventListener('change', () => onProductChange());
}
</script>
</body>
</html>

