<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SMAX Multi-Client Upgrade Hub</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        :root { 
            --primary: #2ea44f; 
            --dark: #24292e; 
            --bg: #f6f8fa; 
            --border: #d1d5da;
            --text: #24292e;
            --card-bg: #ffffff;
        }
        
        /* Dark mode variables */
        body.dark-mode {
            --dark: #f6f8fa;
            --bg: #0d1117;
            --border: #30363d;
            --text: #c9d1d9;
            --card-bg: #161b22;
        }
        
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif; 
            background: var(--bg); 
            margin: 0; 
            color: var(--text);
            transition: background 0.3s, color 0.3s;
        }
        
        /* Header & Controls */
        .header { background: var(--dark); color: white; padding: 1rem 2rem; display: flex; justify-content: space-between; align-items: center; }
        .controls { display: flex; gap: 12px; flex-wrap: wrap; background: #fff; padding: 15px 2rem; border-bottom: 1px solid var(--border); position: sticky; top: 0; z-index: 100; align-items: center; }
        
        /* Layout */
        .container { max-width: 1000px; margin: 20px auto; padding: 0 20px; }
        .card { background: var(--card-bg); border: 1px solid var(--border); border-radius: 6px; padding: 16px; margin-bottom: 16px; position: relative; }
        .step-done { background: #f0fff4; border-left: 6px solid var(--primary); }
        body.dark-mode .step-done { background: #0d3818; }
        
        /* Elements */
        pre { background: #1b1f23; color: #e1e4e8; padding: 16px; border-radius: 6px; overflow-x: auto; font-family: ui-monospace, monospace; font-size: 13px; position: relative; }
        .copy-btn { position: absolute; top: 8px; right: 8px; background: #0366d6; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; }
        textarea { width: 100%; margin-top: 10px; border: 1px solid var(--border); border-radius: 6px; padding: 10px; font-family: inherit; box-sizing: border-box; }
        input, select { padding: 8px 12px; border: 1px solid var(--border); border-radius: 6px; font-size: 14px; }
        
        /* Status Indicators */
        .status-area { display: flex; align-items: center; gap: 8px; font-size: 12px; }
        .indicator { width: 10px; height: 10px; border-radius: 50%; background: #d1d5da; }
        .online { background: var(--primary); box-shadow: 0 0 5px var(--primary); }
        .error-msg { background: #ffeef0; color: #d73a49; padding: 10px; border-radius: 6px; margin-bottom: 15px; display: none; border: 1px solid #f97583; }
        
        /* Stage Navigation */
        .stage-tabs { display: flex; gap: 8px; background: var(--card-bg); padding: 15px 2rem; border-bottom: 1px solid var(--border); overflow-x: auto; }
        .stage-tab { padding: 10px 20px; border-radius: 6px 6px 0 0; cursor: pointer; background: var(--bg); border: 1px solid var(--border); border-bottom: none; transition: all 0.2s; white-space: nowrap; }
        .stage-tab:hover { background: #e1e4e8; }
        body.dark-mode .stage-tab:hover { background: #21262d; }
        .stage-tab.active { background: var(--card-bg); border-bottom: 2px solid var(--card-bg); margin-bottom: -1px; font-weight: 600; color: var(--primary); }
        
        /* Progress Indicator */
        .progress-bar { height: 8px; background: var(--bg); border-radius: 4px; margin: 10px 0; overflow: hidden; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, var(--primary), #34d058); transition: width 0.3s ease; }
        
        /* Stage Navigation Buttons */
        .stage-nav { display: flex; justify-content: space-between; margin: 20px 0; }
        .stage-nav button { padding: 10px 20px; border: 1px solid var(--border); border-radius: 6px; cursor: pointer; background: var(--card-bg); font-weight: 500; color: var(--text); }
        .stage-nav button:hover { background: var(--bg); }
        .stage-nav button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        /* Markdown Notes */
        .note-section { margin-top: 15px; border-top: 1px solid var(--border); padding-top: 15px; }
        .note-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .note-header h5 { margin: 0; color: #586069; font-size: 14px; }
        .note-toggle { background: none; border: none; color: var(--primary); cursor: pointer; font-size: 12px; text-decoration: underline; }
        .note-editor { display: none; }
        .note-editor.active { display: block; }
        .note-preview { background: var(--bg); border: 1px solid var(--border); border-radius: 6px; padding: 12px; min-height: 40px; color: #24292e; }
        .note-preview h1, .note-preview h2, .note-preview h3 { margin-top: 0; }
        .note-preview code { background: #1b1f23; color: #e1e4e8; padding: 2px 6px; border-radius: 3px; font-family: ui-monospace, monospace; }
        .note-preview pre { background: #1b1f23; color: #e1e4e8; padding: 12px; border-radius: 6px; overflow-x: auto; }
        .note-preview pre code { background: none; padding: 0; }
        .note-preview ul, .note-preview ol { padding-left: 25px; }
        .note-preview blockquote { border-left: 4px solid var(--border); padding-left: 15px; color: #586069; margin: 10px 0; }
        
        /* Reset Button */
        .reset-btn { background: #d73a49; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500; }
        .reset-btn:hover { background: #cb2431; }
        
        /* Modal */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.4); }
        .modal-content { background-color: var(--card-bg); margin: 15% auto; padding: 20px; border: 1px solid var(--border); border-radius: 6px; width: 400px; max-width: 90%; }
        .modal-buttons { display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px; }
        
        /* Inline editing */
        .editable { cursor: pointer; padding: 2px 6px; border-radius: 4px; transition: background 0.2s; }
        .editable:hover { background: var(--bg); }
        .editing { background: var(--card-bg); border: 1px solid var(--primary); padding: 4px 8px; }
        
        /* Notes toggle button */
        .note-toggle-btn { background: none; border: 1px solid var(--border); padding: 4px 12px; border-radius: 6px; cursor: pointer; color: var(--text); font-size: 12px; }
        .note-toggle-btn:hover { background: var(--bg); }
        .note-toggle-btn.has-notes { background: var(--primary); color: white; border-color: var(--primary); }
        
        /* Add buttons */
        .add-btn { background: var(--primary); color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; margin: 10px 0; }
        .add-btn:hover { background: #2c974b; }
        
        /* Autosave indicator */
        .autosave-indicator { font-size: 11px; color: #586069; margin-left: 10px; }
        
        /* Dark mode toggle */
        .theme-toggle { background: none; border: 1px solid var(--border); padding: 6px 12px; border-radius: 6px; cursor: pointer; color: var(--text); }
        .theme-toggle:hover { background: var(--bg); }
        
        /* Raw editor */
        .raw-editor { width: 100%; height: 500px; font-family: ui-monospace, monospace; font-size: 13px; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--card-bg); color: var(--text); }
        
        /* Image upload */
        .image-upload-area { border: 2px dashed var(--border); border-radius: 6px; padding: 20px; text-align: center; margin: 10px 0; cursor: pointer; }
        .image-upload-area:hover { background: var(--bg); }
        .image-upload-area.dragging { border-color: var(--primary); background: var(--bg); }
    </style>
</head>
<body>

<div class="header">
    <strong>SMAX Multi-Tenant Operations</strong>
    <div class="status-area">
        <button class="theme-toggle" onclick="toggleDarkMode()" title="Toggle dark mode">
            <span id="theme-icon">üåô</span>
        </button>
        <div id="syncInd" class="indicator"></div>
        <span id="syncStat">Offline</span>
        <span id="autosave-status" class="autosave-indicator"></span>
    </div>
</div>

<div class="controls">
    <input type="password" id="ghToken" placeholder="Paste GitHub Token" onchange="connect()">
    
    <select id="selVer" onchange="onVersionChange()">
        <option value="">Select version...</option>
    </select>

    <select id="selClient" onchange="loadData()">
        <option value="">Loading clients...</option>
    </select>

    <label style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
        <input type="checkbox" id="autosaveToggle" onchange="toggleAutosave()" />
        Autosave
    </label>

    <button onclick="saveData()" style="background: var(--primary); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
        üíæ Save Progress
    </button>
    
    <button onclick="showRawEditor()" style="background: #6f42c1; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
        üìù Raw Editor
    </button>
    
    <button onclick="showVersionUpgrade()" style="background: #0366d6; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
        üöÄ Upgrade to Version
    </button>
    
    <button onclick="showResetModal()" class="reset-btn">
        üîÑ Reset All Done Steps
    </button>
</div>

<div id="stage-tabs-container" class="stage-tabs" style="display: none;"></div>

<div class="container">
    <div id="errorBox" class="error-msg"></div>
    
    <!-- Document Title -->
    <div id="doc-title-container" style="display: none; margin-bottom: 20px;">
        <h2 id="doc-title" class="editable" onclick="editTitle()" style="margin: 0; cursor: pointer;">Document Title</h2>
    </div>
    
    <div id="progress-container" style="display: none;">
        <h4>Stage Progress</h4>
        <div class="progress-bar">
            <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
        </div>
        <div style="font-size: 12px; color: #586069; margin-top: 5px;">
            <span id="progress-text">0 of 0 steps completed</span>
        </div>
    </div>

    <div class="card" id="env-vars-card">
        <h4 style="margin-top:0">Environment Variables</h4>
        <div id="var-inputs" style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:15px;"></div>
    </div>
    
    <div class="stage-nav" id="stage-nav" style="display: none;">
        <button id="prev-stage-btn" onclick="prevStage()">‚Üê Previous Stage</button>
        <div>
            <button class="add-btn" onclick="addNewStage()">‚ûï Add New Stage</button>
        </div>
        <button id="next-stage-btn" onclick="nextStage()">Next Stage ‚Üí</button>
    </div>

    <div id="steps-list"></div>
    
    <div style="text-align: center; margin: 20px 0;" id="add-step-container" style="display: none;">
        <button class="add-btn" onclick="addNewStep()">‚ûï Add New Step to Current Stage</button>
    </div>
    
    <div class="stage-nav" id="stage-nav-bottom" style="display: none;">
        <button id="prev-stage-btn-bottom" onclick="prevStage()">‚Üê Previous Stage</button>
        <button id="next-stage-btn-bottom" onclick="nextStage()">Next Stage ‚Üí</button>
    </div>
</div>

<!-- Reset Confirmation Modal -->
<div id="resetModal" class="modal">
    <div class="modal-content">
        <h3 style="margin-top: 0;">Reset Completed Steps</h3>
        <p>Are you sure you want to reset all completed steps? This will mark all steps as incomplete.</p>
        <div class="modal-buttons">
            <button onclick="closeResetModal()" style="padding: 8px 16px; border: 1px solid var(--border); border-radius: 6px; cursor: pointer; background: white;">
                Cancel
            </button>
            <button onclick="confirmReset()" class="reset-btn">
                Reset All
            </button>
        </div>
    </div>
</div>

<!-- Raw Editor Modal -->
<div id="rawEditorModal" class="modal">
    <div class="modal-content" style="width: 80%; max-width: 900px;">
        <h3 style="margin-top: 0;">Raw Markdown Editor</h3>
        <textarea id="rawEditorContent" class="raw-editor"></textarea>
        <div class="modal-buttons">
            <button onclick="closeRawEditor()" style="padding: 8px 16px; border: 1px solid var(--border); border-radius: 6px; cursor: pointer; background: var(--card-bg); color: var(--text);">
                Cancel
            </button>
            <button onclick="saveRawEditor()" style="background: var(--primary); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                Apply Changes
            </button>
        </div>
    </div>
</div>

<!-- Version Upgrade Modal -->
<div id="versionUpgradeModal" class="modal">
    <div class="modal-content">
        <h3 style="margin-top: 0;">Upgrade to New Version</h3>
        <p>Select target version to clone this configuration:</p>
        <select id="targetVersionSelect" style="width: 100%; padding: 8px; margin: 10px 0; border: 1px solid var(--border); border-radius: 6px; background: var(--card-bg); color: var(--text);">
            <option value="">Select version...</option>
        </select>
        <div class="modal-buttons">
            <button onclick="closeVersionUpgrade()" style="padding: 8px 16px; border: 1px solid var(--border); border-radius: 6px; cursor: pointer; background: var(--card-bg); color: var(--text);">
                Cancel
            </button>
            <button onclick="confirmVersionUpgrade()" style="background: var(--primary); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                Upgrade
            </button>
        </div>
    </div>
</div>

<script>
let GITHUB_TOKEN = "";
    let FILE_SHA = "";
    let CURRENT_YAML_PATH = "";
    let config = { title: "", config: {}, stages: [] };
    let currentStageIndex = 0;
    let autosaveEnabled = false;
    let autosaveTimeout = null;

    // Hardcoded repository information for personal use
    const OWNER = "gianandr4";
    const REPO = "SMAX-Upgrade-Tool"; 

    async function connect() {
        GITHUB_TOKEN = document.getElementById('ghToken').value;
        if (!GITHUB_TOKEN) {
            showError('Please enter a GitHub token');
            return;
        }
        console.log('[SMAX Tool] Connecting with GitHub token...');
        // Step 1: Dynamically find folders
        await fetchFolders();
        // Step 2: Load data for the first folder found
        loadData();
    }

    // NEW: Automatically find version folders (e.g., 24.4, 25.1)
    async function fetchFolders() {
        if (!GITHUB_TOKEN) return;
        try {
            console.log(`[SMAX Tool] Fetching folders from ${OWNER}/${REPO}...`);
            const resp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/`, {
                headers: { Authorization: `token ${GITHUB_TOKEN}` }
            });
            
            if (!resp.ok) {
                const errorData = await resp.json();
                throw new Error(`GitHub API: ${errorData.message || resp.statusText}`);
            }
            
            const items = await resp.json();
            const folderSelect = document.getElementById('selVer');
            
            // Clear existing options
            folderSelect.innerHTML = "";

            // Filter for directories that look like versions (numbers/dots)
            const folders = items.filter(item => item.type === 'dir' && !item.name.startsWith('.'));
            
            if (folders.length === 0) {
                showError('No version folders found in repository');
                return;
            }
            
            folders.forEach(folder => {
                const opt = document.createElement('option');
                opt.value = folder.name;
                opt.innerText = `Version ${folder.name}`;
                folderSelect.appendChild(opt);
            });
            
            console.log(`[SMAX Tool] Found ${folders.length} version folder(s)`);
            
            // Load clients for the first version
            if (folders.length > 0) {
                await fetchClients(folders[0].name);
            }
        } catch (e) {
            console.error('[SMAX Tool] fetchFolders error:', e);
            showError(`Failed to load folders: ${e.message}`);
        }
    }
    
    // NEW: Fetch clients from version folder
    async function fetchClients(version) {
        if (!GITHUB_TOKEN) return;
        try {
            console.log(`[SMAX Tool] Fetching clients from ${version}/...`);
            const resp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${version}`, {
                headers: { Authorization: `token ${GITHUB_TOKEN}` }
            });
            
            if (!resp.ok) {
                const errorData = await resp.json();
                throw new Error(`GitHub API: ${errorData.message || resp.statusText}`);
            }
            
            const items = await resp.json();
            const clientSelect = document.getElementById('selClient');
            
            // Clear existing options
            clientSelect.innerHTML = "";
            
            // Find all client markdown files (excluding README.md)
            const clientFiles = items.filter(item => 
                item.type === 'file' && 
                item.name.endsWith('.md') &&
                item.name !== 'README.md' &&
                item.name !== 'template.md'
            );
            
            if (clientFiles.length === 0) {
                clientSelect.innerHTML = '<option value="">No clients found</option>';
                return;
            }
            
            // Extract client names
            const clients = new Set();
            clientFiles.forEach(file => {
                // Extract client name from filename (e.g., "client-A.md")
                const clientName = file.name.replace(/\.md$/, '');
                clients.add(clientName);
            });
            
            clients.forEach(client => {
                const opt = document.createElement('option');
                opt.value = client;
                opt.innerText = client.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                clientSelect.appendChild(opt);
            });
            
            console.log(`[SMAX Tool] Found ${clients.size} client(s)`);
        } catch (e) {
            console.error('[SMAX Tool] fetchClients error:', e);
            showError(`Failed to load clients: ${e.message}`);
        }
    }
    
    // NEW: Parse markdown with front-matter
    function parseMarkdownFrontMatter(content) {
        // Extract front-matter (between --- delimiters)
        const frontMatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
        const match = content.match(frontMatterRegex);
        
        if (!match) {
            throw new Error('Invalid markdown format: missing front-matter');
        }
        
        const frontMatter = jsyaml.load(match[1]);
        const markdown = match[2];
        
        return { config: frontMatter.config || {}, markdown };
    }
    
    // NEW: Parse markdown content into title, stages and steps
    // # = Document title
    // ## = Stages
    // ### = Steps
    function parseMarkdownStages(markdown) {
        const stages = [];
        const lines = markdown.split('\n');
        
        let documentTitle = '';
        let currentStage = null;
        let currentStep = null;
        let collectingCommand = false;
        let collectingNotes = false;
        let commandBuffer = [];
        let notesBuffer = [];
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            // H1 = Document Title
            if (line.startsWith('# ') && !line.startsWith('## ')) {
                documentTitle = line.substring(2).trim();
                continue;
            }
            
            // H2 = New Stage
            if (line.startsWith('## ') && !line.startsWith('### ')) {
                if (currentStep && currentStage) {
                    currentStage.steps.push(currentStep);
                }
                if (currentStage) {
                    stages.push(currentStage);
                }
                
                currentStage = {
                    name: line.substring(3).trim(),
                    steps: []
                };
                currentStep = null;
                collectingCommand = false;
                collectingNotes = false;
                continue;
            }
            
            // H3 = New Step
            if (line.startsWith('### ')) {
                if (currentStep && currentStage) {
                    currentStage.steps.push(currentStep);
                }
                
                const title = line.substring(4).trim();
                currentStep = {
                    id: title.toLowerCase().replace(/[^a-z0-9]+/g, '_'),
                    title: title,
                    notes: '',
                    command: '',
                    done: false,
                    userNotes: ''
                };
                collectingCommand = false;
                collectingNotes = false;
                commandBuffer = [];
                notesBuffer = [];
                continue;
            }
            
            // Code block start/end
            if (line.trim().startsWith('```')) {
                if (collectingCommand) {
                    // End of command block
                    if (currentStep) {
                        currentStep.command = commandBuffer.join('\n').trim();
                    }
                    collectingCommand = false;
                    commandBuffer = [];
                } else {
                    // Start of command block
                    collectingCommand = true;
                }
                continue;
            }
            
            // Inside command block
            if (collectingCommand) {
                commandBuffer.push(line);
                continue;
            }
            
            // Checkbox for done status
            if (line.trim().startsWith('- [x]') || line.trim().startsWith('- [X]')) {
                if (currentStep) {
                    currentStep.done = true;
                }
                continue;
            }
            
            if (line.trim().startsWith('- [ ]')) {
                if (currentStep) {
                    currentStep.done = false;
                }
                continue;
            }
            
            // Personal notes marker
            if (line.trim().startsWith('**Personal Notes:**') || 
                line.trim().startsWith('**Notes:**') ||
                line.trim().startsWith('**User Notes:**')) {
                collectingNotes = true;
                notesBuffer = [];
                continue;
            }
            
            // Collect notes
            if (collectingNotes && currentStep) {
                if (line.trim() === '' && notesBuffer.length > 0) {
                    // Empty line after notes might end the notes section
                    currentStep.userNotes = notesBuffer.join('\n').trim();
                    collectingNotes = false;
                } else if (line.trim() !== '') {
                    notesBuffer.push(line);
                }
                continue;
            }
            
            // Regular content (step description/notes)
            if (currentStep && line.trim() !== '' && !collectingCommand && !collectingNotes) {
                if (currentStep.notes) {
                    currentStep.notes += '\n' + line.trim();
                } else {
                    currentStep.notes = line.trim();
                }
            }
        }
        
        // Add last step and stage
        if (currentStep && currentStage) {
            if (collectingNotes && notesBuffer.length > 0) {
                currentStep.userNotes = notesBuffer.join('\n').trim();
            }
            currentStage.steps.push(currentStep);
        }
        if (currentStage) {
            stages.push(currentStage);
        }
        
        return { title: documentTitle, stages: stages };
    }
    
    // NEW: Try to load markdown format
    async function tryLoadMarkdown(ver, client, mdPath) {
        try {
            let mdContent;
            
            if (GITHUB_TOKEN) {
                const resp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${mdPath}`, {
                    headers: { Authorization: `token ${GITHUB_TOKEN}` }
                });
                
                if (resp.status === 404) {
                    return false; // File doesn't exist, try YAML
                }
                
                if (!resp.ok) {
                    return false;
                }
                
                const data = await resp.json();
                FILE_SHA = data.sha;
                CURRENT_YAML_PATH = mdPath;
                mdContent = atob(data.content);
            } else {
                const resp = await fetch(mdPath);
                if (!resp.ok) return false;
                CURRENT_YAML_PATH = mdPath;
                mdContent = await resp.text();
            }
            
            console.log(`[SMAX Tool] Loading markdown from ${mdPath}...`);
            
            // Parse markdown
            const { config: configData, markdown } = parseMarkdownFrontMatter(mdContent);
            const { title, stages } = parseMarkdownStages(markdown);
            
            config = {
                title: title,
                config: configData,
                stages: stages
            };
            
            console.log(`[SMAX Tool] Loaded title: "${title}", ${stages.length} stage(s) from markdown`);
            
            if (GITHUB_TOKEN) {
                document.getElementById('syncInd').classList.add('online');
                document.getElementById('syncStat').innerText = `Synced: ${ver}/${client}`;
            }
            
            currentStageIndex = 0;
            renderTitle();
            renderVars();
            renderStageTabs();
            renderCurrentStage();
            updateProgress();
            
            return true;
            
        } catch (e) {
            console.error('[SMAX Tool] Failed to load markdown:', e);
            return false;
        }
    }

    // NEW: Handle version change - refresh client list
    async function onVersionChange() {
        const ver = document.getElementById('selVer').value;
        if (!ver) return;
        
        await fetchClients(ver);
        // Don't auto-load data, wait for user to select a client
    }
    
    async function loadData() {
        showError(""); 
        const ver = document.getElementById('selVer').value;
        const client = document.getElementById('selClient').value;
        
        if (!ver || !client) {
            console.log('[SMAX Tool] Waiting for version and client to be selected...');
            return;
        }

        // Only support markdown format now
        const mdPath = `${ver}/${client}.md`;
        
        // Try markdown first
        if (await tryLoadMarkdown(ver, client, mdPath)) {
            renderTitle();
            return;
        }
        
        // If no markdown, check for YAML and migrate
        const yamlPath = `${ver}/${client}.yaml`;
        console.log(`[SMAX Tool] No markdown found, checking for YAML to migrate...`);
        
        try {
            let yamlContent;
            let yamlSha = "";
            
            if (GITHUB_TOKEN) {
                const resp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${yamlPath}`, {
                    headers: { Authorization: `token ${GITHUB_TOKEN}` }
                });
                
                if (resp.status === 404) {
                    // Try to migrate from old format
                    console.log('[SMAX Tool] YAML not found, attempting migration from old format...');
                    await migrateFromOldFormat(ver, client);
                    return;
                }
                
                if (!resp.ok) {
                    const errorData = await resp.json();
                    throw new Error(`GitHub API: ${errorData.message || resp.statusText}`);
                }
                
                const data = await resp.json();
                yamlSha = data.sha;
                yamlContent = atob(data.content);
            } else {
                const resp = await fetch(yamlPath);
                if (!resp.ok) throw new Error(`No configuration found for ${client}`);
                yamlContent = await resp.text();
            }
            
            // Parse YAML
            let yamlConfig = jsyaml.load(yamlContent);
            
            if (!yamlConfig) {
                throw new Error('Invalid YAML structure');
            }
            
            // Convert old 'steps' to 'stages'
            if (yamlConfig.steps && !yamlConfig.stages) {
                console.log('[SMAX Tool] Converting old steps format to stages...');
                yamlConfig.stages = [{
                    name: 'Upgrade',
                    steps: yamlConfig.steps
                }];
                delete yamlConfig.steps;
            }
            
            // Migrate to markdown
            console.log('[SMAX Tool] Migrating YAML to Markdown format...');
            config = {
                title: yamlConfig.title || `${client} Upgrade`,
                config: yamlConfig.config || {},
                stages: yamlConfig.stages || []
            };
            
            // Save as markdown
            CURRENT_YAML_PATH = mdPath;
            FILE_SHA = ""; // New file
            await saveData();
            
            console.log('[SMAX Tool] Migration complete, reloading...');
            await loadData();
            
        } catch (e) {
            console.error('[SMAX Tool] loadData error:', e);
            showError(e.message);
        }
    }
    
    // NEW: Migrate from old format to new markdown format
    async function migrateFromOldFormat(ver, client) {
        try {
            console.log('[SMAX Tool] Migrating from old format...');
            
            // Try to load old managed or embedded steps file
            let oldStepsPath = `${ver}/${client}-managed-steps.yaml`;
            let oldStatePath = `${ver}/state-${client}.yaml`;
            
            let stepsResp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${oldStepsPath}`, {
                headers: { Authorization: `token ${GITHUB_TOKEN}` }
            });
            
            if (stepsResp.status === 404) {
                // Try embedded format
                oldStepsPath = `${ver}/${client}-embedded-steps.yaml`;
                stepsResp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${oldStepsPath}`, {
                    headers: { Authorization: `token ${GITHUB_TOKEN}` }
                });
            }
            
            if (!stepsResp.ok) {
                throw new Error(`No client configuration found for ${client}`);
            }
            
            const stepsData = await stepsResp.json();
            const oldConfig = jsyaml.load(atob(stepsData.content));
            
            // Load old state file if exists
            let state = {};
            const stateResp = await fetch(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${oldStatePath}`, {
                headers: { Authorization: `token ${GITHUB_TOKEN}` }
            });
            
            if (stateResp.ok) {
                const stateData = await stateResp.json();
                state = jsyaml.load(atob(stateData.content)) || {};
            }
            
            // Create new unified config in markdown format
            config = {
                title: `${client} Upgrade to v${ver}`,
                config: oldConfig.config || {},
                stages: [{
                    name: 'Upgrade',
                    steps: (oldConfig.steps || []).map(step => {
                        return {
                            ...step,
                            done: state[`s_done_${step.id}`] === 'true',
                            userNotes: ''
                        };
                    })
                }]
            };
            
            // Apply variable state
            Object.keys(config.config).forEach(key => {
                if (state[`v_${key}`]) {
                    config.config[key] = state[`v_${key}`];
                }
            });
            
            // Save as markdown
            CURRENT_YAML_PATH = `${ver}/${client}.md`;
            FILE_SHA = ""; // Will create new file
            await saveData();
            
            console.log('[SMAX Tool] Migration complete, reloading...');
            await loadData();
            
        } catch (e) {
            console.error('[SMAX Tool] Migration error:', e);
            showError(`Migration failed: ${e.message}`);
        }
    }

    // Error handling with better logging
    function showError(msg) {
        const box = document.getElementById('errorBox');
        if (msg) {
            console.error('[SMAX Tool Error]:', msg);
            box.innerText = `‚ö†Ô∏è Error: ${msg}`;
            box.style.display = 'block';
        } else {
            box.style.display = 'none';
        }
    }

    // Render environment variables
    function renderVars() {
        const varInputs = document.getElementById('var-inputs');
        varInputs.innerHTML = '';
        
        if (!config.config) return;
        
        Object.entries(config.config).forEach(([key, defaultVal]) => {
            const wrapper = document.createElement('div');
            
            // Create label
            const label = document.createElement('label');
            label.style.fontSize = '12px';
            label.style.color = '#586069';
            label.style.display = 'block';
            label.style.marginBottom = '4px';
            label.textContent = key;
            
            // Create input
            const input = document.createElement('input');
            input.type = 'text';
            input.id = `var_${key}`;
            input.value = defaultVal;
            input.style.width = '100%';
            input.style.boxSizing = 'border-box';
            input.onchange = function() {
                config.config[key] = this.value;
            };
            
            wrapper.appendChild(label);
            wrapper.appendChild(input);
            varInputs.appendChild(wrapper);
        });
    }
    
    // NEW: Render stage tabs
    function renderStageTabs() {
        const container = document.getElementById('stage-tabs-container');
        container.innerHTML = '';
        container.style.display = 'flex';
        
        if (!config.stages || config.stages.length === 0) {
            container.style.display = 'none';
            return;
        }
        
        config.stages.forEach((stage, index) => {
            const tab = document.createElement('div');
            tab.className = 'stage-tab';
            if (index === currentStageIndex) {
                tab.className += ' active';
            }
            
            // Calculate completion for this stage
            const totalSteps = stage.steps.length;
            const completedSteps = stage.steps.filter(s => s.done).length;
            
            const stageName = document.createElement('div');
            stageName.textContent = stage.name;
            stageName.className = 'editable';
            stageName.ondblclick = (e) => {
                e.stopPropagation();
                editStageName(index);
            };
            stageName.title = 'Double-click to edit';
            
            const stageInfo = document.createElement('div');
            stageInfo.style.fontSize = '11px';
            stageInfo.style.color = '#586069';
            stageInfo.style.marginTop = '3px';
            stageInfo.textContent = `${completedSteps}/${totalSteps} steps`;
            
            tab.appendChild(stageName);
            tab.appendChild(stageInfo);
            
            tab.onclick = () => {
                currentStageIndex = index;
                renderStageTabs();
                renderCurrentStage();
                updateProgress();
            };
            
            container.appendChild(tab);
        });
    }
    
    // NEW: Render current stage
    function renderCurrentStage() {
        if (!config.stages || config.stages.length === 0) {
            document.getElementById('steps-list').innerHTML = '<p style="color:#586069;">No stages found.</p>';
            document.getElementById('stage-nav').style.display = 'none';
            document.getElementById('stage-nav-bottom').style.display = 'none';
            return;
        }
        
        const stage = config.stages[currentStageIndex];
        renderSteps(stage.steps);
        
        // Update navigation buttons
        document.getElementById('stage-nav').style.display = 'flex';
        document.getElementById('stage-nav-bottom').style.display = 'flex';
        
        const prevBtn = document.getElementById('prev-stage-btn');
        const nextBtn = document.getElementById('next-stage-btn');
        const prevBtnBottom = document.getElementById('prev-stage-btn-bottom');
        const nextBtnBottom = document.getElementById('next-stage-btn-bottom');
        
        prevBtn.disabled = currentStageIndex === 0;
        nextBtn.disabled = currentStageIndex === config.stages.length - 1;
        prevBtnBottom.disabled = currentStageIndex === 0;
        nextBtnBottom.disabled = currentStageIndex === config.stages.length - 1;
    }
    
    // NEW: Stage navigation
    function prevStage() {
        if (currentStageIndex > 0) {
            currentStageIndex--;
            renderStageTabs();
            renderCurrentStage();
            updateProgress();
            window.scrollTo(0, 0);
        }
    }
    
    function nextStage() {
        if (currentStageIndex < config.stages.length - 1) {
            currentStageIndex++;
            renderStageTabs();
            renderCurrentStage();
            updateProgress();
            window.scrollTo(0, 0);
        }
    }
    
    // NEW: Update progress indicator
    function updateProgress() {
        if (!config.stages || config.stages.length === 0) {
            document.getElementById('progress-container').style.display = 'none';
            return;
        }
        
        document.getElementById('progress-container').style.display = 'block';
        
        // Calculate total progress across all stages
        let totalSteps = 0;
        let completedSteps = 0;
        
        config.stages.forEach(stage => {
            totalSteps += stage.steps.length;
            completedSteps += stage.steps.filter(s => s.done).length;
        });
        
        const percentage = totalSteps > 0 ? (completedSteps / totalSteps * 100).toFixed(0) : 0;
        
        document.getElementById('progress-fill').style.width = `${percentage}%`;
        document.getElementById('progress-text').textContent = `${completedSteps} of ${totalSteps} steps completed (${percentage}%)`;
    }

    // Copy to clipboard function
    function copyToClipboard(text) {
        if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(text).then(() => {
                console.log('[SMAX Tool] Copied to clipboard');
                // Visual feedback could be added here
            }).catch(err => {
                console.error('[SMAX Tool] Failed to copy:', err);
                fallbackCopy(text);
            });
        } else {
            fallbackCopy(text);
        }
    }

    // Fallback copy method for older browsers
    function fallbackCopy(text) {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.select();
        try {
            // Note: execCommand is deprecated but kept as fallback for legacy browser support
            document.execCommand('copy');
            console.log('[SMAX Tool] Copied using fallback method');
        } catch (err) {
            console.error('[SMAX Tool] Fallback copy failed:', err);
            showError('Copy failed. Please copy manually.');
        }
        document.body.removeChild(textarea);
    }

    // Replace placeholders in commands with actual values
    // Replace placeholders in commands with actual values
    // Supports both {{variable}} and <variable> formats
    function interpolate(str) {
        if (!str) return '';
        let result = str;
        Object.keys(config.config || {}).forEach(key => {
            const val = config.config[key] || '';
            // Replace {{key}} format
            result = result.replace(new RegExp(`{{${key}}}`, 'g'), val);
            // Replace <key> format (case-insensitive)
            result = result.replace(new RegExp(`<${key}>`, 'gi'), val);
            // Also try uppercase version for <KEY> format
            const upperKey = key.toUpperCase();
            result = result.replace(new RegExp(`<${upperKey}>`, 'g'), val);
        });
        return result;
    }

    // Render steps with checkboxes, inline editing, and minimal notes UI
    function renderSteps(steps) {
        const stepsList = document.getElementById('steps-list');
        stepsList.innerHTML = '';
        
        if (!steps || steps.length === 0) {
            stepsList.innerHTML = '<p style="color:#586069;">No steps in this stage.</p>';
            document.getElementById('add-step-container').style.display = 'block';
            return;
        }
        
        document.getElementById('add-step-container').style.display = 'block';
        
        steps.forEach((step, stepIndex) => {
            const isDone = step.done || false;
            const card = document.createElement('div');
            card.className = `card ${isDone ? 'step-done' : ''}`;
            card.id = `step_${currentStageIndex}_${stepIndex}`;
            
            // Header with checkbox and title
            const header = document.createElement('div');
            header.style.display = 'flex';
            header.style.justifyContent = 'space-between';
            header.style.alignItems = 'center';
            header.style.marginBottom = '12px';
            
            const leftSection = document.createElement('div');
            leftSection.style.display = 'flex';
            leftSection.style.alignItems = 'center';
            leftSection.style.gap = '8px';
            leftSection.style.flex = '1';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `check_${currentStageIndex}_${stepIndex}`;
            checkbox.checked = isDone;
            checkbox.style.width = '18px';
            checkbox.style.height = '18px';
            checkbox.style.cursor = 'pointer';
            checkbox.onchange = function() {
                toggleStep(currentStageIndex, stepIndex, this.checked);
            };
            
            const title = document.createElement('strong');
            title.className = 'editable';
            title.style.fontSize = '16px';
            title.style.cursor = 'pointer';
            title.textContent = step.title || 'Untitled Step';
            title.onclick = () => editStepTitle(currentStageIndex, stepIndex);
            title.title = 'Click to edit title';
            
            leftSection.appendChild(checkbox);
            leftSection.appendChild(title);
            
            // Right section with notes button and edit buttons
            const rightSection = document.createElement('div');
            rightSection.style.display = 'flex';
            rightSection.style.gap = '6px';
            
            // Minimal notes button
            const notesBtn = document.createElement('button');
            notesBtn.className = `note-toggle-btn ${step.userNotes ? 'has-notes' : ''}`;
            notesBtn.innerHTML = step.userNotes ? 'üí¨ Notes' : 'üí¨';
            notesBtn.title = step.userNotes ? 'View/Edit notes' : 'Add notes';
            notesBtn.onclick = () => toggleNoteEditor(currentStageIndex, stepIndex);
            
            rightSection.appendChild(notesBtn);
            
            header.appendChild(leftSection);
            header.appendChild(rightSection);
            card.appendChild(header);
            
            // Add default notes if present (editable)
            if (step.notes) {
                const notesDiv = document.createElement('div');
                notesDiv.className = 'editable';
                notesDiv.style.color = '#586069';
                notesDiv.style.margin = '8px 0';
                notesDiv.style.fontStyle = 'italic';
                notesDiv.style.cursor = 'pointer';
                notesDiv.textContent = step.notes;
                notesDiv.onclick = () => editStepNotes(currentStageIndex, stepIndex);
                notesDiv.title = 'Click to edit description';
                card.appendChild(notesDiv);
            }
            
            // Add command with copy and edit buttons
            if (step.command) {
                const interpolatedCommand = interpolate(step.command);
                const commandContainer = document.createElement('div');
                commandContainer.style.position = 'relative';
                commandContainer.style.marginTop = '12px';
                
                const pre = document.createElement('pre');
                pre.style.position = 'relative';
                pre.style.cursor = 'pointer';
                pre.onclick = () => editStepCommand(currentStageIndex, stepIndex);
                pre.title = 'Click to edit command';
                
                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-btn';
                copyBtn.textContent = 'Copy';
                copyBtn.onclick = function(e) {
                    e.stopPropagation();
                    copyToClipboard(interpolatedCommand);
                };
                
                const commandText = document.createTextNode(interpolatedCommand);
                
                pre.appendChild(copyBtn);
                pre.appendChild(commandText);
                commandContainer.appendChild(pre);
                card.appendChild(commandContainer);
            }
            
            // Collapsible note editor section
            const noteEditor = document.createElement('div');
            noteEditor.className = 'note-editor';
            noteEditor.id = `note-editor_${currentStageIndex}_${stepIndex}`;
            noteEditor.style.marginTop = '15px';
            noteEditor.style.borderTop = '1px solid var(--border)';
            noteEditor.style.paddingTop = '15px';
            
            const noteTextarea = document.createElement('textarea');
            noteTextarea.id = `note-textarea_${currentStageIndex}_${stepIndex}`;
            noteTextarea.value = step.userNotes || '';
            noteTextarea.placeholder = 'Enter notes in Markdown format...\n\nYou can:\n- Paste images directly (Ctrl+V)\n- Drag and drop images\n- Use **bold**, *italic*, lists, etc.';
            noteTextarea.rows = 6;
            noteTextarea.style.marginBottom = '10px';
            
            // Setup image paste/drop
            setupImagePaste(noteTextarea);
            
            // Live preview
            const notePreview = document.createElement('div');
            notePreview.className = 'note-preview';
            notePreview.id = `note-preview_${currentStageIndex}_${stepIndex}`;
            notePreview.style.marginBottom = '10px';
            if (step.userNotes) {
                notePreview.innerHTML = marked.parse(step.userNotes);
            } else {
                notePreview.innerHTML = '<span style="color: #586069; font-style: italic;">Preview will appear here...</span>';
            }
            
            noteTextarea.oninput = () => {
                if (noteTextarea.value) {
                    notePreview.innerHTML = marked.parse(noteTextarea.value);
                } else {
                    notePreview.innerHTML = '<span style="color: #586069; font-style: italic;">Preview will appear here...</span>';
                }
            };
            
            const noteButtons = document.createElement('div');
            noteButtons.style.display = 'flex';
            noteButtons.style.gap = '10px';
            
            const saveNoteBtn = document.createElement('button');
            saveNoteBtn.textContent = 'üíæ Save Note';
            saveNoteBtn.style.background = 'var(--primary)';
            saveNoteBtn.style.color = 'white';
            saveNoteBtn.style.border = 'none';
            saveNoteBtn.style.padding = '8px 16px';
            saveNoteBtn.style.borderRadius = '6px';
            saveNoteBtn.style.cursor = 'pointer';
            saveNoteBtn.onclick = () => saveNote(currentStageIndex, stepIndex);
            
            const cancelNoteBtn = document.createElement('button');
            cancelNoteBtn.textContent = 'Cancel';
            cancelNoteBtn.style.padding = '8px 16px';
            cancelNoteBtn.style.border = '1px solid var(--border)';
            cancelNoteBtn.style.borderRadius = '6px';
            cancelNoteBtn.style.cursor = 'pointer';
            cancelNoteBtn.style.background = 'var(--card-bg)';
            cancelNoteBtn.style.color = 'var(--text)';
            cancelNoteBtn.onclick = () => toggleNoteEditor(currentStageIndex, stepIndex);
            
            noteButtons.appendChild(saveNoteBtn);
            noteButtons.appendChild(cancelNoteBtn);
            
            noteEditor.appendChild(noteTextarea);
            noteEditor.appendChild(document.createTextNode('Preview:'));
            noteEditor.appendChild(notePreview);
            noteEditor.appendChild(noteButtons);
            
            card.appendChild(noteEditor);
            stepsList.appendChild(card);
        });
    }
    
    // NEW: Toggle note editor
    function toggleNoteEditor(stageIndex, stepIndex) {
        const editor = document.getElementById(`note-editor_${stageIndex}_${stepIndex}`);
        if (editor) {
            editor.classList.toggle('active');
        }
    }
    
    // NEW: Save note
    function saveNote(stageIndex, stepIndex) {
        const textarea = document.getElementById(`note-textarea_${stageIndex}_${stepIndex}`);
        config.stages[stageIndex].steps[stepIndex].userNotes = textarea.value;
        
        // Close editor and re-render to update button
        toggleNoteEditor(stageIndex, stepIndex);
        renderCurrentStage();
        
        console.log('[SMAX Tool] Note saved for step', stepIndex);
        triggerAutosave();
    }

    // Toggle step completion status
    function toggleStep(stageIndex, stepIndex, checked) {
        config.stages[stageIndex].steps[stepIndex].done = checked;
        const card = document.getElementById(`step_${stageIndex}_${stepIndex}`);
        if (card) {
            if (checked) {
                card.classList.add('step-done');
            } else {
                card.classList.remove('step-done');
            }
        }
        console.log(`[SMAX Tool] Step ${stepIndex} in stage ${stageIndex} marked as ${checked ? 'done' : 'pending'}`);
        
        // Update progress and stage tabs
        updateProgress();
        renderStageTabs();
        triggerAutosave();
    }
    
    // NEW: Reset modal functions
    function showResetModal() {
        document.getElementById('resetModal').style.display = 'block';
    }
    
    function closeResetModal() {
        document.getElementById('resetModal').style.display = 'none';
    }
    
    function confirmReset() {
        if (!config.stages) return;
        
        // Reset all steps
        config.stages.forEach(stage => {
            stage.steps.forEach(step => {
                step.done = false;
            });
        });
        
        // Re-render
        renderStageTabs();
        renderCurrentStage();
        updateProgress();
        closeResetModal();
        
        console.log('[SMAX Tool] All steps reset');
        showSuccess('All steps have been reset');
    }

    // Show success message (non-blocking)
    function showSuccess(msg) {
        const box = document.getElementById('errorBox');
        box.innerText = `‚úÖ ${msg}`;
        box.style.display = 'block';
        box.style.background = '#d4edda';
        box.style.color = '#155724';
        box.style.borderColor = '#c3e6cb';
        
        // Auto-hide after 3 seconds
        setTimeout(() => {
            box.style.display = 'none';
            box.style.background = '#ffeef0';
            box.style.color = '#d73a49';
            box.style.borderColor = '#f97583';
        }, 3000);
    }

    // Convert config to markdown format with new structure
    // # = Document title
    // ## = Stages
    // ### = Steps
    function convertToMarkdown() {
        let md = '---\n';
        md += jsyaml.dump({ config: config.config });
        md += '---\n\n';
        
        // Add document title
        if (config.title) {
            md += `# ${config.title}\n\n`;
        }
        
        config.stages.forEach(stage => {
            md += `## ${stage.name}\n\n`;
            
            stage.steps.forEach(step => {
                md += `### ${step.title}\n\n`;
                
                if (step.notes) {
                    md += `${step.notes}\n\n`;
                }
                
                if (step.command) {
                    md += '```bash\n';
                    md += step.command + '\n';
                    md += '```\n\n';
                }
                
                // Checkbox for completion status
                md += step.done ? '- [x] Step completed\n' : '- [ ] Step not completed\n';
                
                if (step.userNotes) {
                    md += '\n**Personal Notes:**\n';
                    md += step.userNotes + '\n';
                }
                
                md += '\n---\n\n';
            });
        });
        
        return md;
    }
    
    // Save data function to push markdown back to GitHub
    async function saveData() {
        if (!GITHUB_TOKEN) {
            showError('GitHub token required. Please enter token and connect.');
            return;
        }
        
        if (!CURRENT_YAML_PATH) {
            showError('No file path selected. Please load data first.');
            return;
        }
        
        try {
            // Always save as markdown
            const fileContent = convertToMarkdown();
            const encodedContent = btoa(fileContent);
            
            // Update file on GitHub
            const updatePayload = {
                message: `Update ${document.getElementById('selClient').value} configuration`,
                content: encodedContent
            };
            
            // Only include SHA if file exists (for updates)
            if (FILE_SHA) {
                updatePayload.sha = FILE_SHA;
            }
            
            console.log('[SMAX Tool] Saving to GitHub:', CURRENT_YAML_PATH);
            
            const response = await fetch(
                `https://api.github.com/repos/${OWNER}/${REPO}/contents/${CURRENT_YAML_PATH}`,
                {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${GITHUB_TOKEN}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updatePayload)
                }
            );
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`GitHub API error: ${errorData.message || response.statusText}`);
            }
            
            const result = await response.json();
            FILE_SHA = result.content.sha; // Update SHA for next save
            
            document.getElementById('syncInd').classList.add('online');
            document.getElementById('syncStat').innerText = `Synced: ${document.getElementById('selVer').value}/${document.getElementById('selClient').value}`;
            
            console.log('[SMAX Tool] Data saved successfully');
            showSuccess('Progress saved to GitHub!');
            
        } catch (error) {
            console.error('[SMAX Tool] Save failed:', error);
            showError(`Failed to save: ${error.message}`);
        }
    }
    
    // Autosave functionality
    function toggleAutosave() {
        autosaveEnabled = document.getElementById('autosaveToggle').checked;
        const status = document.getElementById('autosave-status');
        if (autosaveEnabled) {
            status.textContent = 'Autosave enabled';
            status.style.color = 'var(--primary)';
        } else {
            status.textContent = '';
            if (autosaveTimeout) {
                clearTimeout(autosaveTimeout);
                autosaveTimeout = null;
            }
        }
    }
    
    function triggerAutosave() {
        if (!autosaveEnabled) return;
        
        // Clear existing timeout
        if (autosaveTimeout) {
            clearTimeout(autosaveTimeout);
        }
        
        // Set new timeout (debounced save after 3 seconds)
        autosaveTimeout = setTimeout(async () => {
            const status = document.getElementById('autosave-status');
            status.textContent = 'Saving...';
            await saveData();
            status.textContent = 'Autosaved';
            setTimeout(() => {
                status.textContent = 'Autosave enabled';
            }, 2000);
        }, 3000);
    }
    
    // Dark mode toggle
    function toggleDarkMode() {
        document.body.classList.toggle('dark-mode');
        const icon = document.getElementById('theme-icon');
        if (document.body.classList.contains('dark-mode')) {
            icon.textContent = '‚òÄÔ∏è';
            localStorage.setItem('darkMode', 'true');
        } else {
            icon.textContent = 'üåô';
            localStorage.setItem('darkMode', 'false');
        }
    }
    
    // Initialize dark mode from localStorage
    if (localStorage.getItem('darkMode') === 'true') {
        document.body.classList.add('dark-mode');
        document.getElementById('theme-icon').textContent = '‚òÄÔ∏è';
    }
    
    // Render document title
    function renderTitle() {
        const titleContainer = document.getElementById('doc-title-container');
        const titleElement = document.getElementById('doc-title');
        if (config.title) {
            titleContainer.style.display = 'block';
            titleElement.textContent = config.title;
        } else {
            titleContainer.style.display = 'none';
        }
    }
    
    // Edit title inline
    function editTitle() {
        const titleElement = document.getElementById('doc-title');
        const currentTitle = config.title || '';
        
        const input = document.createElement('input');
        input.type = 'text';
        input.value = currentTitle;
        input.style.width = '100%';
        input.style.fontSize = '1.5em';
        input.style.fontWeight = 'bold';
        input.style.padding = '4px';
        input.style.border = '1px solid var(--primary)';
        input.style.borderRadius = '4px';
        input.style.background = 'var(--card-bg)';
        input.style.color = 'var(--text)';
        
        titleElement.replaceWith(input);
        input.focus();
        input.select();
        
        const saveTitle = () => {
            const newTitle = input.value.trim();
            config.title = newTitle;
            const newTitleElement = document.createElement('h2');
            newTitleElement.id = 'doc-title';
            newTitleElement.className = 'editable';
            newTitleElement.onclick = editTitle;
            newTitleElement.style.margin = '0';
            newTitleElement.style.cursor = 'pointer';
            newTitleElement.textContent = newTitle || 'Document Title';
            input.replaceWith(newTitleElement);
            triggerAutosave();
        };
        
        input.onblur = saveTitle;
        input.onkeypress = (e) => {
            if (e.key === 'Enter') {
                saveTitle();
            }
        };
    }
    
    // Edit stage name inline
    function editStageName(stageIndex) {
        const stage = config.stages[stageIndex];
        const newName = prompt('Edit stage name:', stage.name);
        if (newName && newName.trim()) {
            stage.name = newName.trim();
            renderStageTabs();
            renderCurrentStage();
            triggerAutosave();
        }
    }
    
    // Edit step inline
    function editStepTitle(stageIndex, stepIndex) {
        const step = config.stages[stageIndex].steps[stepIndex];
        const newTitle = prompt('Edit step title:', step.title);
        if (newTitle && newTitle.trim()) {
            step.title = newTitle.trim();
            step.id = newTitle.toLowerCase().replace(/[^a-z0-9]+/g, '_');
            renderCurrentStage();
            triggerAutosave();
        }
    }
    
    function editStepCommand(stageIndex, stepIndex) {
        const step = config.stages[stageIndex].steps[stepIndex];
        const newCommand = prompt('Edit command:', step.command);
        if (newCommand !== null) {
            step.command = newCommand;
            renderCurrentStage();
            triggerAutosave();
        }
    }
    
    function editStepNotes(stageIndex, stepIndex) {
        const step = config.stages[stageIndex].steps[stepIndex];
        const newNotes = prompt('Edit description:', step.notes);
        if (newNotes !== null) {
            step.notes = newNotes;
            renderCurrentStage();
            triggerAutosave();
        }
    }
    
    // Add new stage
    function addNewStage() {
        const stageName = prompt('Enter new stage name:');
        if (stageName && stageName.trim()) {
            config.stages.push({
                name: stageName.trim(),
                steps: []
            });
            currentStageIndex = config.stages.length - 1;
            renderStageTabs();
            renderCurrentStage();
            updateProgress();
            triggerAutosave();
        }
    }
    
    // Add new step to current stage
    function addNewStep() {
        if (currentStageIndex < 0 || currentStageIndex >= config.stages.length) {
            showError('No stage selected');
            return;
        }
        
        const stepTitle = prompt('Enter new step title:');
        if (stepTitle && stepTitle.trim()) {
            config.stages[currentStageIndex].steps.push({
                id: stepTitle.toLowerCase().replace(/[^a-z0-9]+/g, '_'),
                title: stepTitle.trim(),
                notes: '',
                command: '',
                done: false,
                userNotes: ''
            });
            renderCurrentStage();
            updateProgress();
            triggerAutosave();
        }
    }
    
    // Raw editor functions
    function showRawEditor() {
        const modal = document.getElementById('rawEditorModal');
        const textarea = document.getElementById('rawEditorContent');
        textarea.value = convertToMarkdown();
        modal.style.display = 'block';
    }
    
    function closeRawEditor() {
        document.getElementById('rawEditorModal').style.display = 'none';
    }
    
    function saveRawEditor() {
        const content = document.getElementById('rawEditorContent').value;
        try {
            // Parse the markdown content
            const { config: configData, markdown } = parseMarkdownFrontMatter(content);
            const { title, stages } = parseMarkdownStages(markdown);
            
            config = {
                title: title,
                config: configData,
                stages: stages
            };
            
            // Re-render everything
            renderTitle();
            renderVars();
            renderStageTabs();
            renderCurrentStage();
            updateProgress();
            
            closeRawEditor();
            triggerAutosave();
            showSuccess('Changes applied from raw editor');
        } catch (e) {
            showError(`Failed to parse markdown: ${e.message}`);
        }
    }
    
    // Version upgrade functions
    function showVersionUpgrade() {
        const modal = document.getElementById('versionUpgradeModal');
        const select = document.getElementById('targetVersionSelect');
        
        // Populate version options
        const currentVer = document.getElementById('selVer').value;
        const verSelect = document.getElementById('selVer');
        select.innerHTML = '<option value="">Select version...</option>';
        
        Array.from(verSelect.options).forEach(opt => {
            if (opt.value !== currentVer) {
                const newOpt = document.createElement('option');
                newOpt.value = opt.value;
                newOpt.textContent = opt.textContent;
                select.appendChild(newOpt);
            }
        });
        
        modal.style.display = 'block';
    }
    
    function closeVersionUpgrade() {
        document.getElementById('versionUpgradeModal').style.display = 'none';
    }
    
    async function confirmVersionUpgrade() {
        const targetVersion = document.getElementById('targetVersionSelect').value;
        if (!targetVersion) {
            showError('Please select a target version');
            return;
        }
        
        const currentClient = document.getElementById('selClient').value;
        const currentVersion = document.getElementById('selVer').value;
        
        try {
            // Archive current notes under #### history in each step
            config.stages.forEach(stage => {
                stage.steps.forEach(step => {
                    if (step.userNotes) {
                        const historyEntry = `\n\n#### History (from v${currentVersion} - ${new Date().toISOString().split('T')[0]})\n${step.userNotes}`;
                        step.userNotes = historyEntry;
                    }
                    // Reset done status
                    step.done = false;
                });
            });
            
            // Update title
            config.title = config.title.replace(currentVersion, targetVersion);
            
            // Update version in config
            if (config.config.version) {
                config.config.version = targetVersion;
            }
            
            // Save to new version folder
            const newPath = `${targetVersion}/${currentClient}.md`;
            const oldPath = CURRENT_YAML_PATH;
            CURRENT_YAML_PATH = newPath;
            FILE_SHA = ""; // New file
            
            await saveData();
            
            // Update UI to show new version
            document.getElementById('selVer').value = targetVersion;
            
            console.log(`[SMAX Tool] Upgraded from ${currentVersion} to ${targetVersion}`);
            showSuccess(`Successfully upgraded to version ${targetVersion}`);
            
            closeVersionUpgrade();
            await loadData();
            
        } catch (e) {
            console.error('[SMAX Tool] Version upgrade error:', e);
            showError(`Version upgrade failed: ${e.message}`);
        }
    }
    
    // Image upload to notes via GitHub API
    async function uploadImageToGitHub(file, noteTextarea) {
        if (!GITHUB_TOKEN) {
            showError('GitHub token required for image upload');
            return;
        }
        
        try {
            // Read file as base64
            const reader = new FileReader();
            reader.onload = async (e) => {
                const base64Content = e.target.result.split(',')[1];
                const fileName = `images/${Date.now()}-${file.name}`;
                const ver = document.getElementById('selVer').value;
                const imagePath = `${ver}/${fileName}`;
                
                // Upload to GitHub
                const response = await fetch(
                    `https://api.github.com/repos/${OWNER}/${REPO}/contents/${imagePath}`,
                    {
                        method: 'PUT',
                        headers: {
                            'Authorization': `token ${GITHUB_TOKEN}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            message: `Upload image ${file.name}`,
                            content: base64Content
                        })
                    }
                );
                
                if (!response.ok) {
                    throw new Error('Failed to upload image');
                }
                
                const result = await response.json();
                const imageUrl = result.content.download_url;
                
                // Insert markdown image link at cursor
                const markdownLink = `\n![${file.name}](${imageUrl})\n`;
                const cursorPos = noteTextarea.selectionStart;
                const textBefore = noteTextarea.value.substring(0, cursorPos);
                const textAfter = noteTextarea.value.substring(cursorPos);
                noteTextarea.value = textBefore + markdownLink + textAfter;
                
                // Trigger preview update
                noteTextarea.dispatchEvent(new Event('input'));
                
                showSuccess('Image uploaded successfully');
            };
            reader.readAsDataURL(file);
        } catch (e) {
            console.error('[SMAX Tool] Image upload error:', e);
            showError(`Image upload failed: ${e.message}`);
        }
    }
    
    // Handle paste events for image upload
    function setupImagePaste(textarea) {
        textarea.addEventListener('paste', async (e) => {
            const items = e.clipboardData.items;
            for (let item of items) {
                if (item.type.indexOf('image') !== -1) {
                    e.preventDefault();
                    const file = item.getAsFile();
                    await uploadImageToGitHub(file, textarea);
                    break;
                }
            }
        });
        
        // Drag and drop support
        textarea.addEventListener('dragover', (e) => {
            e.preventDefault();
            textarea.classList.add('dragging');
        });
        
        textarea.addEventListener('dragleave', () => {
            textarea.classList.remove('dragging');
        });
        
        textarea.addEventListener('drop', async (e) => {
            e.preventDefault();
            textarea.classList.remove('dragging');
            
            const files = e.dataTransfer.files;
            for (let file of files) {
                if (file.type.indexOf('image') !== -1) {
                    await uploadImageToGitHub(file, textarea);
                    break;
                }
            }
        });
    }
</script>
</body>
</html>
